<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Dev Star SJ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Sharing the common developer&apos;s try-on">
<meta property="og:type" content="website">
<meta property="og:title" content="Dev Star SJ">
<meta property="og:url" content="http://DevStarSJ.github.io/page/10/index.html">
<meta property="og:site_name" content="Dev Star SJ">
<meta property="og:description" content="Sharing the common developer&apos;s try-on">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dev Star SJ">
<meta name="twitter:description" content="Sharing the common developer&apos;s try-on">
  
    <link rel="alternate" href="/atom.xml" title="Dev Star SJ" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Dev Star SJ</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">DevStarSJ</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://DevStarSJ.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-02.02.sql.adv" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/23/02.02.sql.adv/" class="article-date">
  <time datetime="2016-01-22T15:00:00.000Z" itemprop="datePublished">2016-01-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Database/">Database</a>►<a class="article-category-link" href="/categories/Database/SQLP/">SQLP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/23/02.02.sql.adv/">SQLP 2-2-1 SET, Hierarchical Query, Sub-query</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2>2과목 SQL 기본 및 활용</h2>
<ul>
<li>20문제</li>
<li>각 상황별로 SQL문 작성이 가능할 정도로 연습해야 합니다.</li>
<li>기본적인 SQL문법 및 함수는 생략하고 Tuning에 활용될수 있는 것 위주로 정리하고자 합니다.</li>
</ul>
<h3>2장 SQL 활용 (#1)</h3>
<h4>1. 집합 연산자 (SET)</h4>
<ul>
<li>UNON : 합집합, 중복된 행은 제거</li>
<li>UNION ALL : 합집합, 중복된 행을 그대로 표시하는 대신에 성능이 빠름</li>
<li>INTERSECT : 교집합, 중복된 행 제거</li>
<li>MINUS : 차집합, 앞의 SQL 결과에서 뒤의 결과를 제거한다. (오라클 이외의 대부분은 EXCEPT로 사용함)</li>
</ul>
<p>솔직히 UNION과 UNION ALL의 차이만 이해하고 있으면 된다.<br>
UNION 과 UNION ALL의 결과가 같다는것이 보장되면 무조건 UNION ALL을 사용하는 것이 성능이 뛰어나다.<br>
INTERSECT 는 EXISTS 나 IN 서브쿼리로 변경이 가능하다. (그러므로 쓸일이 거의 없다.)<br>
MINUS 는 그냥 WHERE의 조건에서 논리적으로 제외시키는 것이 가능하다. (심지어 출력하지 않아도 될 ROW와 거기서 빼야할 ROW들을 읽어야 하므로 성능을 생각해서는 절대로 사용하면 안된다.)</p>
<h4>2. 계층형 질의 (Hierarchical Query)</h4>
<p>계층형 데이터를 조회할때 사용한다.</p>
<blockquote>
<p>계층형 데이터 : 동일 테이블에 계층적으로 상위, 하위 데이터가 포함된 데이터<br>
ex. EMP Table에  EMPNO, MANAGER 가 있으며 EMPNO는 해당 사원의 사원번호, MANAGER는 해당 사원의 부서장 사원번호인 경우</p>
</blockquote>
<p>계층형 질의는 다음과 같은 모양이다. (Oracle 기준)</p>
<ul>
<li>질의 구문</li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ...</div><div class="line">  <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">name</span></div><div class="line"> <span class="keyword">WHERE</span> (filter condition)</div><div class="line"> <span class="keyword">START</span> <span class="keyword">WITH</span> (root condition)                   <span class="comment">-- START WITH MANAGER IS NULL</span></div><div class="line"> <span class="keyword">CONNECT</span> <span class="keyword">BY</span> [<span class="keyword">NOCYCLE</span>] (hierarchical condition) <span class="comment">-- CONNECT BY NOCYCLE PRIOR EMPNO = MANAGER</span></div><div class="line"> [<span class="keyword">ORDER</span> <span class="keyword">SIBLINGS</span> <span class="keyword">BY</span> columns...]</div></pre></td></tr></table></figure></p>
<ul>
<li>START WITH : 시작조건. root data가 되는 조건을 적는다.</li>
<li>CONNECT BY : 부모와 자식의 관계를 적는다. PRIOR 키워드는 전개방향 상 이전 레코드를 가리킨다.</li>
<li>ORDER SIBLINGS BY :(같은 부모를 가진) 형재 node 의 ORDER BY이다.</li>
</ul>
<p>SELECT, FROM, WHERE 등은 일반 SQL문법과 동일하다.</p>
<ul>
<li>가상 칼럼</li>
</ul>
<ul>
<li>LEVEL : ROOT = 1, LEAF방향으로 1씩 증가</li>
<li>CONNECT_BY_ISLEAF : LEAF이면 1, 자식이 있으면 0</li>
<li>CONNECT_BY_ISCYCLE : 자식을 가지면서, 자신이 자기 조상에도 있으면 1, 아니면 0 (CYCLE 옵션에서만 허용)</li>
</ul>
<ul>
<li>전용 함수</li>
</ul>
<ul>
<li>SYS_CONNECT_BY_PATH(column, separator) : Root부터 현재까지의 경로를 표시한다.</li>
<li>CONNECT_BY_ROOT column : root 데이터의 칼럼을 표시한다.</li>
</ul>
<p>START WITH 조건과 CONNECT BY 조건을 어떻게 하냐에 따라서 부모 -&gt; 자식 방향 또는 자식 -&gt; 부모 방향으로의 전개가 가능하다.</p>
<ul>
<li>부모 -&gt; 자식 방향전개
<ul>
<li>START WITH : ROOT 조건</li>
<li>CONNECT BY : PRIOR 자식ID = 부모ID
<ul>
<li>이 부분 해석이 좀 해깔릴수 있는데, EMPNO, MANAGER의 경우 PRIOR EMPNO = MANAGER 로 써야한다.</li>
<li>그냥 START WITH 조건의 row와 전개방향 바로 다음 row의 비교조건을 적는다고 생각하면 됨.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">LPAD</span>(<span class="string">' '</span>, <span class="number">4</span> * (<span class="keyword">LEVEL</span><span class="number">-1</span>)) || <span class="keyword">LEVEL</span> <span class="keyword">AS</span> <span class="string">"LEVEL"</span>, EMPNO, MGR, <span class="keyword">CONNECT_BY_ISLEAF</span> <span class="keyword">AS</span> LEAF</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP</div><div class="line"> <span class="keyword">START</span> <span class="keyword">WITH</span> MGR <span class="keyword">IS</span> <span class="literal">NULL</span></div><div class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">PRIOR</span> EMPNO = MGR</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">SIBLINGS</span> <span class="keyword">BY</span> EMPNO;</div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.01.png?raw=true&quot;&gt;</p>
<ul>
<li>자식 -&gt; 부모 방향전개
<ul>
<li>START WITH : LEAF 조건</li>
<li>CONNECT BY : PRIOR 부모ID = 자식ID</li>
</ul>
</li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">LEVEL</span>, EMPNO, MGR</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP</div><div class="line"> <span class="keyword">START</span> <span class="keyword">WITH</span> EMPNO = <span class="number">7369</span></div><div class="line"> <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">PRIOR</span> MGR = EMPNO;</div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.02.png?raw=true&quot;&gt;</p>
<h4>3. SELF JOIN</h4>
<p>이것도 설명해야 할까 ?<br>
그냥 같은 테이블 2개를 JOIN, alias 필수(그래야 서로 다른 view인듯 제어가 가능하니깐)</p>
<h4>4. Subquery</h4>
<ul>
<li>SQL문 안에 포함되는 SQL문을 의미한다.</li>
<li>반드시 (괄호)로 감싸야한다.</li>
<li>ORDER BY를 사용하지 못한다. (메인 쿼리의 마지막에 한번만 가능하다.)</li>
</ul>
<h5>분류</h5>
<ul>
<li>
<p>동작 방식</p>
<ul>
<li>비연관 (Un-Correlated) : 메인쿼리의 컬럼을 가지고 있지 않음. 메인쿼리에 결과를 제공하기 위한 목적</li>
<li>연관 (Correlated) : 메인쿼리의 칼럼을 가지고 있음. 메인쿼리가 먼저 수행되면서 서브쿼리에서 조건 체크할 목적</li>
</ul>
</li>
<li>
<p>반환되는 데이터 형태</p>
<ul>
<li>Single row : 결과가 1건 이하 (단일행 비교연산자)</li>
<li>Multi row : 결과가 여러 건 (IN, ALL, ANY, SOME, EXISTS 연산자)</li>
<li>Multi column : 결과가 여러 컬럼 (메인쿼리와 비교하자고 하는 컬럼의 위치와 개수가 같아야함)</li>
<li>Scalar Subquery : 1개의 data (1 row 1 column)만 반환. SQL문 중 column이 위치할 수 있는 대부분의 곳에 사용 가능</li>
</ul>
</li>
</ul>
<p>일단 이 2가지 분류방식에 대해서 먼저 이해를 하고, 이제 위치에 따라 올 수 있는 형태를 살펴보겠다.</p>
<h5>1. WHERE에 위치</h5>
<ul>
<li>Single row</li>
</ul>
<p>SCOTT이 속한 부서의 직원목록을 보기 위해서는<br>
먼저 SCOTT의 DEPTNO를 가져와서 해당 값과 같은 직원들을 조회해야 한다.
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP</div><div class="line"> <span class="keyword">WHERE</span> DEPTNO = (<span class="keyword">SELECT</span> DEPTNO <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> ENAME = <span class="string">'SCOTT'</span>) <span class="comment">-- 먼저 수행</span></div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.03.png?raw=true&quot;&gt;</p>
<ul>
<li>Multi row</li>
</ul>
<p>SALEMAN job이 있는 부서와 해당 부서에 있는 CLERK job의 목록을 보기 위해서는<br>
먼저 SALEMAN 이 속한 부서의 DEPTNO를 구한 뒤, 해당 값과 같은 부서인원중 CLERK를 찾아야 한다.
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP</div><div class="line"> <span class="keyword">WHERE</span> JOB = <span class="string">'CLERK'</span></div><div class="line">   <span class="keyword">AND</span> DEPTNO <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DEPTNO <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> JOB = <span class="string">'SALESMAN'</span>) <span class="comment">-- 먼저 수행</span></div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.04.png?raw=true&quot;&gt;</p>
<ul>
<li>Multi column</li>
</ul>
<p>각 팀별 최고연봉자를 출력하기 위해서는<br>
먼저 각 팀별 최고연봉자에 대해서 GROUP BY로 구한 뒤 해당 칼럼정보와 같은 직원정보를 출력하면 된다.
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP</div><div class="line"> <span class="keyword">WHERE</span> (DEPTNO, SAL) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> DEPTNO, <span class="keyword">MAX</span>(SAL) <span class="keyword">AS</span> SAL <span class="keyword">FROM</span> EMP <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO) <span class="comment">-- 먼저 수행</span></div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.05.png?raw=true&quot;&gt;</p>
<ul>
<li>연관 서브쿼리 (Correlated subuery)</li>
</ul>
<p>메인쿼리 칼럼이 서브쿼리 내에서 사용된다.<br>
메인쿼리가 먼저 수행되면서 row마다 서브쿼리를 한번씩 수행하므로 성능상에는 좋지않다.</p>
<p>각 부서별 평균영봉 이상을 받는 직원정보를 출력하고자 하기 위해서는<br>
매 직원정보마다 해당 직원의 연봉이 해당 부서의 평균이상인지를 비교(check)해야 한다.
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP A               <span class="comment">-- 메인쿼리가 먼저 수행되면서 매 ROW마다 아래 서브쿼리 수행</span></div><div class="line"> <span class="keyword">WHERE</span> SAL &gt;= (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(SAL) <span class="keyword">AS</span> SAL <span class="keyword">FROM</span> EMP B <span class="keyword">WHERE</span> B.DEPTNO = A.DEPTNO <span class="keyword">GROUP</span> <span class="keyword">BY</span> B.DEPTNO)</div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.06.png?raw=true&quot;&gt;</p>
<h5>2. SELECT에 위치 (Scalar Subquery)</h5>
<p>대부분 연관(correlated) 관계로 호출한다.<br>
비연관으로 가능하다면 그냥 Inline View로 하는게 더 효과적이다.</p>
<p>직원정보를 호출하면서 소속부서의 평균연봉도 같이 출력할 경우 다음과 같다.
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, ENAME, SAL,</div><div class="line">       <span class="keyword">ROUND</span>((<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(SAL) <span class="keyword">FROM</span> EMP B <span class="keyword">WHERE</span> B.DEPTNO = A.DEPTNO <span class="keyword">GROUP</span> <span class="keyword">BY</span> B.DEPTNO)) <span class="keyword">AS</span> AVG_SAL</div><div class="line">  <span class="keyword">FROM</span> EMP A</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> DEPTNO, SAL;</div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.07.png?raw=true&quot;&gt;</p>
<h5>3. FROM에 위치 (Inline View)</h5>
<p>View나 Table이 올수 있는 위치에는 사용이 가능하다.<br>
해당 query내에서는 마치 dynamic view처럼 사용된다.<br>
사용상 아무런 제약을 받지않고 SELECT문을 자유롭게 쓸 수 있다. (ORDER BY도 사용이 가능하다.)</p>
<p>바로 위에 연관관계로 호출된 Scalar subquery는 성능이 좋지 않으므로 inline view로 고쳐보자.<br>
각 부서별 평균연봉을 dynamic view로 구한 다음 JOIN을 하면 된다.
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> A.DEPTNO, A.ENAME, A.SAL, B.AVG_SAL</div><div class="line">  <span class="keyword">FROM</span> EMP A,</div><div class="line">       (<span class="keyword">SELECT</span> DEPTNO, <span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(SAL)) <span class="keyword">AS</span> AVG_SAL <span class="keyword">FROM</span> EMP <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO) B</div><div class="line"> <span class="keyword">WHERE</span> A.DEPTNO = B.DEPTNO</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> DEPTNO, SAL;</div></pre></td></tr></table></figure></p>
<ul>
<li>TOP-N 쿼리</li>
</ul>
<p>data를 정렬하고 그 중 일부만 추출하고자 할때는 inline view로 ORDER BY를 한 뒤 ROWNUM으로 추출하면 된다.</p>
<p>MANAGER 중 연봉 BEST 2를 순서대로 출력하고자 할 경우 (MANAGER는 총 3명)
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP <span class="keyword">WHERE</span> JOB = <span class="string">'MANAGER'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>)</div><div class="line"> <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt;= <span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.08.png?raw=true&quot;&gt;</p>
<h5>4. HAVING에 위치</h5>
<p>WHERE에 위치와 크게 다르지않다.<br>
하지만 집계함수 사용시 그 결과를 filtering 하는 것이므로 의미상 필요할 경우 사용하면 된다.</p>
<p>부서별 평균연봉이 전체평균연봉보다 큰 부서명을 출력하고자 할 경우
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> C.DNAME, B.AVG_SAL</div><div class="line">  <span class="keyword">FROM</span> DEPT C,</div><div class="line">       (<span class="keyword">SELECT</span> A.DEPTNO, <span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(A.SAL)) <span class="keyword">AS</span> AVG_SAL</div><div class="line">          <span class="keyword">FROM</span> EMP A</div><div class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO</div><div class="line">        <span class="keyword">HAVING</span> <span class="keyword">AVG</span>(A.SAL) &gt;= (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(SAL) <span class="keyword">FROM</span> EMP)) B</div><div class="line"> <span class="keyword">WHERE</span> C.DEPTNO = B.DEPTNO;</div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.09.png?raw=true&quot;&gt;</p>
<h5>5. UPDATE의 SET에 위치</h5>
<p>UPDATE 할 TABLE과 JOIN하여 여러 row에 대한 UPDATE를 한번에 수행이 가능하다.
DEPT table에 AVG_SAL(평균연봉) 컬럼을 추가한 뒤 해당 값을 한번에 넣고자 하는 경우
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> DEPT A</div><div class="line">   <span class="keyword">SET</span> AVG_SAL = (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(SAL) <span class="keyword">AS</span> AVG_SAL <span class="keyword">FROM</span> EMP B <span class="keyword">WHERE</span> B.DEPTNO = A.DEPTNO <span class="keyword">GROUP</span> <span class="keyword">BY</span> B.DEPTNO);</div></pre></td></tr></table></figure></p>
<h5>6. INSERT의 VALUES에 위치</h5>
<p>주로 새로운 값을 추가할 때 기존에 저장된 마지막 일련번호(s/n)의 다음 번호로 저장하고자 할때 사용하며 편하다.
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> EMP (EMPNO, ENAME)</div><div class="line"><span class="keyword">VALUES</span> ((<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(EMPNO) + <span class="number">1</span> <span class="keyword">FROM</span> EMP), <span class="string">'LUNA'</span>);</div></pre></td></tr></table></figure></p>
<h4>5. View</h4>
<p>SELECT 질의문을 이용하여 가상의 table을 선언하는 것이다.<br>
실제로 물리적으로 해당 table이 생성되는 것이 아니라 수행할때마다 DBMS 내부적으로 View의 정의를 참조하여 쿼리를 재정의한다.</p>
<ul>
<li>
<p>View의 장점</p>
<ul>
<li>독립성 : Table의 구조가 변경되어도, View를 사용하는 application은 변경하지 않아도 된다. (물론 View를 변경해줘야 하지만)</li>
<li>편리성 : 자주 이용되는 복잡한 query를 미리 view로 정의해두면 편리하게 재사용이 가능하다.</li>
<li>보안성 : 보안상 숨기고 싶은 데이터에 대해서는 view 생성시 해당 정보를 제외하고 view를 배포하면 된다.</li>
</ul>
</li>
<li>
<p>View 생성방법
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 뷰명칭</div><div class="line"><span class="keyword">AS</span></div><div class="line"><span class="keyword">SELECT</span> ...</div></pre></td></tr></table></figure></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://DevStarSJ.github.io/2016/01/23/02.02.sql.adv/" data-id="cjov1wtlx0001jw7bkal8z2wn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Database/">Database</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQLP/">SQLP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-02.01.sql.basic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/21/02.01.sql.basic/" class="article-date">
  <time datetime="2016-01-20T15:00:00.000Z" itemprop="datePublished">2016-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Database/">Database</a>►<a class="article-category-link" href="/categories/Database/SQLP/">SQLP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/21/02.01.sql.basic/">SQLP 2-1 SQL 기본</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2>2과목 SQL 기본 및 활용</h2>
<ul>
<li>20문제</li>
<li>각 상황별로 SQL문 작성이 가능할 정도로 연습해야 합니다.</li>
<li>기본적인 SQL문법 및 함수는 생략하고 Tuning에 활용될수 있는 것 위주로 정리하고자 합니다.</li>
</ul>
<h3>1장 SQL 기본</h3>
<h4>1.1 SQL 종류</h4>
<ol>
<li>DML (Data Manipulation Language) : 데이터 조작어</li>
</ol>
<ul>
<li>SELECT : 조회</li>
<li>INSERT, UPDATE, DELETE : 데이터에 변형을 가하는 명령어</li>
</ul>
<ol start="2">
<li>DDL (Data Definition Language) : 데이터 정의어</li>
</ol>
<ul>
<li>CREATE, ALTER, DROP, RENAME :  테이블 등의 데이터 구조를 생성, 변경, 삭제하는 명령어</li>
</ul>
<ol start="3">
<li>DCL (Data Control Language) : 데이터 제어어</li>
</ol>
<ul>
<li>GRANT, REVOKE : DB 및 객체의 접근, 사용 권한을 주고 회수하는 명령어</li>
</ul>
<ol start="4">
<li>TCL (Transaction Control Language) : 트랜잭션 제어어</li>
</ol>
<ul>
<li>COMMIT, ROLLBACK : 트랜잭션을 제어하는 명령어</li>
</ul>
<h4>1.2 CREATE TABLE</h4>
<h5>1. 기본적인 생성법</h5>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 테이블명 (</div><div class="line">    컬럼명    DATATYPE    [<span class="keyword">DEFAULT</span> 형식],</div><div class="line">    ...</div><div class="line">    <span class="keyword">CONSTRAINT</span> 테이블명_PK PRIMARY <span class="keyword">KEY</span> (컬럼, ...),</div><div class="line">    <span class="keyword">CONSTRAINT</span> 테이블명_FK FOREIGN <span class="keyword">KEY</span> (컬럼, ...) <span class="keyword">REFERENCES</span> 테이블<span class="number">2</span>(컬럼, ...)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h5>2. CTAS (Create Table as Select)</h5>
<ul>
<li>
<p>Oracle
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> EMP_COPY</div><div class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>MS-SQL
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">INTO</span> EMP_COPY <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<ul>
<li><code>NOT NULL</code> 제약조건을 제외하고는 모두 삭제</li>
</ul>
<h4>1.3 TRUNCATE TABLE vs DROP TABLE, DELETE TABLE</h4>
<ul>
<li>TRUNCATE TABLE
<ul>
<li>DROP TABLE과의 차이점 : Table을 삭제하지 않고 모든 row들을 제거한다.</li>
<li>DELETE TABLE과의 차이점 : 시스템 부하가 훨씬 적인 대신에 복구가 불가능하다. (rollback 불가)</li>
</ul>
</li>
</ul>
<h4>1.4 TRANSACTION</h4>
<h5>특징</h5>
<ul>
<li>원자성 (atomicity) : 모두 정상적으로 실행되거나, 실행되지 않은 상태로 되거나 (all or nothing )</li>
<li>일관성 (consistency) : 실행전에 잘못된 상태가 아니었다면, 실행후에도 잘못이 있으면 안됨</li>
<li>고립성 (isolation) : 도중에 다른 트랜잭션의 영향을 받지 않음</li>
<li>지속성 (durability) : 수행후 갱신한 내용은 영구적으로 저장</li>
</ul>
<h5>명령어</h5>
<ul>
<li>COMMIT : 변경된 상태를 DB에 반영</li>
<li>ROLLBACK : 트랜잭션 수행 이전 상태로 되돌림</li>
<li>SAVEPOINT [저장명칭] : 현시점까지만 ROLLBACK이 가능하도록 SAVEPOINT 지정 (MS-SQL에서는 SAVE TRANSACTION [저장명칭])</li>
<li>ROLLBACK TO [저장명칭] : 해당 SAVEPOINT 까지 ROLLBACK (MS-SQL에서는 ROLLBACK TRANSACTION [저장명칭])</li>
</ul>
<h4>1.5 ROWNUM (Oracle), TOP (MS-SQL)</h4>
<ul>
<li>
<p>ROWNUM : SQL 처리결과 각 행의 임시 일련번호</p>
</li>
<li>
<p>1개의 행만 출력할 경우<br>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> = <span class="number">1</span>;</div><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt;= <span class="number">1</span>;</div><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt; <span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<ul>
<li>n개의 행을 출력할 경우<br>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt;= n;</div><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt; n+<span class="number">1</span>;</div></pre></td></tr></table></figure></li>
</ul>
</li>
<li>
<p>TOP : 출력결과의 행 수를 제한<br>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TOP( n [<span class="keyword">PERCENT</span>] [<span class="keyword">WITH</span> <span class="keyword">TIES</span>] ) ... <span class="keyword">FROM</span> ...;</div></pre></td></tr></table></figure></p>
<ul>
<li>n : n의 갯수 만큼 행을 출력</li>
<li>PERCENT : n % 만큼 출력</li>
<li>WITH TIES : 마지막 행과 동일한 값과 동일한 값은 추가로 같이 출력</li>
</ul>
</li>
</ul>
<h4>1.6 CASE</h4>
<ul>
<li>프로그래밍의 IF-THEN-ELSE와 비슷한 표현식입니다.</li>
</ul>
<h5>1. 단순비교 : 해당 값에 따라 분류</h5>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CASE value WHEN 1 THEN 'one'</div><div class="line">           WHEN 2 THEN 'two'</div><div class="line">           ELSE NULL</div><div class="line"><span class="keyword">END</span></div></pre></td></tr></table></figure></p>
<h5>2. 조건비교 : 해당 조건에 따라 분류</h5>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CASE WHEN value = 1 THEN 'one'</div><div class="line">     WHEN value = 2 THEN 'two'</div><div class="line">     ELSE NULL</div><div class="line"><span class="keyword">END</span></div></pre></td></tr></table></figure></p>
<h5>3. DECODE : 단순비교를 보다 짧게 표한하는 Oracle 함수</h5>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DECODE(value, 1,'one', 2,'two', NULL)</div></pre></td></tr></table></figure></p>
<h4>1.7 NULL</h4>
<ul>
<li>NULL 관련 문제는 반드시 출제된다.</li>
</ul>
<h5>NVL (Oracle), ISNULL (MS-SQL)</h5>
<p>해당 값이 NULL일 경우 2번째 인자의 값을 출력한다.
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> NVL(SAL,<span class="number">0</span>) <span class="keyword">FROM</span> EMP; <span class="comment">-- Oracle</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">ISNULL</span>(SAL,<span class="number">0</span>) <span class="keyword">FROM</span> EMP; <span class="comment">-- MS-SQL</span></div></pre></td></tr></table></figure></p>
<h5>COALESCE</h5>
<p>인수 중 최초로 NULL이 아닌 값을 출력한다. 모두 NULL인 경우 NULL이 출력된다.
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, COMM, SAL, <span class="keyword">COALESCE</span>(COMM, SAL) COAL <span class="keyword">FROM</span> EMP;</div></pre></td></tr></table></figure></p>
<p>위 문장은 아래의 CASE문으로 표현한 것과 같다.
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, COMM, SAL,</div><div class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> COMM <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> COMM</div><div class="line">            <span class="keyword">WHEN</span> SAL <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> SAL</div><div class="line">            <span class="keyword">ELSE</span> <span class="literal">NULL</span></div><div class="line">       <span class="keyword">END</span> COAL</div><div class="line">  <span class="keyword">FROM</span> EMP;</div></pre></td></tr></table></figure></p>
<h4>1.8 집계함수 (Aggregate function)</h4>
<ul>
<li>GROUP 당 단 1개의 값만 출력하는 함수</li>
<li>SELECT , HAVING, ORDER BY 절에서 사용할 수 있다.</li>
<li>집계함수에 들어온 NULL값은 계산에 포함시키지 않는다. (참고로 산술연산에 NULL 값이 포함되어 있으면 결과는 무조건 NULL이다.)</li>
</ul>
<h5>SELECT</h5>
<p>GROUP BY에 명시된 컬럼, 집계함수의 결과값 만 가능하다.</p>
<h5>GROUP BY</h5>
<p>여기에 명시한 컬럼, 표현식 단위로 집계함수를 이용하여 계산한다.</p>
<h5>WHERE</h5>
<p>여기에 적은 조건에 부합하는 row만 집계함수 계산에 참여한다. (GROUP BY 이전 필터링 역할)</p>
<h5>HAVING</h5>
<p>집계된 결과 중 HAVING 절의 조건에 만족하는 것만 출력한다. (GROUP BY 이후 필터링 역할)</p>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> D.DEPTNO, <span class="keyword">MAX</span>(DNAME) <span class="keyword">AS</span> DNAME, <span class="keyword">SUM</span>(SAL) <span class="keyword">AS</span> <span class="keyword">SUM</span>, <span class="keyword">AVG</span>(SAL) <span class="keyword">AS</span> <span class="keyword">AVG</span></div><div class="line">  <span class="keyword">FROM</span> DEPT D, EMP E</div><div class="line"> <span class="keyword">WHERE</span> D.DEPTNO = E.DEPTNO</div><div class="line">   <span class="keyword">AND</span> D.DEPTNO <span class="keyword">IN</span> (<span class="number">10</span>, <span class="number">30</span>)     <span class="comment">-- DEPTNO가 10, 30 인것만 집계로 계산</span></div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> D.DNAME</div><div class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(SAL) &gt;= <span class="number">10000</span>        <span class="comment">-- 계산된 결과중 10000이 넘는 것만 출력</span></div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">SUM</span>(SAL);</div></pre></td></tr></table></figure></p>
<h5>SELECT 문장 실행순서</h5>
<ol>
<li>FROM : 대상 Table 검색</li>
<li>WHERE : 검색 대상이 아닌 데이터 제거</li>
<li>GROUP BY : 집계할 단위로 그룹화</li>
<li>HAVING : 집계한 것중 조건에 맞는 것만 선택</li>
<li>SELECT : 출력할 값들을 계산 및 함수적용</li>
<li>ORDER BY : 데이터를 정렬하여서 출력</li>
</ol>
<h5>CASE - GROUP BY</h5>
<p>1정규화로 모델링된 테이블들에서 보고서를 만들때 많이 사용되는 기법이다.</p>
<p>예를 들어서 각 부서별로 입사월별 급여합계가 필요한 경우가 있다고 가정했을 때</p>
<p>먼저 부서, 사원명, 입사월, 급여를 출력해보자.</p>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, DEPTNO, <span class="keyword">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> HIREDATE) M, SAL</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.01.decode.01.png?raw=true&quot;&gt;</p>
<p>위 문장을 이용하여 각 월별로 컬럼을 생성하여 해당 월에 급여를 출력해보자.<br>
(CASE랑 기능이 같은 DECODE를 사용하겠다.)</p>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, DEPTNO,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">1</span>,SAL) <span class="keyword">AS</span> M01,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">2</span>,SAL) <span class="keyword">AS</span> M02,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">3</span>,SAL) <span class="keyword">AS</span> M03,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">4</span>,SAL) <span class="keyword">AS</span> M04,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">5</span>,SAL) <span class="keyword">AS</span> M05,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">6</span>,SAL) <span class="keyword">AS</span> M06,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">7</span>,SAL) <span class="keyword">AS</span> M07,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">8</span>,SAL) <span class="keyword">AS</span> M08,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">9</span>,SAL) <span class="keyword">AS</span> M09,</div><div class="line">       <span class="keyword">DECODE</span>(M,<span class="number">10</span>,SAL) <span class="keyword">AS</span> M10,</div><div class="line">       <span class="keyword">DECODE</span>(M,<span class="number">11</span>,SAL) <span class="keyword">AS</span> M11,</div><div class="line">       <span class="keyword">DECODE</span>(M,<span class="number">12</span>,SAL) <span class="keyword">AS</span> M12</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> ENAME, DEPTNO, <span class="keyword">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> HIREDATE) M, SAL</div><div class="line">          <span class="keyword">FROM</span> SCOTT.EMP )</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> DEPTNO, ENAME;</div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.01.decode.02.png?raw=true&quot;&gt;</p>
<p>이제 위 문장을 부서별로 GROUP BY 하는건 어렵지 않을 것이다.<br>
참고로 NULL인 경우 0으로 표시하도록 NVL을 이용하였다.</p>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">1</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M01,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">2</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M02,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">3</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M03,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">4</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M04,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">5</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M05,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">6</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M06,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">7</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M07,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">8</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M08,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">9</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M09,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M,<span class="number">10</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M10,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M,<span class="number">11</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M11,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M,<span class="number">12</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M12</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> ENAME, DEPTNO, <span class="keyword">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> HIREDATE) M, SAL</div><div class="line">          <span class="keyword">FROM</span> SCOTT.EMP )</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO;</div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.01.decode.03.png?raw=true&quot;&gt;</p>
<h4>1.9 JOIN</h4>
<p>JOIN은 한번에 2개의 집합간에만 가능하다.<br>
FROM A, B, C, D 가 있더라도 이 중 2개를 먼저 JOIN하고 그 결과를 다음과 JOIN하는 식으로 처리된다.</p>
<p>JOIN에 대해서는 2장에서 자세히 다루려했으나...<br>
거기에 시간을 빼았겨서는 안될듯하여 그냥 여기서 간단히 다루겠습니다.</p>
<h5>JOIN 연산</h5>
<ul>
<li>EQUI JOIN</li>
</ul>
<p>일반적으로 PK - FK 의 관계에서 많이 이루어진다.<br>
WHERE 절이나 ON 절에서 <code>=</code> 연산으로 JOIN 한다.</p>
<ul>
<li>Non EQUI JOIN</li>
</ul>
<p><code>=</code>연산이 아닌 연산으로 JOIN을 수행한다. ( BETWEEN, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;, != )</p>
<p>예를 들어 SALGRADE Table에 각 급여구간별 GRADE가 저장된 경우, EMP의 각 사원별로 급여등급을 구하고자할때 다음과 같이 작성하면 된다.</p>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> E.ENAME, E.DEPTNO, E.SAL, G.GRADE</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP E, SCOTT.SALGRADE G</div><div class="line"> <span class="keyword">WHERE</span> E.SAL <span class="keyword">BETWEEN</span> G.LOSAL <span class="keyword">AND</span> G.HISAL</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure></p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.01.nonEQ.png?raw=true&quot;&gt;</p>
<h5>JOIN 종류</h5>
<ul>
<li>
<p>INNER JOIN</p>
<ul>
<li>양쪽 Table 모두 조건에 해당되는 데이터만 출력 (교집합)</li>
<li>Natural JOIN : INNER JOIN 에서 중복된 컬럼은 한번만 출력됨
<ul>
<li>모든 일치된 칼럼에 대해서 JOIN 되지만, USING으로 원하는 컬럼만 선택이 가능 (실제로 해보니 USING 안쓰면 ERROR)
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP E, DEPT D <span class="keyword">WHERE</span> E.DEPTNO = D.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * EMP E <span class="keyword">INNER</span> <span class="keyword">JOIN</span> DEPT D <span class="keyword">ON</span> E.DEPTNO = D.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP NATUAL <span class="keyword">JOIN</span> DEPT <span class="keyword">USING</span> (DEPTNO);</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>
<p>OUTER JOIN</p>
<ul>
<li>LEFT OUTER JOIN : 왼쪽 Table의 모든 row 출력, 오른쪽 Table에는 조건에 맞으면 출력하고 아니면 NULL</li>
<li>RIGHT OUTER JOIN : 오른쪽 Table의 모든 row 출력, 왼쪽 Table에는 조건에 맞으면 출력하고 아니면 NULL</li>
<li>FULL OUTER JOIN : 좌,우측을 모두 읽어서 서로 상대에게 있으면 출력 없으면 NULL (LEFT OUTER와 RIGHT OUTER를 UNION 한거랑 결과가 같음)</li>
</ul>
</li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP E <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> SCOTT.DEPT D <span class="keyword">ON</span> E.DEPTNO = D.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP E <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> SCOTT.DEPT D <span class="keyword">ON</span> E.DEPTNO = D.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP E <span class="keyword">FULL</span> <span class="keyword">JOIN</span> SCOTT.DEPT D <span class="keyword">ON</span> E.DEPTNO = D.DEPTNO;</div></pre></td></tr></table></figure></p>
<ul>
<li>CROSS JOIN (CARTESIAN PRODUCT)
<ul>
<li>양쪽 Table의 모든 row 들을 모두 관계짓는다. (A에 10개 row, B에 5개 row가 있을 경우 결과는 10 x 5 = 50개가 된다.)</li>
</ul>
</li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> SCOTT.DEPT;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP, SCOTT.DEPT;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://DevStarSJ.github.io/2016/01/21/02.01.sql.basic/" data-id="cjov1wtm80004jw7bybmyzh0f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Database/">Database</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQLP/">SQLP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-01.02.modeling_performance" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/20/01.02.modeling_performance/" class="article-date">
  <time datetime="2016-01-19T16:00:00.000Z" itemprop="datePublished">2016-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Database/">Database</a>►<a class="article-category-link" href="/categories/Database/SQLP/">SQLP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/20/01.02.modeling_performance/">SQLP 1-2 데이터 모델과 성능</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>1과목 데이터 모델링의 이해</h1>
<ul>
<li>10문제</li>
<li>외우기 보다는 반복적으로 읽어서 전반적인 내용을 이해하는 수준에서 마무리 하는것을 목표로 잡아야 겠습니다.</li>
</ul>
<h2>제 2장 데이터 모델과 성능</h2>
<h3>1절 성능 데이터 모델링의 개요</h3>
<ul>
<li>성능 데이터 모델링이란 ? 성능향상을 목적으로 모델링 하는 것</li>
<li>수행시점은 ? 빠르면 빠를수록 좋다. 분석/설계 단계에서는 운영때보다 더 적은 비용으로 가능하다.</li>
</ul>
<h4>성능 모델링 고려사항</h4>
<ol>
<li>기본적으로 정규화를 수행해놓고 시작한다.</li>
<li>데이터베이스 용량산정</li>
<li>데이터베이스 트랜잭션 유형 파악</li>
<li>용량과 트랜잭션 유형에 따라 반정규화 수행</li>
<li>이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정</li>
<li>성능관점의 데이터 모델 검증</li>
</ol>
<p>일단 정규화를 완벽하게 해놓고 시작해야 한다.<br>
그 상태에서 어느 엔터티에 트랜잭션이 들어오는지 알아봐야 하는데,<br>
가장 간단한 방법이 용량이 집중적으로 늘어나는 엔터티를 찾는 것이다.<br>
트랜잭션 유형도 파악할 필요가 있는데, CRUD, 시퀀스 다이어그램 등을 참조하면 된다.<br>
파악된 트랜잭션 유형으로 SQL문장의 조인관계 테이블의 칼럼들을 파악할 수 있으며,<br>
이렇게 모은 자료를 근거로 반정규화를 적용한다.<br>
그 다음에 성능을 고려하야 PK/FK를 성능이 우수한 순서대로 칼럼 순서를 조정한다.<br>
데이터 모델 규칙보다는 성능적인 측면을 충분히 고려해야 한다.</p>
<h3>2절 정규화와 성능</h3>
<p>일반적으로 정규화를 하면 조회시 JOIN이 늘어나기 때문에 성능이 저하되고,<br>
DML (INSERT, UPDATE, DELETE) 연산의 성능이 향상된다.<br>
하지만 모든 조회에서 성능이 저하되는 것은 아니고, 정규화를 해야만 성능이 향상되는 경우도 아주 많다.</p>
<h5>정규화가 더 빠른 사례 1 : 컬럼이 많을 경우 (버퍼 낭비)</h5>
<p>원래 (반정규화된) 테이블에는 컬럼이 10개가 있었다.<br>
조회시 해당 테이블에서 PK를 제외하고 2개의 컬럼만 자주 읽힌다.
오랜기간 동안의 이력중 PK 포함 그 3개의 컬럼만 자주 읽을 경우라면,
나머지 컬럼들을 PK값에 종속적인 테이블로 따로 분리를 하는 것이 유리하다.</p>
<h5>정규화가 더 빠른 사례 2 : DISTINCT를 써야 할 경우</h5>
<ul>
<li>일자별 거래물건 (100만건) : 물건번호(PK), 일자, 시간, 장소, ...</li>
<li>일자별 거래내역 (2만건) : (일자, 장소) (PK) 금액, 건수, ...</li>
</ul>
<p>광화문에서 거래된 금액을 구하는 SQL문은 다음과 같다.</p>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> B.금액</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 일자, 장소 <span class="keyword">FROM</span> 일자별거래물건 <span class="keyword">WHERE</span> 장소 = <span class="string">'광화문`) A, -- 100만건을 DISTINCT</span></div><div class="line">       일자별거래내역 B</div><div class="line"> WHERE A.일자 = B.일자</div><div class="line">   AND A.장소 = B.장소</div></pre></td></tr></table></figure></p>
<p>만약 위에서 DISTICT 한 결과가 5천건이라면, (일자, 장소) 를 별도의 테이블로 생성하는 것이 유리하다.</p>
<ul>
<li>일자별 거래물건 (100만건) : 물건번호(PK), 일자(FK), ...</li>
<li>거래 (5천건) : 일자(PK), 시간, 장소</li>
<li>일자별 거래내역 (2만건) : (일자(FK), 장소) (PK) , 금액, 건수, ...</li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> B.금액</div><div class="line">  <span class="keyword">FROM</span> 거래 A, 일자별거래내역 B</div><div class="line"> <span class="keyword">WHERE</span> A.장소 = <span class="string">'광화문'</span> <span class="comment">-- 5천건</span></div><div class="line">   <span class="keyword">AND</span> A.일자 = B.일자</div><div class="line">   <span class="keyword">AND</span> A.장소 = B.장소</div></pre></td></tr></table></figure></p>
<h5>정규화가 더 빠른 사례 3 : 동일한 속성 형식이 여러개 나열된 경우</h5>
<p>한 테이블에 속성1, 속성2, 속성3, ... 이 여러개 있고, 각각에 INDEX가 걸려 있는 경우를 말한다.<br>
이런 경우 DML 작업에서의 성능저하 때문에 INDEX를 두지 않거나, 1개 정도만 만드는 경우가 많다.<br>
각 속성에 부합하는 데이터를 찾는 SQL문은 다음과 같다.</p>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ...</div><div class="line">  <span class="keyword">FROM</span> 장비</div><div class="line"> <span class="keyword">WHERE</span> 속성<span class="number">1</span> = <span class="string">'1'</span></div><div class="line">    <span class="keyword">OR</span> 속성<span class="number">2</span> = <span class="string">'2'</span></div><div class="line">    <span class="keyword">OR</span> 속성<span class="number">3</span> = <span class="string">'3'</span></div><div class="line">   ...</div></pre></td></tr></table></figure></p>
<p>각각의 속성에 모두 INDEX를 걸어둔 경우가 아니라면 Full Scan이나 Index Range Scan으로 넓은 범위를 찾아야 한다.</p>
<p>위 Table을 아래와 같이 먼저 정규화를 수행한다.</p>
<ul>
<li>장비 : 장비코드(PK), ... (속성들은 모두 제외)</li>
<li>속성 : (장비코드(FK), 속성코드) (PK), 속성값</li>
</ul>
<p>위 상태에서는 속성 테이블에 PK로 인하여 INDEX가 생성되어 있으므로 조회시 성능이 향상된다.
조회는 다음과 같이 수행하면 된다.
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ...</div><div class="line">  <span class="keyword">FROM</span> 장비 A, 속성 B</div><div class="line"> <span class="keyword">WHERE</span> A.장비코드 = B.장비코드</div><div class="line">   <span class="keyword">AND</span> (   (B.속성코드 = <span class="string">'1'</span> <span class="keyword">AND</span> B.속성값 = <span class="string">'1'</span>)</div><div class="line">        <span class="keyword">OR</span> (B.속성코드 = <span class="string">'2'</span> <span class="keyword">AND</span> B.속성값 = <span class="string">'2'</span>)</div><div class="line">        <span class="keyword">OR</span> (B.속성코드 = <span class="string">'3'</span> <span class="keyword">AND</span> B.속성값 = <span class="string">'3'</span>) )</div></pre></td></tr></table></figure></p>
<p>위와 같이 속성1, 2, 3 뿐만 아니라 이력 같은 데이터를 함께 보관하면서<br>
장기재고 1개월 수량,금액 , 2개월 수량,금액 , 3개월 수량,금액 과 같은 형식의 컬럼이 있는경우<br>
재고기간 별 수량,금액 을 별도 테이블로 분리하는 것이 유리하다.</p>
<h2>3절 반정규화와 성능</h2>
<ul>
<li>반정규화란 ?</li>
</ul>
<p>성능향상, 개발, 운영의 편리를 위하여 데이터 중복을 각오하고 테이블을 통합하는 것을 의미한다.<br>
단순히 JOIN이 귀찮아서 컬럼들을 통합하다가는 데이터의 무결성을 깨트리게 된다.</p>
<h3>3.1 반정규화 적용방법</h3>
<ol>
<li>반정규화 대상조사</li>
</ol>
<ul>
<li>자주 사용되는 table에 range-scan을 하는 경우</li>
<li>대량의 데이터가 있는 table에 range-scan을 하는 경우</li>
<li>통계성 프로세스에서 통계정보를 필요로 할때 -&gt; 별도의 통계테이블 생성 (반정규화)</li>
<li>지나치게 많은 JOIN으로 조회 작업이 기술적으로 어려워 질때</li>
</ul>
<ol start="2">
<li>대안 검토 (반정규화가 아닌 다른 방법들)</li>
</ol>
<ul>
<li>지나치게 많은 JOIN -&gt; View 생성</li>
<li>대량의 데이터 처리, 부분처리가 유리한 경우 -&gt; 클러스터링 적용 또는 INDEX 조정 (단 DML이 적고 조회 위주의 테이블에만 효과적)</li>
<li>대량의 데이터를 PK 성격에 따라 분리가 가능한 경우라면 -&gt; 파티셔닝 기법 적용해서 물리적으로 분리</li>
<li>Application 로직을 변경하여 성능 개선</li>
</ul>
<ol start="3">
<li>반정규화 적용</li>
</ol>
<ul>
<li>테이블 반정규화</li>
<li>속성 반정규화</li>
<li>관계 반정규화</li>
</ul>
<p>###3.2 반정규화 기법</p>
<ol>
<li>테이블 반정규화</li>
</ol>
<ul>
<li>테이블 병합 : 1:1 , 1:M , 슈퍼/서브타입 관계의 테이블들을 병합하여 성능향상</li>
<li>테이블 분할
<ul>
<li>수직분할 : 컬럼단위로 테이블을 1:1로 분리하여 트랜잭션을 분산 (트랜잭션의 유형이 선행되어야 함)</li>
<li>수평분할 : row 단위로 테이블을 분리하여 트랜잭션을 분산</li>
</ul>
</li>
<li>테이블 추가
<ul>
<li>중복테이블 추가 : 원격 등의 환경에서 서버가 다른 경우 동일한 테이블 중복생성</li>
<li>통계테이블 추가 : 통계값을 미리 계산해 둠</li>
<li>이력테이블 추가 : 마스터 테이블에 존재하는 레코드를 중복으로 이력테이블에 저장</li>
<li>부분테이블 추가 : 자주 이용하는 집중화된 칼럼들을 모아놓은 별도 테이블 생성</li>
</ul>
</li>
</ul>
<ol start="2">
<li>컬럼 반정규화</li>
</ol>
<ul>
<li>중복칼럼 추가 : JOIN을 줄이기 위함</li>
<li>파생칼럼 추가 : 미리 계산하여 저장</li>
<li>이력테이블 칼럼추가 : 이력테이블은 대용량이므로 처리속도가 느림. 그 중 자주 사용되는 컬럼을 추가 (최근값, 시작, 종료일자...)</li>
<li>PK에 의한 칼럼추가 : 복합의미 단일PK의 경우, 그 중 특정 값만 자주 사용한다면 일반속성으로 추가</li>
<li>응용시스템 오작동을 위한 칼럼추가 : 잘못 처리되었을 경우를 대비한 백업용 칼럼</li>
</ul>
<ol start="3">
<li>관계 반정규화</li>
</ol>
<ul>
<li>중복관계 추가 : 여러 경로를 거쳐야 하는 JOIN을 줄이고자 관계추가</li>
</ul>
<h3>반정규화가 더빠른 사례 1 : 이력테이블의 최근값이 필요한 경우</h3>
<ul>
<li>고객 Table : 고객번호(PK), 고객명</li>
<li>전화번호 Table : (고객번호(FK), 순번) (PK) , 전화번호</li>
<li>메일주소 Table : (고객번호(FK), 순번) (PK) , 메일주소</li>
</ul>
<p>고객의 전화번호, 메일주소의 변경이력까지 같이 관리해야 할 경우 위와 같이 전화번호, 메일주소를 별도의 Table로 관리하여야 한다.<br>
이 경우 특정 고객의 가장 최근 전화번호와 메일주소를 알고 싶다면 아래와 같이 SQL문을 작성해야 한다.</p>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> A.고객명, D.전화번호, G.메일주소</div><div class="line">  <span class="keyword">FROM</span> 고객 A,</div><div class="line">       (<span class="keyword">SELECT</span> B.고객번호 B.전화번호</div><div class="line">          <span class="keyword">FROM</span> 전화번호 B,</div><div class="line">               (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(순번) <span class="keyword">FROM</span> 전화번호 <span class="keyword">WHERE</span> 고객번호 = :custNo) C</div><div class="line">         <span class="keyword">WHERE</span> B.고객번호 = C.고객번호) D,</div><div class="line">        (<span class="keyword">SELECT</span> E.고객번호 E.메일주소</div><div class="line">          <span class="keyword">FROM</span> 메일주소 E,</div><div class="line">               (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(순번) <span class="keyword">FROM</span> 메일주소 <span class="keyword">WHERE</span> 고객번호 = :custNo) F</div><div class="line">         <span class="keyword">WHERE</span> E.고객번호 = F.고객번호) G,</div><div class="line"> <span class="keyword">WHERE</span> A.고객번호 = D.고객번호</div><div class="line">   <span class="keyword">AND</span> A.고객번호 = G.고객번호</div></pre></td></tr></table></figure></p>
<p>고객 Table에 최근전화번호, 최근메일주소 칼럼을 추가하여 관리할 경우에는 SQL문을 더 쉽게 작성이 가능하다.</p>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> 고객명, 최근전화번호, 최근메일주소</div><div class="line">  <span class="keyword">FROM</span> 고객</div><div class="line"> <span class="keyword">WHERE</span> 고객번호 = :custNo</div></pre></td></tr></table></figure></p>
<h3>반정규화가 더빠른 사례 2 : 원격서버와 JOIN할 경우</h3>
<ul>
<li>서버 A
<ul>
<li>부서 Table : 부서코드(PK), 부서명</li>
<li>접수 Table : (접수번호, 부서코드(FK))(PK), ...</li>
</ul>
</li>
<li>서버 B
<ul>
<li>연계 Table : (연계번호, (접수번호, 부서코드)(FK))(PK), 연계상태, 연계일자, ...</li>
</ul>
</li>
</ul>
<p>특정 일자 사이의 부서명에 따른 연계상태를 알고 싶은 경우 아래와 같이 SQL을 작성해야 한다.</p>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> A.부서명, C.연계상태</div><div class="line">  <span class="keyword">FROM</span> 부서 A, 접수 B, 연계 C</div><div class="line"> <span class="keyword">WHERE</span> A.부서코드 = B.부서코드</div><div class="line">   <span class="keyword">AND</span> B.부서코드 = C.부서코드 <span class="keyword">AND</span> B.접수번호 = C.접수번호 <span class="comment">-- 서버A와 서버B의 원격 JOIN이 발생</span></div><div class="line">   <span class="keyword">AND</span> C.연계일자 <span class="keyword">BETWEEN</span> :startdate <span class="keyword">AND</span> :enddate</div></pre></td></tr></table></figure></p>
<p>원격 JOIN이 일어나서 성능이 저하 될수 있다.<br>
부서명 칼럼을 연계 Table에 중복생성하면 원격JOIN을 없앨수 있다.</p>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> 부서명, 연계상태</div><div class="line">  <span class="keyword">FROM</span> 연계</div><div class="line"> <span class="keyword">WHERE</span> 연계일자 <span class="keyword">BETWEEN</span> :startdate <span class="keyword">AND</span> :enddate</div></pre></td></tr></table></figure></p>
<p>하지만, 반정규화를 할 경우 데이터 입력, 수정, 삭제시 성능이 저하 된다는 점을 명심해야 한다.</p>
<h2>4절 대량 데이터에 따른 성능</h2>
<h3>4.1 칼럼 수가 많은 경우</h3>
<ul>
<li>많은 DISK I/O 및 buffer miss를 발생시킨다. : 레코드 크기가 거져서 블록 당 적제된 레코드 수가 줄어든다.</li>
<li>200개가 넘는 컬럼의 데이터를 한번에 다 조회할 일이 과연 얼마나 될까 ? 화면에 다 표현은 가능한가 ?</li>
</ul>
<p>테이블을 분리시키는 방법이 있다.<br>
도서관에서 관리하는 아래와 같은 table을 살펴보자.</p>
<ul>
<li>도서정보 Table : 도서번호(PK), 위치, 수량, 책정보관련 칼럼 10여개, 전자출판관련 칼럼 10여개, 대체제품관련 칼럼 10여개, ...</li>
</ul>
<p>위의 경우 전자출판관련 정보나 대체제품관련 정보는 자주 이용되지 않는 항목이라면 별도의 table로 분리하는게 효과적이다.</p>
<ul>
<li>도서정보 Table : 도서번호(PK), 위치, 수량, 책정보관련 칼럼 10여개, ...</li>
<li>전자출판 Table : 도서번호(FK, PK), 전자출판관련 칼럼 10여개</li>
<li>대체제품 Table : 도서번호(FK, PK), 대체제품관련 칼럼 10여개</li>
</ul>
<h3>4.2 테이블에 데이터가 많은 경우</h3>
<ul>
<li>파티션(partition)을 적용하여 레코드를 분리하면 된다.</li>
<li>파티션 종류
<ul>
<li>Range Partition : PK값의 범위별로 분리 (ex. 핸드폰요금 Table의 경우 요금일자를 범위로 하여 매 달마다 파티션 분리)</li>
<li>List Partition : PK의 특정값별로 분리 (ex. 핸드폰대리점 Table의 경우 사업소의 위치지역 별로 파티션 분리)</li>
<li>Hash Partition : PK의 해쉬값으로 분리 (범위 검색이 안되며, 데이터 보관주기를 통한 삭제 등의 관리가 어렵다.)</li>
</ul>
</li>
</ul>
<h3>4.3 테이블의 수평/수직 분할 절차</h3>
<ol>
<li>데이터 모델링 완성</li>
<li>데이터베이스 용량산정</li>
</ol>
<ul>
<li>어느 테이블에 데이터가 대용량화 되는지 분석</li>
</ul>
<ol start="3">
<li>대량 데이터가 처리되는 테이블의 트랜잭션 처리 패턴 분석</li>
</ol>
<ul>
<li>대용량화 테이블에 컬럼수가 많은가 ?</li>
<li>대용량화 테이블에 레코드수가 많은가 ?</li>
</ul>
<ol start="4">
<li>컬럼 단위 집중화, 로우 단위 집중화를 분석하여 테이블 분리 검토</li>
</ol>
<ul>
<li>트랜잭션에서 많은 컬럼들을 항상 다 사용하는가 ? 테이블 분리가 가능한가 ?</li>
<li>트랜잭션에서 특정 범위 단위로 작업을 많이 하는가 ? 해당 범위별로 파티셔닝이 가능한가 ?</li>
</ul>
<h2>5절 데이터베이스 구조와 성능</h2>
<h3>5.1 슈퍼/서브타입 데이터 모델링</h3>
<ul>
<li>공통부분을 슈퍼타입으로 모델링하고 이를 상속받아서 차이가 있는 속성별로 별도의 서브엔터티로 구분</li>
<li>논리적 데이터 모델링, 분석단계에서 사용됨</li>
<li>물리적으로는 3가지 형태로 구현함 ( One to One Type (1:1) , Plus Type (슈퍼+서브), Single Type (All in One) )</li>
<li>트랜잭션의 유형을 보고 각각의 형태로 구현해야 한다.</li>
</ul>
<h5>1. 개별로 발생하는 트랜잭션에는 개별로 구현하는게 유리 (1:1)</h5>
<p>부동산거래 관리 어플리케이션에서 계약 내역에 이해관계자들(매수인,매도인,중개인)이 표시가 되고 상세를 눌렀을 경우 해당 인물에 대한 상세정보가 나오는 경우라면 이해관계자들을 별도의 테이블로 관리하는 것이 좋습니다.</p>
<ul>
<li>계약 Table : 계약번호(PK), ... , 중개인번호(FK), 매도인번호(FK), 매수인번호(FK)</li>
<li>이해관계자 Table : 이해관계자번호(FK) , 역할, ...</li>
</ul>
<h5>2. 슈파타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입으로 구분</h5>
<p>위 예제에서 중개인이 10만명, 매수인이 500만명, 매도인이 500만명인 경우 (즉, 이해관계자 Table은 1010만건)
중개인에 대한 처리가 필요한 경우 최대10만건의 데이터가 필요한데 최대1010만건을 읽을 경우도 발생할 수 있다.
이럴때는 슈퍼/서브타입으로 분리하는 것이 좋다.</p>
<ul>
<li>계약 Table : 계약반호(PK), ...</li>
<li>이해관계자 Table : 계약번호(PK), 중개인번호(FK), 매도인번호(FK), 매수인번호(FK)</li>
<li>중개인 Table : 중개인번호(PK), ...</li>
<li>매도인 Table : 매도인번호(PK), ...</li>
<li>매수인 Table : 매수인번호(PK), ...</li>
</ul>
<h5>3. 전체를 하나로 묶어서 트랜잭션이 발생하는 경우</h5>
<p>항상 계약관련 사항을 조회하는데, 각 이해관계자들의 정보까지 동시에 화면에 출력이 되는 경우라면 하나의 테이블로 관리하는게 유리하다.</p>
<ul>
<li>계약 Table : 계약번호(PK), ... , 중개인 정보들, 매도인 정보들), 매수인 정보들</li>
</ul>
<h3>5.2 INDEX 특성을 고려한 PK/FK 설정</h3>
<ul>
<li>PK는 Unique Index를 자동으로 생성한다. 이하 생략 (자세한 내용은 뒤에 나올 Index 부분을 참조)</li>
<li>FK도 Index를 생성한다. FK가 없어도 WHERE 절에서 조건을 적어주는 것으로 SQL 작성이 가능하지만, Full Table Scan이 될 수 있다. 가능하면 일단 FK를 생성하는 것을 기본 정책으로하고, 트랜잭션을 분석하여 거의 활용되지 않을때는 지우는 것이 적절한 방법이다.</li>
</ul>
<h2>6절 분산 데이터베이스와 성능</h2>
<h3>6.1 분산 데이터베이스의 투명성(transparency) : 6가지 조건을 만족해야 한다.</h3>
<ul>
<li>분할 투명성 (단편화) : 하나의 논리적인 relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장</li>
<li>위치 투명성 : 위치정보는 system catalog에 유지되어야 하며, 사용자가 데이터 사용시는 명시할 필요가 없어야 함</li>
<li>지역사상 투명성 : 지역DBMS와 물리적 DB 사이의 Mapping 보장. 지역시스템과 무관한 이름 사용 가능</li>
<li>중복 투명성 : DB 객체가 여러 site에 중복되어 있는지 알 필요가 없음</li>
<li>장애 투명성 : DBMS의 장애와 무관하게 Transaction 일관성 유지</li>
<li>병행 투명성 : 다수 Transaction 수행시 일관성 유지, 분산 2단계 Locking을 이용하여 구현</li>
</ul>
<h3>6.2 장단점</h3>
<ul>
<li>장점
<ul>
<li>신뢰성, 가용성</li>
<li>빠른 응답 속도와 통신비용 절감</li>
<li>각 지역 사용자의 요구 수용 증대</li>
<li>지역 자치성, 점증적 시스템 용량 확장</li>
</ul>
</li>
<li>단점
<ul>
<li>소프트웨어 개발 비용</li>
<li>처리 비용</li>
<li>설계, 관리의 복잡성과 비용</li>
<li>불규칙한 응답속도</li>
<li>통제가 어려움</li>
</ul>
</li>
</ul>
<h3>6.3 적용 기법</h3>
<h4>1. 테이블 분산</h4>
<p>테이블을 위치별로 분산 (ex. 자재품목은 본사, 생산제품은 지사)</p>
<h4>2. 테이블 분할(fragmentation) 분산</h4>
<ul>
<li>수평분할 : 지사별로 각각 다른 PK를 가진 레코드들을 저장. 통합처리시 수행속도가 느려짐</li>
<li>수직분할 : 사이트별로 동일한 PK를 가진 레코드를 저장하나 컬럼을 분리해서 저장 (ex. 본사에는 단가를 저장, 각 지사에는 지사별 재고량을 저장)</li>
</ul>
<h4>3. 테이블 복제(replication) 분산</h4>
<p>동일한 테이블을 여러 곳에서 동시에 생성하여 관리</p>
<ul>
<li>부분복제(segment replication) : 통합본은 본사에 있고, 각 지사별로 수평분할 형태. 데이터 입력은 지사에서 하고, 본사에서 지사 데이터를 이용하여 통합</li>
<li>광역복제 (broadcast replication) : 본사의 데이터를 지사에서도 동일하게 가지고 있음. 본사를 통해서 입력을하고, 주기별로 해당 데이터를 지사로 복사</li>
</ul>
<h4>4. 테이블 요약(summarization) 분산</h4>
<ul>
<li>분석요약 (rollup replication) : 지사별로 존재하는 요약정보를 본사에서 통합하여 지사로 전송 (모든 지사가 동일 정보)</li>
<li>통합요약 (consolidation replication) : 지사별로 존재하는 다른 정보를 본사에서 통합하여 관리 (모든 지사가 다른 정보)</li>
</ul>
<h3>6.4 분산 데이터베이스를 통한 성능 향상 사례</h3>
<p>인사팀DB에만 직원 정보가 있는 경우 업무DB에서는 항상 인사팀DB를 JOIN해야함.<br>
직원 정보를 각 업무DB로 복사를 하면 성능이 향상 됨</p>
<ul>
<li>성능이 중요한 사이트에 적용</li>
<li>master 성격의 table을 분산하면 성능이 향상됨</li>
<li>실시간 동기화가 요구되지 않으면 유리. 특정시간에 batch로 동기화</li>
<li>특정 서버에 부하가 집중될떄 분산시킬수 있음</li>
<li>백업사이트를 구성할 때 분산기능을 적용할 수 있음</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://DevStarSJ.github.io/2016/01/20/01.02.modeling_performance/" data-id="cjov1wtlt0000jw7bf63wh9r4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Database/">Database</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQLP/">SQLP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-01.01.modeling" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/20/01.01.modeling/" class="article-date">
  <time datetime="2016-01-19T15:00:00.000Z" itemprop="datePublished">2016-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Database/">Database</a>►<a class="article-category-link" href="/categories/Database/SQLP/">SQLP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/20/01.01.modeling/">SQLP 1-1 데이터 모델링</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2>1과목 데이터 모델링의 이해</h2>
<ul>
<li>10문제</li>
<li>외우기 보다는 반복적으로 읽어서 전반적인 내용을 이해하는 수준에서 마무리 하는것을 목표로 잡아야 겠습니다.</li>
</ul>
<h2>제 1장 데이터 모델링의 이해</h2>
<h3>1절 데이터 모델의 이해</h3>
<h4>모델링의 특징</h4>
<ul>
<li><code>추상화</code> : 일정한 형식에 맞추어 표현</li>
<li><code>단순화</code> : 약속된 규약에 의해 제한</li>
<li><code>명확화</code> : 애매모호함을 제거 정확하게 기술</li>
</ul>
<h4>모델링의 3가지 관점</h4>
<ul>
<li>데이터 관점 (what) : 업무가 어떤 데이터와 관려이 있는지, 데이터간의 관계가 무엇인지</li>
<li>프로세스 관점 (how) : 업무가 실제하고 있는 일이 무엇인지, 무엇을 해야 하는지</li>
<li>데이터와 프로세스의 상관관점 (interaction) : 업무가 처리됨에 따라 데이터는 어떻게 영향을 받고 있는지</li>
</ul>
<h4>데이터 모델링이란...</h4>
<ul>
<li>정보시스템을 구축하기 위한 데이터관점의 업무 분석 기법</li>
<li>현실세계의 데이터(what)에 대해 약속된 표기법에 의해 표현하는 과정</li>
<li>데이터베이스를 구축하기 위한 분석/설계의 과정</li>
</ul>
<h4>데이터 모델의 중요성</h4>
<ul>
<li>파급효과(leverage) : 데이터 모델이 잘못되어서 나중에 변경될때에는 전체 시스템에 큰 변경 사항이 발생함</li>
<li>복잡한 정보 요구사항의 간결한 표현(conciseness) : 요구사항을 정확하고 간결하게 표현. 요구사항 파악시 데이터 모델을 리뷰하는 것이 더 빠름.</li>
<li>데이터 품질(data quality) : 기간이 오래되고 쌓인 데이터를 활용하려면 품질이 중요. (정확성, 중복데이터 등...). 품질이 안좋으면 활용하지 못한 쓰레기가 될수 있음</li>
</ul>
<h4>데이터 모델링의 유의점</h4>
<ul>
<li><code>중복(duplication)</code> : 여러 곳에 같은 정보 저장하지 않도록</li>
<li><code>비유연성(inflexibility)</code> : 데이터 정의와 사용 프로세스를 분리. 각각의 작은 변화가 서로에게 영향을 미치지 않도록</li>
<li><code>비일관성(inconsistency)</code> : 서로 영향을 미치는 데이터간 상호 연관 관계에 대한 명확한 정의가 필요 (ex. 납부이력과 신용상태)</li>
</ul>
<h4>데이터 모델링의 3단계 진행 (추상화 수준에 따라)</h4>
<ul>
<li><code>개념적 데이터 모델(conceptual)</code>
<ul>
<li>추상화 수준이 높고 업무중신적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링, EA수립시 많이 이용</li>
<li>엔티티 - 관계 다이어그램 생성</li>
<li>전사적 데이터 모델링 (enterprise)</li>
<li>중요한 2가지 기능
<ol>
<li>사용자와 시스템 개발자가 데이터 요구 사항을 발견하는 것을 지원</li>
<li>현 시스템이 어떻게 변형되어야 하는지를 이해하는데 유용</li>
</ol>
</li>
</ul>
</li>
<li><code>논리적 데이터 모델 (logical)</code>
<ul>
<li>시스템으로 구축하고자 하는 업무에 대한 Key, 속성, 관계 등을 정확하게 표현, 재사용성이 높음</li>
<li>식별자 확정, 정규화, M:M 관계 해소, 참조 무결성 규칙 정의 등</li>
<li>데이터베이스 설계 프로세스의 input으로 비즈니스 정보의 논리적인 구조와 규칙을 명확하게 표현하는 기법 또는 과정</li>
</ul>
</li>
<li><code>물리적 데이터 모델 (physical)</code>
<ul>
<li>실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등 무리적인 성격을 고려하여 설계</li>
<li>물리적 스키마 : 데이터가 물리적으로 컴퓨터에 어떻게 저장될 것인가에 대한 정의</li>
<li>테이블, 칼럼 등의 저장구조와 저장 장치, 접근 방법 등</li>
</ul>
</li>
</ul>
<h4>데이터 독립성의 필요성 &lt;-&gt; 데이터 종속성</h4>
<ul>
<li>유지보수 비용증가</li>
<li>데이터 중복성 증가</li>
<li>데이터복잡도 증가</li>
<li>요구사항 대응 저하</li>
</ul>
<h4>데이터 독립성 확보시 효과</h4>
<ul>
<li>각 View의 독립성을 유지하고 계층별 View에 영향을 주지 않고 변경 가능</li>
<li>단계별 Schema에 따라 DDL과 DML가 다름을 제공</li>
</ul>
<h4>데이터베이스 3단계 구조</h4>
<ol>
<li>외부단계 (External Schema) : 사용자 관점</li>
</ol>
<pre><code>- DB의 개개 user나 application이 접근하는 DB 정의
</code></pre>
<ol start="2">
<li>개념적단계 (Conceptual Schema) : 통합 관점</li>
</ol>
<pre><code>- 사용자가 처리하는 데이터 유형의 공통적인 사항을 처리하는 통합된 뷰를 스키마 구조로 디자인한 형태
- 모든 사용자 관점을 통합한 조직 전체의 DB
- 모든 user와 application이 필요로하는 데이터를 통합한 조직 전체의 DB를 기술
- DB에 저장되는 데이터와 그들간의 관계를 표현하는 스키마
</code></pre>
<ol start="3">
<li>내부적단계 (Internal Schema) : 물리적 저장구조</li>
</ol>
<h4>논리적, 물리직 독립성</h4>
<table>
<thead>
<tr>
<th>독립성</th>
<th>내용</th>
<th>특징</th>
</tr>
</thead>
<tbody>
<tr>
<td>논리적 독립성</td>
<td>- 개념 스키마가 변경되어도 외부 스키마에는 영향 없음  - 논리적 구조가 변경되어도 Application에는 영향 없음</td>
<td>- 사용자 특성에 맞는 변경가능  - 통합 구조 변경가능</td>
</tr>
<tr>
<td>물리적 독립성</td>
<td>- 내부스키마가 변경되어도 외부/개념 스키마에 영향 없음  - 저장장치의 구조변경은 Application과 개념스키마에 영향 없음</td>
<td>- 물리구조, 개념구조를 서로 영향없이 변경가능</td>
</tr>
</tbody>
</table>
<h4>사상 (Mapping)</h4>
<ul>
<li>논리적 mapping (외부적 &lt;-&gt; 개념적) : 외부적 뷰와 개념적 뷰의 상호 관련성 정의
<ul>
<li>사용자가 접근하는 뷰의 필드는 다른 타입을 가질 수 있으나, 개념적 뷰의 필드 타입은 변화가 없음</li>
</ul>
</li>
<li>물리적 mapping (개념적 &lt;-&gt; 내부적) : 개념적 뷰와 데이터베이스의 상호 관련성 정의
<ul>
<li>데이터베이스 구조가 바뀔 경우 물리적 mapping이 바뀌어야 함. 개념적 스키마는 안바뀌도록 해야 함</li>
</ul>
</li>
</ul>
<h4>데이터 모델링의 3가지 개념</h4>
<ul>
<li>업무가 관여하는 어떤 것 : things (table)</li>
<li>어떤 것이 가지는 성격 : attributes (column)</li>
<li>업무가 관여하는 어떤 것 간의 관계 : relationships</li>
</ul>
<h4>좋은 데이터 모델의 요소</h4>
<ul>
<li>완전성 (completeness) : 업무에 필요한 모든 데이터가 데이터 모델에 정의되어 있어야 함</li>
<li>중복배제 (non-redundancy) : 동일한 사실은 반드시 한 번만 기록 (ex. 나이, 생년월일 은 중복)</li>
<li>업무규칙 (business rules) : 수많은 업무규칙을 데이터 모델에 표현</li>
<li>데이터 재사용 (data reusability) : 데이터 통합성, 독립성을 충분히 고려</li>
<li>의사소통 (communication) :  데이터 모델은 업무를 데이터 관점에서 분석하고 설계하여 나오는 최종 산출물. 모든 업무 규칙을 엔티티, 서브타입, 속성, 관계 등의 형태로 최대한 자세하게 표현. 업무관련자들은 이를 업무 규칙과 동일하게 받아들이고 정보시스템 활용</li>
<li>통합성 (integration) : 각 부서별 따로 존재했던 데이터 중 중복적인 성격들(마스터 테이블)을 통합 관리</li>
</ul>
<h3>2절 엔터티 (entity)</h3>
<h4>2.1 엔터티의 특성</h4>
<ul>
<li>업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것(thing)</li>
<li>반드시 필요한 정보</li>
<li>unique하게 식별이 가능</li>
<li>반드시 속성(attribute)를 가져야 함</li>
<li>업무 프로세스에서 사용되어야 함</li>
<li>최소 한 개 이상의 다른 엔터티와의 관계 필수</li>
<li>영속적으로 존재하는 인스턴스(instance)의 집합</li>
</ul>
<h4>2.2 엔터티의 분류</h4>
<ul>
<li>유무형에 따른 분류
<ul>
<li>유형엔터티 : 사원, 물품</li>
<li>개념엔터티 : 부서, 보험상품</li>
<li>사건엔터티 : 주문, 청구</li>
</ul>
</li>
<li>발생시점에 따른 분류
<ul>
<li>기본 엔터티 (fundamental entity, key entity) : 독립적 생성 가능, 다른 엔터티의 주어 역할 (ex. 사원 부서, 고객, 상품)</li>
<li>중심 엔터티 (main entity) : 기본 엔터티로 부터 발생하고, 업무의 중심 역할 (ex. 계약, 주문, 매출)</li>
<li>행위 엔터티 (active entity) :  2개 이상의 부모로 부터 발생하고 자주 바뀌거나 데이터량이 증가되는 성격을 가짐 (ex. 주문목록, 사원변경이력)</li>
</ul>
</li>
</ul>
<h4>2.3 인스턴스 (instance)</h4>
<ul>
<li>엔터티로부터 생성된 하나의 개체</li>
<li>entity가 class하면 instance 는 object</li>
</ul>
<h3>3절 속성 (attribute)</h3>
<h4>3.1 속성의 특징</h4>
<ul>
<li>의미상 더 이상 분리되지 않음 : 2개 이상의 값을 가질 경우 분리해야 함</li>
<li>엔터티를 설명하고 인스턴스의 구성요소</li>
<li>정규화 규칙에 의거해 주식별자에 함수적 종속성을 가져야 함</li>
<li>업무상 필요로 해야한다.</li>
</ul>
<h4>3.2 속성의 분류</h4>
<ul>
<li>특성에 의한 분류
<ul>
<li>기본속성 (basic attribute) : 업무로부터 추출한 모든 속성</li>
<li>설계속성 (designed attribute) : 업무를 규칙화하기 위해 새로 만들거나 변형한 속성 (ex. 일련번호)</li>
<li>파생속성 (derived attribute) : 다른 속성에 영향을 받는 속성. 주로 계산 값들. 되도록이면 적게 정의하는게 좋음</li>
</ul>
</li>
<li>구성방식에 따른 분류
<ul>
<li>PK (primary key), FK (foreign key), 일반속성 등...</li>
</ul>
</li>
</ul>
<h4>3.3 도메인 (domain)</h4>
<ul>
<li>속성이 가질 수 있는 값의 범위</li>
</ul>
<h3>4절 관계 (relationship)</h3>
<ul>
<li>인스턴스 사이의 연관성</li>
</ul>
<h4>4.1 관계의 분류</h4>
<ul>
<li>존재에 의한 관계 : 부서 (1) : 사원 (M)</li>
<li>행위에 의한 관계 : 고객 (1) : 주문 (M)</li>
</ul>
<h4>4.2 관계 차수(degree, cardinality)</h4>
<ul>
<li>1 : 1 관계 : 사원 - 병역사항</li>
<li>1 : M 관계 : 부서 (1) : 사원 (M)</li>
<li>M : M 관계 : 주문 (M) : 제품 (M)</li>
</ul>
<h3>5절 식별자 (identifiers)</h3>
<ul>
<li>entity 내에서 instance의 구분자</li>
</ul>
<h4>5.1 식별자의 특징</h4>
<ul>
<li>유일성 : 주식별자에 의해 엔터티 내의 모든 인스턴스가 유일하게 부분</li>
<li>최소성 : 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수</li>
<li>불변성 : 자주 변하지 않는 값이어야 함</li>
<li>존재성 : 반드시 값이 있어야함 (NOT NULL)</li>
</ul>
<h4>5.2 주식별자 도출기준</h4>
<ul>
<li>업무에서 자주 이용되는 속성 : PK로 등록 = index 생성</li>
<li>명칭, 내역등과 같은 이름은 피해야 함 : 다른 적당한 구분자가 존재하지 않으면 일변번호 같은 것을 새로 생성</li>
<li>속성수가 많아지지 않도록 함 : WHERE 조건이 복잡해짐. 새로운 인조식별자를 생성하는게 편함</li>
</ul>
<h4>5.3 외부식별자 (foreign identifier)와의 관계</h4>
<h5>5.3.1 식별관계, 비식별관계</h5>
<ul>
<li>식별자관계 : 부모의 식별자를 자식의 식별자로 사용
<ul>
<li>FK가 NOT NULL이어야 함</li>
<li>종속관계 : <code>1 : 1</code> 또는 <code>1 : M</code></li>
<li>상속받은 주식별자속성을 타 엔터티에 이전 필요</li>
</ul>
</li>
<li>비식별관계 : 부모없는 자식이 생성될 수 있음
<ul>
<li>자식의 일반 속성에 생성 됨 : NULL 일 수 있음</li>
<li>부모와 자식의 생명주기(life cycle)을 달리할 경우 유용함</li>
<li>자식 엔터티의 주 식별자로 사용되어도 되지만, 따로 생성하는게 더 유리하다고 판단 될 경우</li>
</ul>
</li>
</ul>
<h5>5.4.2 관계에 대한 주의사항</h5>
<ul>
<li>식별관계 / 비식별관계 결정
<ul>
<li>어떻게 관계를 짓는냐에 따라 속성의 정의 및 SQL 작성시에 달라지므로 SQL 전략에 맞게 결정해야 한다.</li>
</ul>
</li>
<li>식별관계로만 설정할 경우 문제점
<ul>
<li>PK 속성의 수가 데이터 모델 흐름에 따라 계속 증가하게 된다. : 자식의 PK 속성수는 부모의 PK 속성수 + n</li>
<li>JOIN 할때 적어줘야 할 WHERE절의 조건 수가 늘어난다.</li>
</ul>
</li>
<li>비식별관계로만 설정할 경우 문제점
<ul>
<li>자식 엔터티의 데이터를 조회할때 부모 엔터티에 WHERE 조건을 추가해 주어야 할 경우가 발생한다.</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://DevStarSJ.github.io/2016/01/20/01.01.modeling/" data-id="cjov1wtma0005jw7bmjf3mcu6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Database/">Database</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQLP/">SQLP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-BigPicture" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/27/BigPicture/" class="article-date">
  <time datetime="2015-12-26T15:00:00.000Z" itemprop="datePublished">2015-12-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Book/">Book</a>►<a class="article-category-link" href="/categories/Book/Review/">Review</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/27/BigPicture/">선대인의 빅픽처 저성장 시대의 생존 경제학</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3>선대인의 빅픽처 저성장 시대의 생존 경제학</h3>
<ul>
<li>웅진지식하우스</li>
<li>선대인</li>
<li>책소개 Link : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=9770144" target="_blank" rel="external">http://book.naver.com/bookdb/book_detail.nhn?bid=9770144</a></li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/BigPicture.jpg?raw=true" alt=""></p>
<p>안녕하세요.<br>
이번에 소개 드릴 책은 <code>선대인의 빅픽처 저성장 시대의 생존 경제학</code>입니다.<br>
제목 그대로 요즘같은 저성장 시대에서 개인이 어떤 관점을 가지고 경제를 바라 보아야 할 것인가에 대한 소개와<br>
어떻게 투자를 해야 할 것인지에 대한 거시적인 안목을 가지는 방법 및 투자 방법을 한가지 소개해 주고 있습니다.</p>
<h4>BIG PICTURE</h4>
<p>세계 시장에 대해서 큰 시각으로 바로 보라는 의미와 주목해야 할 10가지 키워드의 머릿글자라는 2가지 의미로 저자는 소개하였습니다.</p>
<ul>
<li>B : Bio-health Care</li>
<li>I : Interest Rate (금리)</li>
<li>G : Green (녹색산업)</li>
<li>P : Petroleum (석유)</li>
<li>I : India (인도)</li>
<li>C : China (중국)</li>
<li>T : Tech Companies (기술기업)</li>
<li>U : USA (미국)</li>
<li>R : Risk (리스크)</li>
<li>E : Exchange Rate (환율)</li>
</ul>
<p>책 내용이 크게 어렵다던지, 무조건 이렇게 해라는 식은 아니어서 별 다른 거부감 없이 잘 읽혔습니다.<br>
저금리 시대에 은행에 돈을 넣어두자니 아깝고,  너도 나도 부동산 하고 있으니 부동산에 투자하자니 불안하고...<br>
등 고민이 많으신 분들은 꼭 읽어보시길 추천 합니다.</p>
<p>예전같이 금리가 15%씩 하는 이런 시절로 다시 돌아가기는 힘들기 때문에 그 시절의 경제적 논리로 투자를 하면 안된다는 것을 설명해 주고 있습니다. 현 시대의 투자법에 대해서 잘 정리가 되어 있냐 ? 그렇지도 않습니다. 왜냐하면 인류가 아직 이런 저 금리시대에 살아본 적이 없기 때문입니다. 지금의 경제 상황은 인류가 한번도 경험해보지 못한 상황이니 만큼 어느 누구하나 이게 정답이다 라고 할 수도 없는 상황입니다.</p>
<p>1장에서는 국내 증권사는 철저하게 개인의 이익에는 관심이 전혀 없다는 내용과, 달러 - 유가 - 금값 의 상관관계, 세계 4대 경제권과 우리나라 경제의 관계에 대해서 거시적인 관점에서 소개를 해주고 있습니다.</p>
<p>P.35에 아래와 같은 내용이 나오는데 참 공감이 갑니다.</p>
<blockquote>
<p>가이드가 정박 중인 멋진 보트들을 가리키며 말했다.<br>
&quot;보세요 저 배들이 바로 은행가와 주식중개인들의 요트랍니다.&quot;<br>
그러자 순진한 방문객이 물었다.<br>
&quot;그러면 고객들의 요트는 어디에 있나요?&quot;</p>
</blockquote>
<p>1장에서는 세계 경제에 대한 이야기 였다면, 2장에서는 한국 경제에 대해서 지금 현재 상황과 앞으로 어떻게 될 것이라는 작가의 의견이 서술되어 있습니다.</p>
<p>3장에서는 앞서 얘기한 10가지 키워드에 대해서 설명을 해주고 있습니다.<br>
역시 중국 경제에 대해서 주목을 해야 한다는 것에 대해서 강조를 하고 있습니다.<br>
중국이 현재 경제 불황이라고는 하지만, 그래도 다른 나라보다는 훨씬 높은 7% 대의 성장률을 보이고 있으며,<br>
계속해서 투자가 일어나며 임금은 올라가고 일자리도 늘어나고 있다는 것에 대해서 주목을 해야 한다는 군요.<br>
나머지 키워드에 대해서도 설명을 해주고 있는데, 서평에서는 생략하도록 하겠습니다.</p>
<p>다음에는 경제 흐름을 읽는 방법들에 대한 소개하고 있습니다.
비교적 위험 부담이 적고 회사일을 하면서도 크게 신경을 쓰지 않을 수 있는 투자 방법중 하나인 <code>성장형 우량주 투자</code>방법에 대해서 소개를 해주었습니다.<br>
그리고 지난 4년간 그 방법으로 투자를 하여 수익을 냈다는 소개도 같이 해주고 있습니다.</p>
<p>뒷 부분에는 참조할 만한 사이트 4곳의 소개와 같이 읽으면 좋은 경제학 관련 책들에 대한 소개가 있었습니다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://DevStarSJ.github.io/2015/12/27/BigPicture/" data-id="cjov1wtnm002ajw7bwercd6eq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Book/">Book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Review/">Review</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hanbit.BBP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/24/hanbit.BBP/" class="article-date">
  <time datetime="2015-12-23T15:00:00.000Z" itemprop="datePublished">2015-12-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Book/">Book</a>►<a class="article-category-link" href="/categories/Book/Review/">Review</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/24/hanbit.BBP/">훌륭한 프로그래머가 되는 법</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3>훌륭한 프로그래머가 되는 법 : 프로젝트와 팀을 성공으로 이끄는 선배 개발자의 노하우</h3>
<ul>
<li>한빛미디어</li>
<li>옮긴이 : 최원재, 강전희, 안재덕, 남윤화</li>
<li>책소개 Link : <a href="http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-230-4" target="_blank" rel="external">http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-230-4</a></li>
<li>원서 : Becoming a Better Programmer - Pete Goodliffe - O'Reilly Media, Inc. : <a href="http://shop.oreilly.com/product/0636920033929.do" target="_blank" rel="external">http://shop.oreilly.com/product/0636920033929.do</a></li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.BBP.01.jpg?raw=true" alt=""></p>
<p>안녕하세요. 이번에 소개해 드릴 책은 최근에 나온 화제의 도서 <code>훌륭한 프로그래머가 되는 법 : 프로젝트와 팀을 성공으로 이끄는 선배 개발자의 노하우</code> 입니다.<br>
<code>프로그래머로 사는 법</code> 처럼 부담없이 읽을 수 있는 에세이라고 생각을 했는데, 엄청난 착각이었습니다.<br>
<code>팟캐스트 나는 프로그래머다: 뉴욕, 서울, 도쿄 개발자의 촌철살인 IT 이야기</code> 처럼 재미있는 책도 아니었구요.</p>
<p>한마디로 표현하자면 <code>율법서</code> 같다고나 할까요 ?<br>
생각보다 많이 무거운 내용이었습니다. 읽는 내내 엄청 아픕니다. 가슴을 엄청 찔러대더군요.<br>
가끔씩 나름 개그라고 쓴 내용도 있고, 그림도 있긴 했습니다만...</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.BBP.02.jpg?raw=true" alt=""></p>
<p>전체적인 분위기가 너무 무겁다 보니 그것 또한 웃음으로 다가오기 보다는 좀 심각한 표정으로 보게되더군요.</p>
<p>이 책의 내용을 짧게 요약하자면... 요약이 안됩니다.<br>
그럼 책 내용중 중요한 부분만 정리하자면... 정리가 안됩니다.<br>
어디하나 버릴 내용이 없습니다. 433페이지까지 모든 페이지가 다 중요합니다.<br>
그 중 특히 이 부분이 더 중요하다 싶은데를 꼽을 수도 없습니다. 다~ 중요한 내용입니다.<br>
말그대로 <code>율법서</code> 입니다.</p>
<ol>
<li>you.write(code);</li>
<li>연습을 통해 완벽해진다.</li>
<li>개인적인 일로 받아들이기</li>
<li>일 끝내기</li>
<li>사람의 일<br>
부록. 국내 개발자 이야기</li>
</ol>
<p>이렇게 5개의 부분을 39개의 챕터로 나눠놨습니다.</p>
<h4>Part 1 you.write(code);</h4>
<p>13개의 챕터로 구성되어 있으며, 주로 코드 작성시 주의해야 할 사항에 대해서 설명되어 있습니다.<br>
각각의 테스트 단계에 대한 설명 및 오브젝트간의 복잡도(complexity)에 관한 설명도 같이 있습니다.<br>
일반적인 프로젝트의 형태와 처음부터 디자인을 잘잡고 시작한 프로젝트에 대한 비교를 이야기 형식으로 서술한 부분의 이야기가 참 재밌으면서도, 안타까우면서도, 부러우면서도, 그랬습니다. ;;</p>
<h4>Part 2 연습을 통해 완벽해진다.</h4>
<p>코딩시의 규칙들, 코드 재사용에 대한 이야기, 버전 관리 및 배포(release)에 관한 이야기들이 있습니다.<br>
개인의 개발규칙보다는 회사에서 팀으로 작업할때 필요한 이야기들입니다.</p>
<h4>Part 3 개인적인 일로 받아들이기</h4>
<p>이 파트에서는 개발자로서의 삶, 자세에 대한 이야기가 주를 이룹니다.<br>
개발자로서 배움을 지속해야 한다는 이야기 및 개발자의 윤리, 언어 및 자세에 대한 이야기를 하고 있습니다.</p>
<h4>Part 4 일 끝내기</h4>
<p>이 파트도 개인적인 이야기 보다는 회사내에서 팀으로서의 작업에 대한 이야기 입니다. (파트 2의 후속 파타라는 느낌이 강합니다.)<br>
개발이라는 과정이 끝이 명확한 작업이 아닌 만큼, 어떻게 끝을 규정할 것인가 ? 누군가가 일의 진행 사항을 물었을때 어떻게 대답해야 하는가 등에 대한 이야기가 있습니다.</p>
<h4>Part 5 사람의 일</h4>
<p>프로그래머로서 개발에 대한 이야기 뿐 아니라 삶의 대한 이야기도 같이 있습니다. (파트 3의 후속이랄까요 ?)<br>
생각, 말하기, 태도 등에 대한 이야기를 포함해서 전반적인 삶, 생활에 대한 이야기가 있습니다.</p>
<h4>부록 국내 개발자 이야기</h4>
<p>국내 개발자 4분께서 여러 가지 조언을 많이 해 주십니다.<br>
굉장히 현실적인 조언이 많이 있어서 큰 도움이 되었습니다.<br>
특히 프로그래머의 미래가 어둡다고 넋두리하는 것에 귀담아 듣지 말라고 하는 <code>염재현</code>님의 조언에 크게 공감이 되었습니다.</p>
<p>####총평</p>
<p>진짜 어느하나 버릴 주제가 없는 꼭 필요한 책입니다.<br>
가볍게 읽을 수 있는 책은 아니었습니다.<br>
이 책을 읽으면서 내가 많이 부족하구나, 내가 많이 건방졌구나 란 질책도 많이 느껴졌으며,<br>
반면 그래도 내가 완전 잘못된 방향으로 걸어온 것은 아니구나 라는 위안도 같이 받았습니다.<br>
앞으로도 지금처럼 노력하면서, 책을 보고 느꼈던 나의 부족한 점을 하나하나 고쳐가야 겠습니다.<br>
매일 기도하는 마음으로 책의 한 챕터씩 아니면 한 페이지씩이라도 읽으면서 이 책의 내용에 대해서 계속해서 되씹으면서 늘 옆에 두어야 할 책이라 여겨집니다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://DevStarSJ.github.io/2015/12/24/hanbit.BBP/" data-id="cjov1wtqz008cjw7br45wymep" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Book/">Book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Review/">Review</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hanbit.naProDa" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/22/hanbit.naProDa/" class="article-date">
  <time datetime="2015-11-21T15:00:00.000Z" itemprop="datePublished">2015-11-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Book/">Book</a>►<a class="article-category-link" href="/categories/Book/Review/">Review</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/22/hanbit.naProDa/">팟캐스트 나는 프로그래머다</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3>팟캐스트 나는 프로그래머다: 뉴욕, 서울, 도쿄 개발자의 촌철살인 IT 이야기</h3>
<ul>
<li>한빛미디어</li>
<li>임백준, 정도현, 김호광 지음</li>
<li>책소개 Link : <a href="http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-228-1" target="_blank" rel="external">http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-228-1</a></li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.naProDa.01.jpg?raw=true" alt=""></p>
<p>안녕하세요. 오늘 정말 재미있고 유익한 책 한권을 소개할께요.
최근 본 개발자 관련 서적중에 가장 재미있는 책입니다.
위에 제목에 나와 있듯 <code>팟캐스트 나는 프로그래머다: 뉴욕, 서울, 도쿄 개발자의 촌철살인 IT 이야기</code> 입니다.
팟캐스트 방송으로 이미 너무나도 유명한 책이죠.</p>
<h4>팟캐스트 소개</h4>
<p>저도 아직 제대로 들어보진 않았습니다.
이런 방송이 있다고는 알고 있었지만요.
그러다가 10월 말에 열린 <code>나는 프로그래머다 컨퍼런스</code> 관련 동영상들이 소개된 것을 통해서 들었는데 너무 재미있고, 개발자들의 입장에서 공감되는 이야기를 적나라게 해주는 것이 너무나도 시원시원 하였습니다.</p>
<ul>
<li>나는 프로그래머다 Youtube 페이지 : <a href="https://www.youtube.com/channel/UCTaAL7nKLOEnRsTW9uujxSQ" target="_blank" rel="external">https://www.youtube.com/channel/UCTaAL7nKLOEnRsTW9uujxSQ</a></li>
</ul>
<p>위 Link에서 컨퍼런스 영상 및 팟캐스트 영상 모두 확인이 가능 합니다.</p>
<h4>첫 인상</h4>
<p>겉표지가 귀여우면서도 세련되었습니다.
캐릭터도 너무 귀엽구요. 개인적으로 데니스님 케릭이 가장 귀여워요. ㅎ
저번에 질문에 몇 번 답해주었다고 <code>스타벅스 쿠폰을 2개나 보내주셨는데, 잘 마셨다고 인사도 못드렸네용.</code>.
<code>개발자의 가려운 곳을 긁어주마!</code> 라는 말이 너무나도 인상적이었구요.
저런 말이야 누구나 다 할 수 있지.
정말 그렇게 다 긁어줄까 ? 라고 의문을 느낄 수 있겠지만, 이미 나프다 컨퍼런스 영상을 본 후라서 정말 그럴꺼라는 확신이 들었습니다.</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.naProDa.02.jpg?raw=true" alt=""></p>
<h4>책 구성</h4>
<p>실제 팟캐스트 방송에서 얘기한 것을 책으로 옮겨둔 것입니다.
물론 그 내용이 그대로 대본같이 들어있는 것은 아니겠죠.
그리고 거기다가 방송에서는 미처 얘기하지 못한 작가님들의 설명글도 중간중간에 포함되어 있습니다.
총 11개의 이야기로 구성되어 있구요.
각각의 이야기마다 주제가 있습니다.</p>
<ul>
<li>언어 : Java, Go, Scala</li>
<li>기술 : MS, MS Build, AWS, FinTech</li>
<li>삶 : MS MVP, 여자 개발자, 개발자영어, SI</li>
</ul>
<p>이렇듯 모든 개발자라면 모두 관심있어할 만한 주제부터 해서 힘들어하시는 소외받으신 분들 이야기까지 개발자 분야의 꼭대기에서 바닥까지 모든 것을 다 다룬다고 해야 하나요 ?</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.naProDa.03.jpg?raw=true" alt=""></p>
<h4>1부 언어</h4>
<p>Java, Go, Scala 3가지 언어에 대한 내용으로 각각 방송을 진행한 이야기를 소개해 줍니다.
모든 방송마다 관련 guest를 초대해서 같이 이야기를 나누는 형식으로 진행됩니다.</p>
<p>Java 에서는 주로 자바의 미래가 어두운 점과 아쉬운 점에 대한 이야기가 주가 되구요.
한국의 전자정부 프레임워크가 만들어지게 된 배경부터 한국에서의 Java 개발자들의 안타까운 현실에 대해서 물론 직접 격으신 분들도 많으시겠지만, 직접 겪어보지 않으신 분들도 어느 정도 공감할 수 있도록 적나라하게 이야기를 해줍니다.</p>
<p>Go 언어에 대한 이야기에서는 현재 Google에서 활동하고 계시는 개발자분을 초대해서 이야기가 진행됩니다.
Go 언어의 탄생 배경을 시작으로, ActiveX 이야기, Ruby에 대한 이야기등 개발자들이 관심 가질만한 주제에 대해서 이야기를 해줍니다.</p>
<p>Scala에 대해서 안 들어보신 분들은 없겠지만, 어떤 언어인지 제대로 아시는 분들은 아마 많지 않을 듯 한데요.
저도 그런 부류 중 하나이구요.
함수형 언어 ? 이게 뭐지 ? 란 생각은 들어도 그게 뭔지에 대해서 제대로 찾아 보신분들도 많지 않으리라 봅니다.
그나마 함수형 언어가 무엇인지에 대해서 감을 잡을 수 있도록 이야기를 해줍니다.
Scala 언어의 탄생 배경부터해서 현재 스터디 활동 중이신 분들을 guest로 모셔서 이야기를 하고 있구요.
스터디를 함께 하고싶으신 분들을 위한 안내까지 해줍니다.
정말 앞으로는 함수형 언어가 대세가 될까요 ? 이 책에 따르면 그럴 수도 있겠단 생각이 드네요.
제가 이 책을 읽고 간단히 이해한 함수형 언어라는 것은</p>
<ul>
<li>모든 함수는 <code>return</code>값이 있어야 하며 <code>call by reference</code>로 인자를 전달하면 안됩니다.</li>
<li>함수 안에서 인자로 전달받은 값이 아닌 다른 자원에 대해서 수정을 하면 안됩니다.</li>
<li>즉 모든 제어를 함수의 입/출력을 통해서 해야합니다.</li>
<li>그러므로, Unit Test 작성이 용의하며, bug 발생 가능성도 줄어들며, bug가 발생하더라도 예측하기 쉽습니다.</li>
</ul>
<h4>2부 기술</h4>
<p>2부에서는 최신 기술들의 흐름에 대해서 알아 볼 수 있었습니다.
MS의 신기술들, MS Azure, Amazon AWS 등 Cloud 활용시의 장단점을 비롯하여 FinTech의 범위와 국내 해외의 FinTech 현재 상황까지...
기술적인 부분부터 해서 서비스단의 이야기까지 많은 부분에 대해서 간접적으로 나마 이해하는데 많은 도움이 되었습니다.
그 동안 여러가지 컨퍼런스에서 직접 봐왔던 분들이 guest로 오셔서 이야기를 진행해주셨는데, 그 분들이 정말 대단한 분들이란 것을 느끼게 되었습니다.</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.naProDa.04.jpg?raw=true" alt=""></p>
<h4>3부 삶</h4>
<p>이 부분에서 정말 느낀게 많았습니다.
MS MVP, 여자 개발자, 개발자 영어, SI 까지 여자 개발자 빼고 나머지 3가지 부분은 제가 관심을 가지고 있다던지, 아니면 직접 겪은 부분이라서 더 관심이 많이 가는 부분이었습니다.
지금도 온라인으로 영어강좌를 신청해서 듣고 있는데, 영어 학습과 개발자의 삶에 대해서 직접 임작가님의 재밌는 실수담 부터 해서 영어에 대한 두려움을 없에주는 용기도 주었습니다.
알게 모르게 일어나고 있는 여자 개발자에 대해서 한국 업체들에서 벌어지는 차별들에 대한 소개와, SI업체의 힘든 현실에 대한 부분도 알지 못했던 현실들이었구요.</p>
<h4>총평</h4>
<p>이야기 하나하나에서 다루는 주제가 개발자들이 관심을 가질 수 있는 주제에 대해서 미리 겪어본 선배님들의 이야기를 들음으로써 나중에 그 분야에 대해서 학습을 할때 시행착오를 덜 겪을 수 있도록 큰 도움을 주는 책으로도 괜찮으리라 봅니다.
물론 그냥 재미로 보기에도 좋은 책입니다. 너무너무 재미있구요.
이 책을 보니깐 시간내서 팟캐스트도 한번 쭉~ 보고 싶다는 생각이 듭니다.
책에는 11개의 이야기를 다루었지만, 팟캐스트는 쭉 진행중에 있죠.
반드시 2권이 출간되었으면 좋겠습니다.
이번 책은 한빛미디어에서 제공해주어서 좋은 기회에 좋은 책을 읽을 수 있었던것 같구요.
2권이 출간되면 반드시 사서 보겠습니다. ㅎ
좋은 책을 제공해주신 한빛미디어에 다시 한번 감사드립니다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://DevStarSJ.github.io/2015/11/22/hanbit.naProDa/" data-id="cjov1wtrh009jjw7babntkeet" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Book/">Book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Review/">Review</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Devops.Jenkins" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/10/Devops.Jenkins/" class="article-date">
  <time datetime="2015-11-09T15:00:00.000Z" itemprop="datePublished">2015-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DevOps/">DevOps</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/10/Devops.Jenkins/">Install Jenkins</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>Install Jenkins</h1>
<h3>1. Jenkins 란 ?</h3>
<p>Jenkins Server는 Open Source CI (Continuous Integration) 을 자동화해주는 Tool입니다. 대부분 다음과 같은 방식으로 Jenkins를 이용합니다.</p>
<ol>
<li>Repository (SVN, Git)에서 source code를 가져옵니다.</li>
<li>정해진 절차에 따라 build 및 unit test, integration test를 수행합니다. 수행 결과 이상이 있을 때 e-mail을 통해서 reporting해주는 역할까지 수행해 줍니다.</li>
<li>정상적으로 build 되었으며, 모든 test 결과에 이상이 없는 경우 배포 파일(setup, update)을 생성합니다.</li>
</ol>
<p>Jenkins 자체는 사용자가 입력한 command line 명령어들을 특정 조건에 맞게 또는 특정 시간이나 일정한 간격으로 수행해주는 역할을 해줍니다.
build 및 test, deploy하는 역할 자체는 command line에서 수행가능한 형태로 사용자가 직접 입력해 놓으면 그 명령어를 수행해주는 역할을 할 뿐이지, Jenkins 자체에 build tool이 있다던지 그러진 않습니다.</p>
<h3>2. 이번 Posting에서 다룰 내용</h3>
<ol>
<li>Jenkins download 및 설치 (Windows 기준)</li>
<li>MSBuild plugin 설치</li>
<li>Jenkins item 설정</li>
<li>SVN Repository에서 source code 내려받기</li>
<li>VisualStudio Solution (.sln)을 command line에서 실행시키기 (MSBuild 이용)</li>
<li>Jenkins item에서 build 후 다른 item 실행</li>
</ol>
<h3>3. Jenkins download 및 설치</h3>
<ul>
<li>Link : <a href="http://jenkins-ci.org" target="_blank" rel="external">http://jenkins-ci.org</a></li>
</ul>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/blob/master/Blog/CI/image/jenkins.01.png?raw=true&quot;&gt;</p>
<p>위 Link에서 우측에 있는 <code>Windows</code>를 눌러서 다운로드 받으면 됩니다.
zip 파일이 다운로드 받아지는데 압축을 풀어서 셋업을 실행하면 설치가 끝납니다.
바로 Jenkins 창이 실행됩니다. 기본적으로는 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> 로 접속이 가능합니다. (다른 PC에서 접속시에는 PC ip나 hostname 에 8080 포트로 접속을 하면 됩니다.)</p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/blob/master/Blog/CI/image/jenkins.02.png?raw=true&quot;&gt;</p>
<p>###3. MSBuild plugin 설치</p>
<p>Visual Studio에서 작업한 solution 파일 (.sln)을 command line에서 build 하기 위해서는 MSBuild.exe를 실행해서 build 해야 합니다. MSBuild.exe는 Visual Studio 설치시 같이 설치가 됩니다.
Jenkins에서 MSBuild를 사용하기 위해서는 별도의 plugin이 필요합니다.</p>
<p>먼저 Jenkins 화면에서 <code>Jenkins 관리</code>-&gt; <code>플러그인 관리</code> 로 들어갑니다.</p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/blob/master/Blog/CI/image/jenkins.03.png?raw=true&quot;&gt;</p>
<p>internet에 연결된 환경이라면 <code>설치가능</code> 탭에서 바로 MSBuild를 선택해주시면 됩니다.</p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/blob/master/Blog/CI/image/jenkins.04.png?raw=true&quot;&gt;</p>
<p>offline 상태의 pc라면 <a href="https://updates.jenkins-ci.org/download/plugins" target="_blank" rel="external">https://updates.jenkins-ci.org/download/plugins</a>로 들어가서 원하는 버전의 MSBuild plugin을 다운로드 받으시면 됩니다.</p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/blob/master/Blog/CI/image/jenkins.05.png?raw=true&quot;&gt;</p>
<p>다운로드 받은 뒤 <code>고급</code> 탭을 눌러서 <code>플러그인 올리기</code> 에서 다운로드 받은 파일을 선택하면 됩니다.</p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/blob/master/Blog/CI/image/jenkins.06.png?raw=true&quot;&gt;</p>
<p>그런 뒤 Jenkins를 재가동 하면 됩니다.</p>
<h3>4. Jenkins 환경설정</h3>
<p>SVN , MSBuild 설정에 대한 부분을 설명드리겠습니다.
다른 Tool 들에 대해서도 어렵지 않게 스스로 설정이 가능하거나, 검색을 하시면 자료가 많이 나올 것입니다.</p>
<p>먼저 Jenkins 화면에서 <code>Jenkins 관리</code>-&gt; <code>시스템 설정</code> 으로 들어갑니다.</p>
<p>아래로 쭉 내리시면 <code>Subversion</code>이란 부분이 있습니다.
현재 PC에 설치된 SVN과 같은 버전으로 설정하면 끝입니다.</p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/blob/master/Blog/CI/image/jenkins.08.png?raw=true&quot;&gt;</p>
<p>거기서 조금 위로 올리시면 <code>MSBuild</code> 부분이 있습니다. 거기 버튼을 누른 뒤 PC상의 <code>MSBuild.exe</code>파일의 위치를 입력해줍니다.</p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/blob/master/Blog/CI/image/jenkins.07.png?raw=true&quot;&gt;</p>
<p>단순히 여기에 위치만 입력해 줘도 되지만, 개인적으로는 해당 위치를 시스템환경변수에 PATH로 잡아두시는 것을 추천합니다.
그러면 cmd 창에서 직접 실행도 가능합니다.</p>
<p>&lt;img src=&quot;https://github.com/DevStarSJ/Study/blob/master/Blog/CI/image/jenkins.09.png?raw=true&quot;&gt;</p>
<p><code>MSBuild</code>의 자세한 사용법에 대해서는 여기서 다루지 않겠습니다.</p>
<p>MSDN에 자세한 설명이 있으니 참조하시면 됩니다.</p>
<blockquote>
<p><a href="https://msdn.microsoft.com/ko-kr/library/ms164311.aspx" target="_blank" rel="external">https://msdn.microsoft.com/ko-kr/library/ms164311.aspx</a></p>
</blockquote>
<p>그 중 Jenkins에서 자주 사용하는 예시 한가지만 든다면...</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/p:Configuration=&quot;Release&quot; /t:Clean,Build</div></pre></td></tr></table></figure></p>
<p>Release 모드로 Clean 후 Build를 할 경우 위와 같이 써주시면 됩니다.</p>
<p>###5. Jenkins item 추가</p>
<ul>
<li><code>새로운 item</code>을 누르면 추가가 가능합니다.</li>
<li>원하시는 이름을 입력한 뒤 <code>Freestyle project</code>를 선택합니다.</li>
<li>먼저 <code>고급 프로젝트 옵션</code>에서 <code>고급</code> 버튼을 눌러서 <code>사용자 빌드 경로 사용</code>을 체크하셔서 source code를 받을 경로를 입력해 줍니다.</li>
</ul>
<blockquote>
<p>ex. <code>d:\build\svn\test_project</code></p>
</blockquote>
<ul>
<li><code>소스코드관리</code>에는 <code>Subversion</code>을 선택하시고 <code>Repository URL</code>을 입력합니다.</li>
</ul>
<blockquote>
<p>ex. <code>svn://192.168.0.1/repo/test_project/trunk</code></p>
</blockquote>
<ul>
<li><code>Add Build Step</code> 을 눌러서 <code>MSBuild</code>를 선택합니다.</li>
<li>build할 solution이나 project 파일명을 전체경로나 위에 정한 사용자 빌드 경로로 부터의 상태경로로 입력합니다.</li>
</ul>
<blockquote>
<p>ex. <code>./workspace/buildAll.sln</code></p>
</blockquote>
<ul>
<li>그리고 command line argument에 옵션을 적어줍니다.</li>
</ul>
<blockquote>
<p>ex. <code>/p:Configuration=&quot;Release&quot; /t:Clean,Build</code></p>
</blockquote>
<ul>
<li>한 item에서 여러가지의 build step을 가질 수 있습니다. 예를 들어서 <code>Release</code>로 빌드하고, <code>Debug</code>로도 빌드 한다던지, 다른 project나 solution 들을 build 한다든지 등요.</li>
<li>build step에서 <code>Execute Windows batch command</code>를 선택하시면 일단 command line에서 선택하는 명령어를 그대로 입력하셔서 실행이 가능합니다. 관련 내용을 미리 batch file (.bat)나 python으로 생성해 놓고 실행하면 편리합니다.
<ul>
<li>특정 file들을 다른 folder로 옮겨 놓고 파일이름을 다르게 복사하고 등등의 작업이 가능합니다.</li>
</ul>
</li>
<li>현재 item이 끝난 후 다른 item을 자동으로 시작 시킬려면 <code>빌드 후 조치 추가</code>에서 <code>Build other projects</code>를 눌러서 다른 item명을 입력하시면 선택이 됩니다. 콤마(,)를 입력해서 여러개 project 실행이 가능합니다. Test Project를 실행한다던지, InstallShield를 이용하여 배포 파일을 생성하는 등의 작업을 하면 편리하게 활용이 가능합니다.</li>
<li>주기적으로 build를 할려면 <code>빌드 유발</code>에 <code>Build periodically</code>를 선택하셔서 <code>Schedule</code>에 입력하시면 됩니다. 참고로 매일 새벽에 돌리실려면 <code>@midnight</code>라고 입력하시면 됩니다. 오른쪽 ?를 누르면 자세한 설명이 나옵니다.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://DevStarSJ.github.io/2015/11/10/Devops.Jenkins/" data-id="cjov1wton0042jw7beoxyrg4o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CI-CD/">CI/CD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DevOps/">DevOps</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hanbit.netty" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/29/hanbit.netty/" class="article-date">
  <time datetime="2015-10-28T15:00:00.000Z" itemprop="datePublished">2015-10-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Book/">Book</a>►<a class="article-category-link" href="/categories/Book/Review/">Review</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/29/hanbit.netty/">자바 네트워크 소녀 Netty</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3>자바 네트워크 소녀 Netty</h3>
<ul>
<li>한빛미디어</li>
<li>정경석 지음</li>
<li>책소개 Link : <a href="http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-224-3" target="_blank" rel="external">http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-224-3</a></li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.02.jpg?raw=true" alt=""></p>
<h4>첫 인상</h4>
<p>처음 책을 받고 깜짝 놀랐습니다.<br>
내가 분명 주문한 것은 IT 기술서적인데...<br>
미소녀의 대형 브로마이드가 배송되었으며, 덤으로 책이 한권 같이 왔더군요.</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.01.jpg?raw=true" alt=""></p>
<p>두께가 많이 두껍지 않아서 부담없이 들고 다니기 좋아 보입니다. 하지만 표지 그림때문에 약간 들고다니기는 망설여 지더군요.<br>
종이재질은 <code>한빛미디어</code>다 보니 당연히 최상이구요.<br>
책안의 그림, 소스코드, 스크린샷 모두 눈에 쏙쏙 들어오게 되어 있었습니다.</p>
<ul>
<li>
<p>그림<br>
<img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.03.jpg?raw=true" alt=""></p>
</li>
<li>
<p>스크린샷<br>
<img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.04.jpg?raw=true" alt=""></p>
</li>
<li>
<p>Source Code<br>
<img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.05.jpg?raw=true" alt=""></p>
</li>
</ul>
<h4>전체적인 서평</h4>
<p>수많은 개발자들이 사용하는 언어,<code>Java</code>. <code>Netty</code>는 범용 자바 네트워크 프레임 워크입니다. <code>Facebook</code>에서 출시 된 것을 보고 어떤 내용일까 궁금했는데, <code>한빛리더스 2기</code> 활동 중인데 이번 달의 목록에 이 책이 있었습니다. 그것도 선착순 5명만 가능하다고 해서 얼릉 신청했습니다.<br>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Network Server 개발을 하기 위해서는 Socket을 이용한 Chatting Server만 만들어보면 됩니다.</div><div class="line">Web Server 개발을 하기 위해서는 게시판만 한번 만들어보면 됩니다.</div></pre></td></tr></table></figure></p>
<p>와 같은 말이 있습니다. 마침 Chatting Server 쪽에 대해서 괌심이 있었습니다. Netty의 내부를 이해하기 어려운 점이 있긴 하지만 처음에 추천의 말에서 <code>네티를 처음 접하신 분은 4-5장을 꼭 정독하라</code>는 글귀를 읽고 우선 4-5장부터 차례대로 보기 시작했습니다.</p>
<p>이 책을 읽어야 하는 독자들은 학생들 보다는 Java 현업에서 네트워크 통신 개발이 경험이 있는 프로그래머나 네트워크에 대한 기반과 Java 기본 개념에서 중급으로 넘어갈 수 있는 학생들이라면 추천합니다. 무작정 Java 초급이었다가 Chatting Server를 만들려고 이 책을 접했더라면 엄청 험난한 길에 접어들 것이라 예상됩니다. 기본적인 Linux 사용법과 전반적인 Server에 대한 지식, Java 개발 경험이 있는 개발자들에게 도움이 된다고 할 수 있겠습니다. 저는 Windows 환경의 개발자이고 Java도 공부를 한적은 있지만, Project 경험은 없어서 보는데 애를 좀 먹었습니다. 예전에 TCP를 이용한 Chatting Server / Client는 교육과정을 통해서 직접 만들어 본적은 있었습니다.</p>
<p>책을 전체적으로 볼 때 각 단원마다 <code>마치며</code> 라는 부분이 너무 좋았습니다. 이해 되지 않았던 단어들 및 그리고 현재에 이용해야 하는 개발자들에게 참고 사항같이 독자들의 배려로 보이는 것으로 집필자의 작성 글들이 섬세하다는 것을 많이 느꼈습니다.</p>
<p>####1장 네티 맛보기</p>
<p>Network 관련된 기초 설명이 별도로 없기 때문에 Java 네트워크 프로그램에 대한 기본 지식이 있는 상태에서 접근해야 책을 보는데 도움이 될것입니다. 바로 다운받고 설치하는 과정으로 들어가고 특히 환경 설정에서 그림을 보여 주며 설명 해주는 부분은 기존 책들과 비슷합니다. 다만 책에서는 Windows 7을 기준으로 설명하고 있어서, Windows 8.1이나 Windows 10을 사용하는 독자들은 Putty 설치방법 등에 대해서 따로 찾아봐야 합니다. 각각의 필요한 Server에 대해 이해 할 수 있도록 우선 코드를 작성하면서 개념에 대해 설명해주는 것도 좋았습니다.<br>
Source Code에 번호를 붙여 별도로 설명을 해줌으로써 Code를 작성하고 참고할 개발자들에게는 주석을 달아 놓도록 간단하게 설명해주기때문에 그 부분도 좋았습니다.</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.06.jpg?raw=true" alt=""></p>
<h4>2장 네티 주요 특징</h4>
<p>Netty의 주요 특징에서는 동기와 비동기에 대해 자세히 설명 해주지만 프로그램적 보다는 사전에 있는 내용을 인용했기 때문에 독자들의 호불호가 갈릴것 같습니다. 그리고 다른 책과는 달리 한 장 한 장씩 동기와 비동기를 그림으로 보여 주고 각각 설명 해주는 부분이 읽기에 부담 없고 이해하는데도 쉽게 도움이 되어 좋았습니다.</p>
<p>블로킹과 논블로킹 소켓에 대한 부분은 직접 Code를 입력해 보면서 숫자를 매겨 설명을 별도로 해주는 방식이라 Source Code에 대한  분석도 좋았습니다. 그림을 통해 다양한 종류로 보여 주기 때문에 이해되지 않는 부분에 대해서도 쉽게 이해할 수 있도록 노력한 점도 좋았습니다. 글만 읽게 되는 것과 글과 그림을 동시에 보여 주는 이해도는 엄청나게 차이가 난다는 것을 다시 한번 느꼈습니다.</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.07.jpg?raw=true" alt=""></p>
<h4>3장 부트스트랩</h4>
<p>부트스트랩은 개발자, 디자이너, 퍼블리셔라면 접해야 되는 부분인데 부트스랩의 기본 정의부터 API, 다양한 이벤트 핸들러 관련 부분과 설정까지 다양하게 정리되어 있고 우선 구조에 대해서도 그림으로 보여줌으로써 한눈에 특징을 볼 수 있습니다. Java 개발자들에게 볼 수 있는 다이어그램 및 패턴을 code로 작성해 보면서 code에 붙여 진 주요한 method의 특징을 기호를 찾아 설명을 읽으면 더 자세하면서도 바로 실무에 적용할 수 있는 code가 있는 점이 너무 좋았습니다.</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.08.jpg?raw=true" alt=""></p>
<h4>4장 채널 파이프라인과 코덱</h4>
<p>Event 실행을 할 경우에 실행 과정을 보여 줄 때 기호를 표기 해 준 것이 좋았습니다. 보통 책을 읽을 때 순서를 매기지 않고 설명 식으로 진행 해주는 책이 많은데 이 책은 이해하기 쉬웠습니다. 채널 파이프 라인 예시는 관련 개념을 모르는 사람이 보기에도 적절 했습니다. 전력 공급 과정으로 채널과 채널 파이프 라인의 관계를 표현 해주는 쉽게 이해가 되었고 그림 자체도 도움이 많이 되었습니다. 각각의 구성과 설명을 그림으로 표현하고 번호를 붙여 설명해 주는 것이 특히 채널 생성과 채널 파이프라인의 구성에 대해 1장에서 작성했던 code와 주석과 설명 그리고 그림까지 한꺼번에 번호를 매겨 보여 주는 것은 독자들로 하여금 작성하면서 이해 안되어 있던 부분까지 상세하게 보여 주는 배려가 보여 너무 좋았습니다. 이벤트 핸들러의 각각의 이벤트마다 간단한 설명만 있어서 독자들이 각각 해봐야만 이해할 수 있는 부분은 조금 아쉬웠습니다.</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.09.jpg?raw=true" alt=""></p>
<h4>5장 이벤트 모델</h4>
<p>웹 개발자라면 눈 여겨 봐도 좋은 chapter입니다. <code>Node.js</code> 와 <code>ver.x</code>(Netty)의 차이점을 이용해서 Netty 이벤트 모델에 대해 설명 해주기 때문에 기존에 웹 프로그램 경험이 있는 개발자들이라면 바로 개념을 이해하고 사용할 수 있도록 그림 설명과 처리량에 대해서는 그래프로 작성해 주어 바쁜 상황에 글을 읽지 못하더라도 한눈에 표로 확인할 수 있도록 배려한 것이 좋았습니다. 그리고 code가 예시로 나오기 때문에 직접 독자들이 작성해 보면서 이해할 수 있도록 해주는 것이 다른 기존 책들보다 상세하게 표현되어 있어 이해하는데 훨씬 도움이 되었습니다.</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.10.jpg?raw=true" alt="Netty"></p>
<p>####6장 바이트 버퍼</p>
<p>이 부분은 Java 개발자이면서 전공자면 조금 쉽게 접근할 수 있을듯 합니다. 예전에 <code>NIO</code>에 대해서 교육받은 적이 있어서 쉽게 이해할 수 있었습니다. 자료 구조와 관련된 부분이 많고 source code로 설명을 해주기는 하나 이 내용을 이해할 수 있는 것은 학생들 보다는 현업에 있는 개발자들 특히 버퍼를 많이 이용하는 개발자에게도 내용이 조금은 어려울 것 같습니다. 버퍼를 많이 이용한 개발자들에게는 예제를 통해서 Netty와의 차이점을 확연히 알아볼 수 있을 것 같습니다.</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.11.jpg?raw=true" alt=""></p>
<h4>7장 네티와 채널 보안</h4>
<p>7장부터 끝까지는 <code>3부 Netty응용부분</code>이라 기존에 Netty를 사용하는 개발자들에게는 필요한 부분과 이용할 때 참고 사항이 많아지는 부분입니다. 특히 Netty는 범용 네트워크 프레임워크기 때문에 보안에 대해 관심이 많고 그 보안을 어떻게 해야 할지 모르는 개발자들에게는 한줄기 빛과 같은 단원일듯 판단됩니다.</p>
<p>그리고 네트워크 보안에 대해서도 짧게나마 설명해주는 부분이 있기 때문에 개념에 대해 잘 모르고 이용이 어려울 경우에는 책에 있는 자료를 참고하는것도 좋은 방법일것 같습니다. Netty server에 SSL을 이용하는 내용을 추가해 주는데 Windows와 Lunux에 대한 설명이 같이 있고, OpenSSL을 이용하는 방법에 압축이나 명령 같은 부분을 직접 이용한 명령어로 보여줌으로써 쉽게 따라 할 수 있도록 배려해 준 것이 좋았습니다. 그리고 채널 보안 적용하기에 서버 부트스트랩 설정 코드와 번호를 붙여 간단하게 주석을 작성할 수 있도록 해주는 배려도 좋았습니다. 실제 네트워크 데이터를 캡쳐하여 유용하게 사용하는 도구와 방법을 언급해주므로서 필요할 경우 적용 할 수 있는 점이 좋았습니다.</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.12.jpg?raw=true" alt=""></p>
<h4>8장 네티와 서드 파티 연동</h4>
<p><code>Spring framework</code>에 대한 기본 지식이 있어야 <code>Maven</code>에 접근이 가능합니다. 즉 Java만 배운 학생에게는 어려운 부분이 많아 보입니다. 하지만 <code>Eclipse</code>를 이용할 수 있는 사람이라면 실습은 쉽게 따라 할 수 있도록 잘 설명되어 있습니다. Eclipse에서  market이용하여 Maven 설치와 실습까지 동시에 진행이 되나 Linux에서 실행되는 것이기 때문에 <code>CentOS</code>를 잘 아는 학생이나  개발자들에게는 쉽게 이해 할수 있을듯 합니다. 그렇지 않을 경우 Linux와 Spring 기본 개념에 대해 공부를 하고 source code를 봐야지만 잘 알아 볼 수 있을 것입니다. 기본을 잘 알고 Spring까지 애플리케이션 작성 source code까지 있기 때문에 그대로 따라 해보고 실행해 보거나 응용할 수 있도록 해 주었습니다.</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.13.jpg?raw=true" alt=""></p>
<h4>9장 네티로 구현한 API 서버</h4>
<p>마지막은 Netty로 아예 처음부터 설계와 작업을 해서 실습이 되고 API 통합 테스트까지 해주므로서 Netty를 한번 더 과정을 볼 수 있게 해주는 과정이라 좋았습니다.</p>
<p><img src="https://github.com/DevStarSJ/Study/blob/master/Blog/Review/Books/image/small.hanbit.netty.14.jpg?raw=true" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://DevStarSJ.github.io/2015/10/29/hanbit.netty/" data-id="cjov1wtr6008rjw7bb3lluba4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Book/">Book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Review/">Review</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SIMD" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/06/25/SIMD/" class="article-date">
  <time datetime="2013-06-25T06:28:00.000Z" itemprop="datePublished">2013-06-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CPP/">CPP</a>►<a class="article-category-link" href="/categories/CPP/MFC/">MFC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/06/25/SIMD/">MFC SIMD Vector Class 사용법 정리</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>Header File : <code>&lt;dvec.h&gt;</code></li>
</ul>
<h2>SIMD Vector Class 명명법</h2>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> &lt;Type&gt;&lt;Signed&gt;&lt;Bits&gt;vec&lt;Nums&gt;</div><div class="line">&#123; F | I &#125; &#123; s | u &#125; &#123; 64 | 32 | 16 | 8 &#125; vec &#123; 8 | 4 | 2 | 1 &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>F : 실수 , I : 정수</p>
</li>
<li>
<p>s : signed, u : unsigned ( I에만 사용됨)</p>
</li>
<li>
<p>64 : double, __int64 , 32 : float, int , 16: short , 8 : char</p>
</li>
<li>
<p>8,4,2,1 : pack 개수 (Bits x Nums 는 128을 넘어 갈 수 없다. )</p>
</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ex) unsigned int 4개pack class : Iu32vec4 , float 4개 packclass : F32vec4</div></pre></td></tr></table></figure></p>
<h2>초기화</h2>
<ul>
<li>괄호 안에 각 변수들을 지정
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ex) Is32vec4 pint4(10,20,30,40);</div></pre></td></tr></table></figure></li>
</ul>
<h3>1. 연산자 ( vec = vec op vec)</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    = : 대입</div><div class="line">+, += : 덧셈</div><div class="line">- , -= : 뺄셈</div><div class="line">* , *=  : 곱셈</div><div class="line">/ , /+ : 나눗셈 (실수 연산만 가능)</div><div class="line">&amp; : 논리연산 AND</div><div class="line">| : 논리연산 OR</div><div class="line">^ : 논리연산 XOR</div></pre></td></tr></table></figure></p>
<h3>2. 연산자 (vec = vec op n )</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;, &lt;&lt;== : Left Shift ( x2 )</div><div class="line">&gt;&gt; , &gt;&gt;== : Right Shift ( /2 )</div></pre></td></tr></table></figure></p>
<h3>3. 함수 (vec = func(vec, vec)</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">simd_min() : 최소값</div><div class="line">simd_max() : 최대값</div><div class="line">andnot() : 논리연산 And Not</div></pre></td></tr></table></figure></p>
<h3>4. 비교함수 ( 참이면 0xff…, 거짓이면 0 )</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cmpeq : ==</div><div class="line">cmpneq : !=</div><div class="line">cmpgt : &gt;</div><div class="line">cmpge : &gt;=</div><div class="line">cmplt : &lt;</div><div class="line">cmple : &lt;=</div><div class="line">cmpnlt : !(A &lt; B)</div><div class="line">cmpnle : !(A &lt;= B)</div><div class="line">cmpngt : !(A &gt; B)</div><div class="line">cmpnge : !(A &gt;= B)</div></pre></td></tr></table></figure></p>
<h3>5. Select : R = Select(A,B,C,D)=&gt; if (A 비교 B) R = C else R = D</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">select_eq : ==</div><div class="line">select_neq : !=</div><div class="line">select_gt : &gt;</div><div class="line">select_ge : &gt;=</div><div class="line">select_lt : &lt;</div><div class="line">select_le : &lt;=</div><div class="line">select_nlt : !(A &lt; B)</div><div class="line">select_nle : !(A &lt;= B)</div><div class="line">select_ngt : !(A &gt; B)</div><div class="line">select_nge : !(A &gt;= B)</div></pre></td></tr></table></figure></p>
<h3>6. Unpacked / Pack (예제는 Is32vec4)</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">R = unpack_low( A, B) =&gt; R = ( B1 , A1 , B0 , A0 )</div><div class="line">R = unpack_high(A, B) =&gt; R = ( B3 , A3 , B2 , A2 )</div><div class="line">R = pack_sat(A, B) =&gt; Is16vec8 R = (B3, B2, B1, B0, A3, A2, A1, A0) : 정수형만지원</div></pre></td></tr></table></figure></p>
<h3>7.정수 Vector &lt;-&gt; Array :Vector Class에서 지원하지 앟음 intrinsic 함수 이용</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Is32vec4 A = _mm_load_si128((__m128i*) p) : 배열 Pointer를 __m128i* 로 casting 후 저장  </div><div class="line">                                                            (정렬된 메모리)</div><div class="line"></div><div class="line">s32vec4 A = _mm_loadu_si128((__m128i*) p) : 정렬되지 않은 메모리에서 데이터 읽어오기</div><div class="line">_mm_store_si128((_m128i*) p , A) : A에 저장된 값들을 배열 p에순서대로 저장</div><div class="line">                                            (정렬된 메모리)</div><div class="line">_mm_storeu_si128((_m128i*) p , A) : 정렬되지 않은 메모리에 데이터 쓰기</div></pre></td></tr></table></figure></p>
<h3>8. 실수 Vector &lt;-&gt; Array</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">loadu (F32vec4 R, float* a) : a[0] ~ a[3] 4개의 float 값을읽어서 R에 저장</div><div class="line">storeu(float* a, F32vec4 R) : R의 값을 a[0] ~ a[3]에저장</div><div class="line">store_nta(float* a, F32vec$ R) : 버퍼 없이 메모리 a[0] ~ a[3]에저장</div></pre></td></tr></table></figure></p>
<h3>9.수학 함수 (실수 연산만 가능)</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">R = sqrt(A) : 제곱근 Root</div><div class="line">R = rcp(A) : 역분수 : R = 1 / A</div><div class="line">R = rsqrt(A) : 제곱근 역분수 : R = 1 / Root A</div><div class="line">R = rcp_nr(A) : Newton-Raphson법의 역분수 : R = rcp(A) * 2 –A * rcp(A) * rcp(A)</div><div class="line">R = rsqrt_nr(A) : Newton-Raphson법의 제곤근 역분수 : R = rsqrt(A)/ 2 * ( 3 – A * rsqrt(A) * rsqrt(A) )</div><div class="line">F = add_horizontal(A) : float F = A0 + A1 + A2 + A3</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://DevStarSJ.github.io/2013/06/25/SIMD/" data-id="cjov1wtqr007wjw7b9gch25ox" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CPP/">CPP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MFC/">MFC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SIMD/">SIMD</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/9/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AWS/">AWS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/AWS/ECS/">ECS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/AWS/Lambda/">Lambda</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/AWS/SageMaker/">SageMaker</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Azure/">Azure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Book/">Book</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Book/Review/">Review</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C#</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C/ASP-NET/">ASP.NET</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/ASP-NET-Core/">ASP.NET Core</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/C/">C#</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/CPP/">CPP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/CPP/MFC/">MFC</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataScience/">DataScience</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/Oracle/">Oracle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/SQLP/">SQLP</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/DevOps/">DevOps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/Node-JS/">Node.JS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/TypeScript/">TypeScript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/DataScience/">DataScience</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/Python/">Python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tips/">Tips</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Tips/JupyterNotebook/">JupyterNotebook</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tips/macOS/">macOS</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APIGateway/">APIGateway</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ASP-NET/">ASP.NET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ASP-NET-Core/">ASP.NET Core</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWS/">AWS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Azure/">Azure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AzureContainerRegistry/">AzureContainerRegistry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AzureContainerService/">AzureContainerService</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AzureFileStorage/">AzureFileStorage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AzureFunction/">AzureFunction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Batch/">Batch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Book/">Book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CI-CD/">CI/CD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPP/">CPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataScience/">DataScience</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DevOps/">DevOps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECS/">ECS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HyperparameterTuning/">HyperparameterTuning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JupyterNotebook/">JupyterNotebook</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kaggle/">Kaggle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda/">Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MFC/">MFC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MachineLearning/">MachineLearning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matplotlib/">Matplotlib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-JS/">Node.JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Review/">Review</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/S3/">S3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SIMD/">SIMD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLP/">SQLP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SageMaker/">SageMaker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Serverless/">Serverless</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/">Tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ToolkitPro/">ToolkitPro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UAC/">UAC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XGBoost/">XGBoost</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/">express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/">macOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/한글폰트/">한글폰트</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/APIGateway/" style="font-size: 15px;">APIGateway</a> <a href="/tags/ASP-NET/" style="font-size: 13.57px;">ASP.NET</a> <a href="/tags/ASP-NET-Core/" style="font-size: 12.14px;">ASP.NET Core</a> <a href="/tags/AWS/" style="font-size: 19.29px;">AWS</a> <a href="/tags/Azure/" style="font-size: 10.71px;">Azure</a> <a href="/tags/AzureContainerRegistry/" style="font-size: 10px;">AzureContainerRegistry</a> <a href="/tags/AzureContainerService/" style="font-size: 10px;">AzureContainerService</a> <a href="/tags/AzureFileStorage/" style="font-size: 10.71px;">AzureFileStorage</a> <a href="/tags/AzureFunction/" style="font-size: 10px;">AzureFunction</a> <a href="/tags/Batch/" style="font-size: 10px;">Batch</a> <a href="/tags/Book/" style="font-size: 16.43px;">Book</a> <a href="/tags/C/" style="font-size: 18.57px;">C#</a> <a href="/tags/CI-CD/" style="font-size: 11.43px;">CI/CD</a> <a href="/tags/CPP/" style="font-size: 13.57px;">CPP</a> <a href="/tags/DataScience/" style="font-size: 15.71px;">DataScience</a> <a href="/tags/Database/" style="font-size: 20px;">Database</a> <a href="/tags/DevOps/" style="font-size: 11.43px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 10.71px;">Docker</a> <a href="/tags/ECS/" style="font-size: 10px;">ECS</a> <a href="/tags/HyperparameterTuning/" style="font-size: 10px;">HyperparameterTuning</a> <a href="/tags/JavaScript/" style="font-size: 11.43px;">JavaScript</a> <a href="/tags/Jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/tags/JupyterNotebook/" style="font-size: 11.43px;">JupyterNotebook</a> <a href="/tags/Kaggle/" style="font-size: 14.29px;">Kaggle</a> <a href="/tags/Lambda/" style="font-size: 17.86px;">Lambda</a> <a href="/tags/MFC/" style="font-size: 13.57px;">MFC</a> <a href="/tags/MachineLearning/" style="font-size: 17.14px;">MachineLearning</a> <a href="/tags/Matplotlib/" style="font-size: 10px;">Matplotlib</a> <a href="/tags/Node-JS/" style="font-size: 12.86px;">Node.JS</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 20px;">Oracle</a> <a href="/tags/Python/" style="font-size: 16.43px;">Python</a> <a href="/tags/Review/" style="font-size: 16.43px;">Review</a> <a href="/tags/S3/" style="font-size: 10px;">S3</a> <a href="/tags/SIMD/" style="font-size: 10px;">SIMD</a> <a href="/tags/SQLP/" style="font-size: 20px;">SQLP</a> <a href="/tags/SageMaker/" style="font-size: 10px;">SageMaker</a> <a href="/tags/Serverless/" style="font-size: 12.14px;">Serverless</a> <a href="/tags/Tensorflow/" style="font-size: 12.14px;">Tensorflow</a> <a href="/tags/ToolkitPro/" style="font-size: 10.71px;">ToolkitPro</a> <a href="/tags/TypeScript/" style="font-size: 10.71px;">TypeScript</a> <a href="/tags/UAC/" style="font-size: 10px;">UAC</a> <a href="/tags/XGBoost/" style="font-size: 10px;">XGBoost</a> <a href="/tags/express/" style="font-size: 10px;">express</a> <a href="/tags/macOS/" style="font-size: 10px;">macOS</a> <a href="/tags/한글폰트/" style="font-size: 10px;">한글폰트</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/24/aws-batch-tutorial/">Introduce to AWS Batch</a>
          </li>
        
          <li>
            <a href="/2018/11/04/kaggle.coursera.competition.03.02/">Coursera Kaggle 강의(How to win a data science competition) week 3,4 Advanced Feature Engineering 요약</a>
          </li>
        
          <li>
            <a href="/2018/10/30/kaggle.coursera.competition.04.02/">Coursera Kaggle 강의(How to win a data science competition) week 4-4 Ensemble 요약</a>
          </li>
        
          <li>
            <a href="/2018/10/30/kaggle.coursera.competition.04.01/">Coursera Kaggle 강의(How to win a data science competition) week 4-1 Hyperparameter Tuning 요약</a>
          </li>
        
          <li>
            <a href="/2018/10/30/181030.data.philosophy/">데이터를 철학하다</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Yun Seok-joon<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>