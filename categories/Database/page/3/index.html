
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Dev Star SJ">
    <title>Category: Database - Dev Star SJ</title>
    <meta name="author" content="Yun Seok-joon">
    
    
    
    <meta name="description" content="Sharing the common developer&apos;s try-on">
<meta property="og:type" content="blog">
<meta property="og:title" content="Dev Star SJ">
<meta property="og:url" content="http://DevStarSJ.github.io/categories/Database/page/3/index.html">
<meta property="og:site_name" content="Dev Star SJ">
<meta property="og:description" content="Sharing the common developer&apos;s try-on">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dev Star SJ">
<meta name="twitter:description" content="Sharing the common developer&apos;s try-on">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/font-awesome.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox-thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Dev Star SJ</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://DevLunaSJ.github.com/" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.facebook.com/seokjoon.yun.9" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-facebook"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://plus.google.com/u/1/108379332089647292574" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-google-plus"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/in/sjyun/" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-linkedin"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:seokjoon.yun@gmail.com" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/21/02.01.sql.basic/">
                            SQLP 2-1 SQL 기본
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-21T00:00:00+09:00">
	
		    Jan 21, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="2과목-SQL-기본-및-활용"><a href="#2과목-SQL-기본-및-활용" class="headerlink" title="2과목 SQL 기본 및 활용"></a>2과목 SQL 기본 및 활용</h2><ul>
<li>20문제</li>
<li>각 상황별로 SQL문 작성이 가능할 정도로 연습해야 합니다.</li>
<li>기본적인 SQL문법 및 함수는 생략하고 Tuning에 활용될수 있는 것 위주로 정리하고자 합니다.</li>
</ul>
<h3 id="1장-SQL-기본"><a href="#1장-SQL-기본" class="headerlink" title="1장 SQL 기본"></a>1장 SQL 기본</h3><h4 id="1-1-SQL-종류"><a href="#1-1-SQL-종류" class="headerlink" title="1.1 SQL 종류"></a>1.1 SQL 종류</h4><ol>
<li>DML (Data Manipulation Language) : 데이터 조작어<ul>
<li>SELECT : 조회</li>
<li>INSERT, UPDATE, DELETE : 데이터에 변형을 가하는 명령어</li>
</ul>
</li>
<li>DDL (Data Definition Language) : 데이터 정의어<ul>
<li>CREATE, ALTER, DROP, RENAME :  테이블 등의 데이터 구조를 생성, 변경, 삭제하는 명령어</li>
</ul>
</li>
<li>DCL (Data Control Language) : 데이터 제어어<ul>
<li>GRANT, REVOKE : DB 및 객체의 접근, 사용 권한을 주고 회수하는 명령어</li>
</ul>
</li>
<li>TCL (Transaction Control Language) : 트랜잭션 제어어<ul>
<li>COMMIT, ROLLBACK : 트랜잭션을 제어하는 명령어</li>
</ul>
</li>
</ol>
<h4 id="1-2-CREATE-TABLE"><a href="#1-2-CREATE-TABLE" class="headerlink" title="1.2 CREATE TABLE"></a>1.2 CREATE TABLE</h4><h5 id="1-기본적인-생성법"><a href="#1-기본적인-생성법" class="headerlink" title="1. 기본적인 생성법"></a>1. 기본적인 생성법</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 테이블명 (</div><div class="line">    컬럼명    DATATYPE    [<span class="keyword">DEFAULT</span> 형식],</div><div class="line">    ...</div><div class="line">    <span class="keyword">CONSTRAINT</span> 테이블명_PK PRIMARY <span class="keyword">KEY</span> (컬럼, ...),</div><div class="line">    <span class="keyword">CONSTRAINT</span> 테이블명_FK FOREIGN <span class="keyword">KEY</span> (컬럼, ...) <span class="keyword">REFERENCES</span> 테이블<span class="number">2</span>(컬럼, ...)</div><div class="line">);</div></pre></td></tr></table></figure>
<h5 id="2-CTAS-Create-Table-as-Select"><a href="#2-CTAS-Create-Table-as-Select" class="headerlink" title="2. CTAS (Create Table as Select)"></a>2. CTAS (Create Table as Select)</h5><ul>
<li><p>Oracle</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> EMP_COPY</div><div class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
</li>
<li><p>MS-SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">INTO</span> EMP_COPY <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>NOT NULL</code> 제약조건을 제외하고는 모두 삭제</li>
</ul>
<h4 id="1-3-TRUNCATE-TABLE-vs-DROP-TABLE-DELETE-TABLE"><a href="#1-3-TRUNCATE-TABLE-vs-DROP-TABLE-DELETE-TABLE" class="headerlink" title="1.3 TRUNCATE TABLE vs DROP TABLE, DELETE TABLE"></a>1.3 TRUNCATE TABLE vs DROP TABLE, DELETE TABLE</h4><ul>
<li>TRUNCATE TABLE<ul>
<li>DROP TABLE과의 차이점 : Table을 삭제하지 않고 모든 row들을 제거한다.</li>
<li>DELETE TABLE과의 차이점 : 시스템 부하가 훨씬 적인 대신에 복구가 불가능하다. (rollback 불가)</li>
</ul>
</li>
</ul>
<h4 id="1-4-TRANSACTION"><a href="#1-4-TRANSACTION" class="headerlink" title="1.4 TRANSACTION"></a>1.4 TRANSACTION</h4><h5 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h5><ul>
<li>원자성 (atomicity) : 모두 정상적으로 실행되거나, 실행되지 않은 상태로 되거나 (all or nothing )</li>
<li>일관성 (consistency) : 실행전에 잘못된 상태가 아니었다면, 실행후에도 잘못이 있으면 안됨</li>
<li>고립성 (isolation) : 도중에 다른 트랜잭션의 영향을 받지 않음</li>
<li>지속성 (durability) : 수행후 갱신한 내용은 영구적으로 저장</li>
</ul>
<h5 id="명령어"><a href="#명령어" class="headerlink" title="명령어"></a>명령어</h5><ul>
<li>COMMIT : 변경된 상태를 DB에 반영</li>
<li>ROLLBACK : 트랜잭션 수행 이전 상태로 되돌림</li>
<li>SAVEPOINT [저장명칭] : 현시점까지만 ROLLBACK이 가능하도록 SAVEPOINT 지정 (MS-SQL에서는 SAVE TRANSACTION [저장명칭])</li>
<li>ROLLBACK TO [저장명칭] : 해당 SAVEPOINT 까지 ROLLBACK (MS-SQL에서는 ROLLBACK TRANSACTION [저장명칭])</li>
</ul>
<h4 id="1-5-ROWNUM-Oracle-TOP-MS-SQL"><a href="#1-5-ROWNUM-Oracle-TOP-MS-SQL" class="headerlink" title="1.5 ROWNUM (Oracle), TOP (MS-SQL)"></a>1.5 ROWNUM (Oracle), TOP (MS-SQL)</h4><ul>
<li>ROWNUM : SQL 처리결과 각 행의 임시 일련번호</li>
<li><p>1개의 행만 출력할 경우  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> = <span class="number">1</span>;</div><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt;= <span class="number">1</span>;</div><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt; <span class="number">2</span>;</div></pre></td></tr></table></figure>
<ul>
<li>n개의 행을 출력할 경우  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt;= n;</div><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt; n+<span class="number">1</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>TOP : 출력결과의 행 수를 제한  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TOP( n [<span class="keyword">PERCENT</span>] [<span class="keyword">WITH</span> <span class="keyword">TIES</span>] ) ... <span class="keyword">FROM</span> ...;</div></pre></td></tr></table></figure>
<ul>
<li>n : n의 갯수 만큼 행을 출력</li>
<li>PERCENT : n % 만큼 출력</li>
<li>WITH TIES : 마지막 행과 동일한 값과 동일한 값은 추가로 같이 출력</li>
</ul>
</li>
</ul>
<h4 id="1-6-CASE"><a href="#1-6-CASE" class="headerlink" title="1.6 CASE"></a>1.6 CASE</h4><ul>
<li>프로그래밍의 IF-THEN-ELSE와 비슷한 표현식입니다.</li>
</ul>
<h5 id="1-단순비교-해당-값에-따라-분류"><a href="#1-단순비교-해당-값에-따라-분류" class="headerlink" title="1. 단순비교 : 해당 값에 따라 분류"></a>1. 단순비교 : 해당 값에 따라 분류</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CASE value WHEN 1 THEN 'one'</div><div class="line">           WHEN 2 THEN 'two'</div><div class="line">           ELSE NULL</div><div class="line"><span class="keyword">END</span></div></pre></td></tr></table></figure>
<h5 id="2-조건비교-해당-조건에-따라-분류"><a href="#2-조건비교-해당-조건에-따라-분류" class="headerlink" title="2. 조건비교 : 해당 조건에 따라 분류"></a>2. 조건비교 : 해당 조건에 따라 분류</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CASE WHEN value = 1 THEN 'one'</div><div class="line">     WHEN value = 2 THEN 'two'</div><div class="line">     ELSE NULL</div><div class="line"><span class="keyword">END</span></div></pre></td></tr></table></figure>
<h5 id="3-DECODE-단순비교를-보다-짧게-표한하는-Oracle-함수"><a href="#3-DECODE-단순비교를-보다-짧게-표한하는-Oracle-함수" class="headerlink" title="3. DECODE : 단순비교를 보다 짧게 표한하는 Oracle 함수"></a>3. DECODE : 단순비교를 보다 짧게 표한하는 Oracle 함수</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DECODE(value, 1,'one', 2,'two', NULL)</div></pre></td></tr></table></figure>
<h4 id="1-7-NULL"><a href="#1-7-NULL" class="headerlink" title="1.7 NULL"></a>1.7 NULL</h4><ul>
<li>NULL 관련 문제는 반드시 출제된다.</li>
</ul>
<h5 id="NVL-Oracle-ISNULL-MS-SQL"><a href="#NVL-Oracle-ISNULL-MS-SQL" class="headerlink" title="NVL (Oracle), ISNULL (MS-SQL)"></a>NVL (Oracle), ISNULL (MS-SQL)</h5><p>해당 값이 NULL일 경우 2번째 인자의 값을 출력한다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> NVL(SAL,<span class="number">0</span>) <span class="keyword">FROM</span> EMP; <span class="comment">-- Oracle</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">ISNULL</span>(SAL,<span class="number">0</span>) <span class="keyword">FROM</span> EMP; <span class="comment">-- MS-SQL</span></div></pre></td></tr></table></figure></p>
<h5 id="COALESCE"><a href="#COALESCE" class="headerlink" title="COALESCE"></a>COALESCE</h5><p>인수 중 최초로 NULL이 아닌 값을 출력한다. 모두 NULL인 경우 NULL이 출력된다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, COMM, SAL, <span class="keyword">COALESCE</span>(COMM, SAL) COAL <span class="keyword">FROM</span> EMP;</div></pre></td></tr></table></figure></p>
<p>위 문장은 아래의 CASE문으로 표현한 것과 같다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, COMM, SAL,</div><div class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> COMM <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> COMM</div><div class="line">            <span class="keyword">WHEN</span> SAL <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> SAL</div><div class="line">            <span class="keyword">ELSE</span> <span class="literal">NULL</span></div><div class="line">       <span class="keyword">END</span> COAL</div><div class="line">  <span class="keyword">FROM</span> EMP;</div></pre></td></tr></table></figure></p>
<h4 id="1-8-집계함수-Aggregate-function"><a href="#1-8-집계함수-Aggregate-function" class="headerlink" title="1.8 집계함수 (Aggregate function)"></a>1.8 집계함수 (Aggregate function)</h4><ul>
<li>GROUP 당 단 1개의 값만 출력하는 함수</li>
<li>SELECT , HAVING, ORDER BY 절에서 사용할 수 있다.</li>
<li>집계함수에 들어온 NULL값은 계산에 포함시키지 않는다. (참고로 산술연산에 NULL 값이 포함되어 있으면 결과는 무조건 NULL이다.)</li>
</ul>
<h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5><p>GROUP BY에 명시된 컬럼, 집계함수의 결과값 만 가능하다.</p>
<h5 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h5><p>여기에 명시한 컬럼, 표현식 단위로 집계함수를 이용하여 계산한다.</p>
<h5 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h5><p>여기에 적은 조건에 부합하는 row만 집계함수 계산에 참여한다. (GROUP BY 이전 필터링 역할)</p>
<h5 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h5><p>집계된 결과 중 HAVING 절의 조건에 만족하는 것만 출력한다. (GROUP BY 이후 필터링 역할)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> D.DEPTNO, <span class="keyword">MAX</span>(DNAME) <span class="keyword">AS</span> DNAME, <span class="keyword">SUM</span>(SAL) <span class="keyword">AS</span> <span class="keyword">SUM</span>, <span class="keyword">AVG</span>(SAL) <span class="keyword">AS</span> <span class="keyword">AVG</span></div><div class="line">  <span class="keyword">FROM</span> DEPT D, EMP E</div><div class="line"> <span class="keyword">WHERE</span> D.DEPTNO = E.DEPTNO</div><div class="line">   <span class="keyword">AND</span> D.DEPTNO <span class="keyword">IN</span> (<span class="number">10</span>, <span class="number">30</span>)     <span class="comment">-- DEPTNO가 10, 30 인것만 집계로 계산</span></div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> D.DNAME</div><div class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(SAL) &gt;= <span class="number">10000</span>        <span class="comment">-- 계산된 결과중 10000이 넘는 것만 출력</span></div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">SUM</span>(SAL);</div></pre></td></tr></table></figure>
<h5 id="SELECT-문장-실행순서"><a href="#SELECT-문장-실행순서" class="headerlink" title="SELECT 문장 실행순서"></a>SELECT 문장 실행순서</h5><ol>
<li>FROM : 대상 Table 검색</li>
<li>WHERE : 검색 대상이 아닌 데이터 제거</li>
<li>GROUP BY : 집계할 단위로 그룹화</li>
<li>HAVING : 집계한 것중 조건에 맞는 것만 선택</li>
<li>SELECT : 출력할 값들을 계산 및 함수적용</li>
<li>ORDER BY : 데이터를 정렬하여서 출력</li>
</ol>
<h5 id="CASE-GROUP-BY"><a href="#CASE-GROUP-BY" class="headerlink" title="CASE - GROUP BY"></a>CASE - GROUP BY</h5><p>1정규화로 모델링된 테이블들에서 보고서를 만들때 많이 사용되는 기법이다.</p>
<p>예를 들어서 각 부서별로 입사월별 급여합계가 필요한 경우가 있다고 가정했을 때</p>
<p>먼저 부서, 사원명, 입사월, 급여를 출력해보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, DEPTNO, <span class="keyword">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> HIREDATE) M, SAL</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.01.decode.01.png?raw=true"></p>
<p>위 문장을 이용하여 각 월별로 컬럼을 생성하여 해당 월에 급여를 출력해보자.<br>(CASE랑 기능이 같은 DECODE를 사용하겠다.)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, DEPTNO,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">1</span>,SAL) <span class="keyword">AS</span> M01,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">2</span>,SAL) <span class="keyword">AS</span> M02,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">3</span>,SAL) <span class="keyword">AS</span> M03,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">4</span>,SAL) <span class="keyword">AS</span> M04,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">5</span>,SAL) <span class="keyword">AS</span> M05,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">6</span>,SAL) <span class="keyword">AS</span> M06,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">7</span>,SAL) <span class="keyword">AS</span> M07,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">8</span>,SAL) <span class="keyword">AS</span> M08,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">9</span>,SAL) <span class="keyword">AS</span> M09,</div><div class="line">       <span class="keyword">DECODE</span>(M,<span class="number">10</span>,SAL) <span class="keyword">AS</span> M10,</div><div class="line">       <span class="keyword">DECODE</span>(M,<span class="number">11</span>,SAL) <span class="keyword">AS</span> M11,</div><div class="line">       <span class="keyword">DECODE</span>(M,<span class="number">12</span>,SAL) <span class="keyword">AS</span> M12</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> ENAME, DEPTNO, <span class="keyword">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> HIREDATE) M, SAL</div><div class="line">          <span class="keyword">FROM</span> SCOTT.EMP )</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> DEPTNO, ENAME;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.01.decode.02.png?raw=true"></p>
<p>이제 위 문장을 부서별로 GROUP BY 하는건 어렵지 않을 것이다.<br>참고로 NULL인 경우 0으로 표시하도록 NVL을 이용하였다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">1</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M01,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">2</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M02,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">3</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M03,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">4</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M04,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">5</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M05,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">6</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M06,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">7</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M07,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">8</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M08,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">9</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M09,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M,<span class="number">10</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M10,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M,<span class="number">11</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M11,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M,<span class="number">12</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M12</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> ENAME, DEPTNO, <span class="keyword">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> HIREDATE) M, SAL</div><div class="line">          <span class="keyword">FROM</span> SCOTT.EMP )</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.01.decode.03.png?raw=true"></p>
<h4 id="1-9-JOIN"><a href="#1-9-JOIN" class="headerlink" title="1.9 JOIN"></a>1.9 JOIN</h4><p>JOIN은 한번에 2개의 집합간에만 가능하다.<br>FROM A, B, C, D 가 있더라도 이 중 2개를 먼저 JOIN하고 그 결과를 다음과 JOIN하는 식으로 처리된다.</p>
<p>JOIN에 대해서는 2장에서 자세히 다루려했으나…<br>거기에 시간을 빼았겨서는 안될듯하여 그냥 여기서 간단히 다루겠습니다.</p>
<h5 id="JOIN-연산"><a href="#JOIN-연산" class="headerlink" title="JOIN 연산"></a>JOIN 연산</h5><ul>
<li>EQUI JOIN</li>
</ul>
<p>일반적으로 PK - FK 의 관계에서 많이 이루어진다.<br>WHERE 절이나 ON 절에서 <code>=</code> 연산으로 JOIN 한다.  </p>
<ul>
<li>Non EQUI JOIN</li>
</ul>
<p><code>=</code>연산이 아닌 연산으로 JOIN을 수행한다. ( BETWEEN, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;, != )</p>
<p>예를 들어 SALGRADE Table에 각 급여구간별 GRADE가 저장된 경우, EMP의 각 사원별로 급여등급을 구하고자할때 다음과 같이 작성하면 된다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> E.ENAME, E.DEPTNO, E.SAL, G.GRADE</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP E, SCOTT.SALGRADE G</div><div class="line"> <span class="keyword">WHERE</span> E.SAL <span class="keyword">BETWEEN</span> G.LOSAL <span class="keyword">AND</span> G.HISAL</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.01.nonEQ.png?raw=true"></p>
<h5 id="JOIN-종류"><a href="#JOIN-종류" class="headerlink" title="JOIN 종류"></a>JOIN 종류</h5><ul>
<li><p>INNER JOIN</p>
<ul>
<li>양쪽 Table 모두 조건에 해당되는 데이터만 출력 (교집합)</li>
<li>Natural JOIN : INNER JOIN 에서 중복된 컬럼은 한번만 출력됨<ul>
<li>모든 일치된 칼럼에 대해서 JOIN 되지만, USING으로 원하는 컬럼만 선택이 가능 (실제로 해보니 USING 안쓰면 ERROR)<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP E, DEPT D <span class="keyword">WHERE</span> E.DEPTNO = D.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * EMP E <span class="keyword">INNER</span> <span class="keyword">JOIN</span> DEPT D <span class="keyword">ON</span> E.DEPTNO = D.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP NATUAL <span class="keyword">JOIN</span> DEPT <span class="keyword">USING</span> (DEPTNO);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>OUTER JOIN</p>
<ul>
<li>LEFT OUTER JOIN : 왼쪽 Table의 모든 row 출력, 오른쪽 Table에는 조건에 맞으면 출력하고 아니면 NULL</li>
<li>RIGHT OUTER JOIN : 오른쪽 Table의 모든 row 출력, 왼쪽 Table에는 조건에 맞으면 출력하고 아니면 NULL</li>
<li>FULL OUTER JOIN : 좌,우측을 모두 읽어서 서로 상대에게 있으면 출력 없으면 NULL (LEFT OUTER와 RIGHT OUTER를 UNION 한거랑 결과가 같음)</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP E <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> SCOTT.DEPT D <span class="keyword">ON</span> E.DEPTNO = D.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP E <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> SCOTT.DEPT D <span class="keyword">ON</span> E.DEPTNO = D.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP E <span class="keyword">FULL</span> <span class="keyword">JOIN</span> SCOTT.DEPT D <span class="keyword">ON</span> E.DEPTNO = D.DEPTNO;</div></pre></td></tr></table></figure>
<ul>
<li>CROSS JOIN (CARTESIAN PRODUCT)<ul>
<li>양쪽 Table의 모든 row 들을 모두 관계짓는다. (A에 10개 row, B에 5개 row가 있을 경우 결과는 10 x 5 = 50개가 된다.)</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> SCOTT.DEPT;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP, SCOTT.DEPT;</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/21/02.01.sql.basic/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/01/21/02.01.sql.basic/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/20/01.02.modeling_performance/">
                            SQLP 1-2 데이터 모델과 성능
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-20T01:00:00+09:00">
	
		    Jan 20, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="1과목-데이터-모델링의-이해"><a href="#1과목-데이터-모델링의-이해" class="headerlink" title="1과목 데이터 모델링의 이해"></a>1과목 데이터 모델링의 이해</h1><ul>
<li>10문제</li>
<li>외우기 보다는 반복적으로 읽어서 전반적인 내용을 이해하는 수준에서 마무리 하는것을 목표로 잡아야 겠습니다.</li>
</ul>
<h2 id="제-2장-데이터-모델과-성능"><a href="#제-2장-데이터-모델과-성능" class="headerlink" title="제 2장 데이터 모델과 성능"></a>제 2장 데이터 모델과 성능</h2><h3 id="1절-성능-데이터-모델링의-개요"><a href="#1절-성능-데이터-모델링의-개요" class="headerlink" title="1절 성능 데이터 모델링의 개요"></a>1절 성능 데이터 모델링의 개요</h3><ul>
<li>성능 데이터 모델링이란 ? 성능향상을 목적으로 모델링 하는 것</li>
<li>수행시점은 ? 빠르면 빠를수록 좋다. 분석/설계 단계에서는 운영때보다 더 적은 비용으로 가능하다.</li>
</ul>
<h4 id="성능-모델링-고려사항"><a href="#성능-모델링-고려사항" class="headerlink" title="성능 모델링 고려사항"></a>성능 모델링 고려사항</h4><ol>
<li>기본적으로 정규화를 수행해놓고 시작한다.</li>
<li>데이터베이스 용량산정</li>
<li>데이터베이스 트랜잭션 유형 파악</li>
<li>용량과 트랜잭션 유형에 따라 반정규화 수행</li>
<li>이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정</li>
<li>성능관점의 데이터 모델 검증</li>
</ol>
<p>일단 정규화를 완벽하게 해놓고 시작해야 한다.<br>그 상태에서 어느 엔터티에 트랜잭션이 들어오는지 알아봐야 하는데,<br>가장 간단한 방법이 용량이 집중적으로 늘어나는 엔터티를 찾는 것이다.<br>트랜잭션 유형도 파악할 필요가 있는데, CRUD, 시퀀스 다이어그램 등을 참조하면 된다.<br>파악된 트랜잭션 유형으로 SQL문장의 조인관계 테이블의 칼럼들을 파악할 수 있으며,<br>이렇게 모은 자료를 근거로 반정규화를 적용한다.<br>그 다음에 성능을 고려하야 PK/FK를 성능이 우수한 순서대로 칼럼 순서를 조정한다.<br>데이터 모델 규칙보다는 성능적인 측면을 충분히 고려해야 한다.</p>
<h3 id="2절-정규화와-성능"><a href="#2절-정규화와-성능" class="headerlink" title="2절 정규화와 성능"></a>2절 정규화와 성능</h3><p>일반적으로 정규화를 하면 조회시 JOIN이 늘어나기 때문에 성능이 저하되고,<br>DML (INSERT, UPDATE, DELETE) 연산의 성능이 향상된다.<br>하지만 모든 조회에서 성능이 저하되는 것은 아니고, 정규화를 해야만 성능이 향상되는 경우도 아주 많다.  </p>
<h5 id="정규화가-더-빠른-사례-1-컬럼이-많을-경우-버퍼-낭비"><a href="#정규화가-더-빠른-사례-1-컬럼이-많을-경우-버퍼-낭비" class="headerlink" title="정규화가 더 빠른 사례 1 : 컬럼이 많을 경우 (버퍼 낭비)"></a>정규화가 더 빠른 사례 1 : 컬럼이 많을 경우 (버퍼 낭비)</h5><p>원래 (반정규화된) 테이블에는 컬럼이 10개가 있었다.<br>조회시 해당 테이블에서 PK를 제외하고 2개의 컬럼만 자주 읽힌다.<br>오랜기간 동안의 이력중 PK 포함 그 3개의 컬럼만 자주 읽을 경우라면,<br>나머지 컬럼들을 PK값에 종속적인 테이블로 따로 분리를 하는 것이 유리하다.</p>
<h5 id="정규화가-더-빠른-사례-2-DISTINCT를-써야-할-경우"><a href="#정규화가-더-빠른-사례-2-DISTINCT를-써야-할-경우" class="headerlink" title="정규화가 더 빠른 사례 2 : DISTINCT를 써야 할 경우"></a>정규화가 더 빠른 사례 2 : DISTINCT를 써야 할 경우</h5><ul>
<li>일자별 거래물건 (100만건) : 물건번호(PK), 일자, 시간, 장소, …</li>
<li>일자별 거래내역 (2만건) : (일자, 장소) (PK) 금액, 건수, …</li>
</ul>
<p>광화문에서 거래된 금액을 구하는 SQL문은 다음과 같다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> B.금액</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 일자, 장소 <span class="keyword">FROM</span> 일자별거래물건 <span class="keyword">WHERE</span> 장소 = <span class="string">'광화문`) A, -- 100만건을 DISTINCT</span></div><div class="line">       일자별거래내역 B</div><div class="line"> WHERE A.일자 = B.일자</div><div class="line">   AND A.장소 = B.장소</div></pre></td></tr></table></figure>
<p>만약 위에서 DISTICT 한 결과가 5천건이라면, (일자, 장소) 를 별도의 테이블로 생성하는 것이 유리하다.</p>
<ul>
<li>일자별 거래물건 (100만건) : 물건번호(PK), 일자(FK), …</li>
<li>거래 (5천건) : 일자(PK), 시간, 장소</li>
<li>일자별 거래내역 (2만건) : (일자(FK), 장소) (PK) , 금액, 건수, …</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> B.금액</div><div class="line">  <span class="keyword">FROM</span> 거래 A, 일자별거래내역 B</div><div class="line"> <span class="keyword">WHERE</span> A.장소 = <span class="string">'광화문'</span> <span class="comment">-- 5천건</span></div><div class="line">   <span class="keyword">AND</span> A.일자 = B.일자</div><div class="line">   <span class="keyword">AND</span> A.장소 = B.장소</div></pre></td></tr></table></figure>
<h5 id="정규화가-더-빠른-사례-3-동일한-속성-형식이-여러개-나열된-경우"><a href="#정규화가-더-빠른-사례-3-동일한-속성-형식이-여러개-나열된-경우" class="headerlink" title="정규화가 더 빠른 사례 3 : 동일한 속성 형식이 여러개 나열된 경우"></a>정규화가 더 빠른 사례 3 : 동일한 속성 형식이 여러개 나열된 경우</h5><p>한 테이블에 속성1, 속성2, 속성3, … 이 여러개 있고, 각각에 INDEX가 걸려 있는 경우를 말한다.<br>이런 경우 DML 작업에서의 성능저하 때문에 INDEX를 두지 않거나, 1개 정도만 만드는 경우가 많다.<br>각 속성에 부합하는 데이터를 찾는 SQL문은 다음과 같다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ...</div><div class="line">  <span class="keyword">FROM</span> 장비</div><div class="line"> <span class="keyword">WHERE</span> 속성<span class="number">1</span> = <span class="string">'1'</span></div><div class="line">    <span class="keyword">OR</span> 속성<span class="number">2</span> = <span class="string">'2'</span></div><div class="line">    <span class="keyword">OR</span> 속성<span class="number">3</span> = <span class="string">'3'</span></div><div class="line">   ...</div></pre></td></tr></table></figure>
<p>각각의 속성에 모두 INDEX를 걸어둔 경우가 아니라면 Full Scan이나 Index Range Scan으로 넓은 범위를 찾아야 한다.</p>
<p>위 Table을 아래와 같이 먼저 정규화를 수행한다.</p>
<ul>
<li>장비 : 장비코드(PK), … (속성들은 모두 제외)</li>
<li>속성 : (장비코드(FK), 속성코드) (PK), 속성값</li>
</ul>
<p>위 상태에서는 속성 테이블에 PK로 인하여 INDEX가 생성되어 있으므로 조회시 성능이 향상된다.<br>조회는 다음과 같이 수행하면 된다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ...</div><div class="line">  <span class="keyword">FROM</span> 장비 A, 속성 B</div><div class="line"> <span class="keyword">WHERE</span> A.장비코드 = B.장비코드</div><div class="line">   <span class="keyword">AND</span> (   (B.속성코드 = <span class="string">'1'</span> <span class="keyword">AND</span> B.속성값 = <span class="string">'1'</span>)</div><div class="line">        <span class="keyword">OR</span> (B.속성코드 = <span class="string">'2'</span> <span class="keyword">AND</span> B.속성값 = <span class="string">'2'</span>)</div><div class="line">        <span class="keyword">OR</span> (B.속성코드 = <span class="string">'3'</span> <span class="keyword">AND</span> B.속성값 = <span class="string">'3'</span>) )</div></pre></td></tr></table></figure></p>
<p>위와 같이 속성1, 2, 3 뿐만 아니라 이력 같은 데이터를 함께 보관하면서<br>장기재고 1개월 수량,금액 , 2개월 수량,금액 , 3개월 수량,금액 과 같은 형식의 컬럼이 있는경우<br>재고기간 별 수량,금액 을 별도 테이블로 분리하는 것이 유리하다.</p>
<h2 id="3절-반정규화와-성능"><a href="#3절-반정규화와-성능" class="headerlink" title="3절 반정규화와 성능"></a>3절 반정규화와 성능</h2><ul>
<li>반정규화란 ?</li>
</ul>
<p>성능향상, 개발, 운영의 편리를 위하여 데이터 중복을 각오하고 테이블을 통합하는 것을 의미한다.<br>단순히 JOIN이 귀찮아서 컬럼들을 통합하다가는 데이터의 무결성을 깨트리게 된다.  </p>
<h3 id="3-1-반정규화-적용방법"><a href="#3-1-반정규화-적용방법" class="headerlink" title="3.1 반정규화 적용방법"></a>3.1 반정규화 적용방법</h3><ol>
<li>반정규화 대상조사<ul>
<li>자주 사용되는 table에 range-scan을 하는 경우</li>
<li>대량의 데이터가 있는 table에 range-scan을 하는 경우</li>
<li>통계성 프로세스에서 통계정보를 필요로 할때 -&gt; 별도의 통계테이블 생성 (반정규화)</li>
<li>지나치게 많은 JOIN으로 조회 작업이 기술적으로 어려워 질때</li>
</ul>
</li>
<li>대안 검토 (반정규화가 아닌 다른 방법들)<ul>
<li>지나치게 많은 JOIN -&gt; View 생성</li>
<li>대량의 데이터 처리, 부분처리가 유리한 경우 -&gt; 클러스터링 적용 또는 INDEX 조정 (단 DML이 적고 조회 위주의 테이블에만 효과적)</li>
<li>대량의 데이터를 PK 성격에 따라 분리가 가능한 경우라면 -&gt; 파티셔닝 기법 적용해서 물리적으로 분리</li>
<li>Application 로직을 변경하여 성능 개선</li>
</ul>
</li>
<li>반정규화 적용<ul>
<li>테이블 반정규화</li>
<li>속성 반정규화</li>
<li>관계 반정규화</li>
</ul>
</li>
</ol>
<p>###3.2 반정규화 기법</p>
<ol>
<li>테이블 반정규화<ul>
<li>테이블 병합 : 1:1 , 1:M , 슈퍼/서브타입 관계의 테이블들을 병합하여 성능향상</li>
<li>테이블 분할<ul>
<li>수직분할 : 컬럼단위로 테이블을 1:1로 분리하여 트랜잭션을 분산 (트랜잭션의 유형이 선행되어야 함)</li>
<li>수평분할 : row 단위로 테이블을 분리하여 트랜잭션을 분산</li>
</ul>
</li>
<li>테이블 추가<ul>
<li>중복테이블 추가 : 원격 등의 환경에서 서버가 다른 경우 동일한 테이블 중복생성</li>
<li>통계테이블 추가 : 통계값을 미리 계산해 둠</li>
<li>이력테이블 추가 : 마스터 테이블에 존재하는 레코드를 중복으로 이력테이블에 저장</li>
<li>부분테이블 추가 : 자주 이용하는 집중화된 칼럼들을 모아놓은 별도 테이블 생성</li>
</ul>
</li>
</ul>
</li>
<li>컬럼 반정규화<ul>
<li>중복칼럼 추가 : JOIN을 줄이기 위함</li>
<li>파생칼럼 추가 : 미리 계산하여 저장</li>
<li>이력테이블 칼럼추가 : 이력테이블은 대용량이므로 처리속도가 느림. 그 중 자주 사용되는 컬럼을 추가 (최근값, 시작, 종료일자…)</li>
<li>PK에 의한 칼럼추가 : 복합의미 단일PK의 경우, 그 중 특정 값만 자주 사용한다면 일반속성으로 추가</li>
<li>응용시스템 오작동을 위한 칼럼추가 : 잘못 처리되었을 경우를 대비한 백업용 칼럼</li>
</ul>
</li>
<li>관계 반정규화<ul>
<li>중복관계 추가 : 여러 경로를 거쳐야 하는 JOIN을 줄이고자 관계추가</li>
</ul>
</li>
</ol>
<h3 id="반정규화가-더빠른-사례-1-이력테이블의-최근값이-필요한-경우"><a href="#반정규화가-더빠른-사례-1-이력테이블의-최근값이-필요한-경우" class="headerlink" title="반정규화가 더빠른 사례 1 : 이력테이블의 최근값이 필요한 경우"></a>반정규화가 더빠른 사례 1 : 이력테이블의 최근값이 필요한 경우</h3><ul>
<li>고객 Table : 고객번호(PK), 고객명</li>
<li>전화번호 Table : (고객번호(FK), 순번) (PK) , 전화번호</li>
<li>메일주소 Table : (고객번호(FK), 순번) (PK) , 메일주소</li>
</ul>
<p>고객의 전화번호, 메일주소의 변경이력까지 같이 관리해야 할 경우 위와 같이 전화번호, 메일주소를 별도의 Table로 관리하여야 한다.<br>이 경우 특정 고객의 가장 최근 전화번호와 메일주소를 알고 싶다면 아래와 같이 SQL문을 작성해야 한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> A.고객명, D.전화번호, G.메일주소</div><div class="line">  <span class="keyword">FROM</span> 고객 A,</div><div class="line">       (<span class="keyword">SELECT</span> B.고객번호 B.전화번호</div><div class="line">          <span class="keyword">FROM</span> 전화번호 B,</div><div class="line">               (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(순번) <span class="keyword">FROM</span> 전화번호 <span class="keyword">WHERE</span> 고객번호 = :custNo) C</div><div class="line">         <span class="keyword">WHERE</span> B.고객번호 = C.고객번호) D,</div><div class="line">        (<span class="keyword">SELECT</span> E.고객번호 E.메일주소</div><div class="line">          <span class="keyword">FROM</span> 메일주소 E,</div><div class="line">               (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(순번) <span class="keyword">FROM</span> 메일주소 <span class="keyword">WHERE</span> 고객번호 = :custNo) F</div><div class="line">         <span class="keyword">WHERE</span> E.고객번호 = F.고객번호) G,</div><div class="line"> <span class="keyword">WHERE</span> A.고객번호 = D.고객번호</div><div class="line">   <span class="keyword">AND</span> A.고객번호 = G.고객번호</div></pre></td></tr></table></figure>
<p>고객 Table에 최근전화번호, 최근메일주소 칼럼을 추가하여 관리할 경우에는 SQL문을 더 쉽게 작성이 가능하다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> 고객명, 최근전화번호, 최근메일주소</div><div class="line">  <span class="keyword">FROM</span> 고객</div><div class="line"> <span class="keyword">WHERE</span> 고객번호 = :custNo</div></pre></td></tr></table></figure>
<h3 id="반정규화가-더빠른-사례-2-원격서버와-JOIN할-경우"><a href="#반정규화가-더빠른-사례-2-원격서버와-JOIN할-경우" class="headerlink" title="반정규화가 더빠른 사례 2 : 원격서버와 JOIN할 경우"></a>반정규화가 더빠른 사례 2 : 원격서버와 JOIN할 경우</h3><ul>
<li>서버 A<ul>
<li>부서 Table : 부서코드(PK), 부서명</li>
<li>접수 Table : (접수번호, 부서코드(FK))(PK), …</li>
</ul>
</li>
<li>서버 B<ul>
<li>연계 Table : (연계번호, (접수번호, 부서코드)(FK))(PK), 연계상태, 연계일자, …</li>
</ul>
</li>
</ul>
<p>특정 일자 사이의 부서명에 따른 연계상태를 알고 싶은 경우 아래와 같이 SQL을 작성해야 한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> A.부서명, C.연계상태</div><div class="line">  <span class="keyword">FROM</span> 부서 A, 접수 B, 연계 C</div><div class="line"> <span class="keyword">WHERE</span> A.부서코드 = B.부서코드</div><div class="line">   <span class="keyword">AND</span> B.부서코드 = C.부서코드 <span class="keyword">AND</span> B.접수번호 = C.접수번호 <span class="comment">-- 서버A와 서버B의 원격 JOIN이 발생</span></div><div class="line">   <span class="keyword">AND</span> C.연계일자 <span class="keyword">BETWEEN</span> :startdate <span class="keyword">AND</span> :enddate</div></pre></td></tr></table></figure>
<p>원격 JOIN이 일어나서 성능이 저하 될수 있다.<br>부서명 칼럼을 연계 Table에 중복생성하면 원격JOIN을 없앨수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> 부서명, 연계상태</div><div class="line">  <span class="keyword">FROM</span> 연계</div><div class="line"> <span class="keyword">WHERE</span> 연계일자 <span class="keyword">BETWEEN</span> :startdate <span class="keyword">AND</span> :enddate</div></pre></td></tr></table></figure>
<p>하지만, 반정규화를 할 경우 데이터 입력, 수정, 삭제시 성능이 저하 된다는 점을 명심해야 한다.</p>
<h2 id="4절-대량-데이터에-따른-성능"><a href="#4절-대량-데이터에-따른-성능" class="headerlink" title="4절 대량 데이터에 따른 성능"></a>4절 대량 데이터에 따른 성능</h2><h3 id="4-1-칼럼-수가-많은-경우"><a href="#4-1-칼럼-수가-많은-경우" class="headerlink" title="4.1 칼럼 수가 많은 경우"></a>4.1 칼럼 수가 많은 경우</h3><ul>
<li>많은 DISK I/O 및 buffer miss를 발생시킨다. : 레코드 크기가 거져서 블록 당 적제된 레코드 수가 줄어든다.</li>
<li>200개가 넘는 컬럼의 데이터를 한번에 다 조회할 일이 과연 얼마나 될까 ? 화면에 다 표현은 가능한가 ?</li>
</ul>
<p>테이블을 분리시키는 방법이 있다.<br>도서관에서 관리하는 아래와 같은 table을 살펴보자.</p>
<ul>
<li>도서정보 Table : 도서번호(PK), 위치, 수량, 책정보관련 칼럼 10여개, 전자출판관련 칼럼 10여개, 대체제품관련 칼럼 10여개, …</li>
</ul>
<p>위의 경우 전자출판관련 정보나 대체제품관련 정보는 자주 이용되지 않는 항목이라면 별도의 table로 분리하는게 효과적이다.</p>
<ul>
<li>도서정보 Table : 도서번호(PK), 위치, 수량, 책정보관련 칼럼 10여개, …</li>
<li>전자출판 Table : 도서번호(FK, PK), 전자출판관련 칼럼 10여개</li>
<li>대체제품 Table : 도서번호(FK, PK), 대체제품관련 칼럼 10여개</li>
</ul>
<h3 id="4-2-테이블에-데이터가-많은-경우"><a href="#4-2-테이블에-데이터가-많은-경우" class="headerlink" title="4.2 테이블에 데이터가 많은 경우"></a>4.2 테이블에 데이터가 많은 경우</h3><ul>
<li>파티션(partition)을 적용하여 레코드를 분리하면 된다.</li>
<li>파티션 종류<ul>
<li>Range Partition : PK값의 범위별로 분리 (ex. 핸드폰요금 Table의 경우 요금일자를 범위로 하여 매 달마다 파티션 분리)</li>
<li>List Partition : PK의 특정값별로 분리 (ex. 핸드폰대리점 Table의 경우 사업소의 위치지역 별로 파티션 분리)</li>
<li>Hash Partition : PK의 해쉬값으로 분리 (범위 검색이 안되며, 데이터 보관주기를 통한 삭제 등의 관리가 어렵다.)</li>
</ul>
</li>
</ul>
<h3 id="4-3-테이블의-수평-수직-분할-절차"><a href="#4-3-테이블의-수평-수직-분할-절차" class="headerlink" title="4.3 테이블의 수평/수직 분할 절차"></a>4.3 테이블의 수평/수직 분할 절차</h3><ol>
<li>데이터 모델링 완성</li>
<li>데이터베이스 용량산정<ul>
<li>어느 테이블에 데이터가 대용량화 되는지 분석</li>
</ul>
</li>
<li>대량 데이터가 처리되는 테이블의 트랜잭션 처리 패턴 분석<ul>
<li>대용량화 테이블에 컬럼수가 많은가 ?</li>
<li>대용량화 테이블에 레코드수가 많은가 ?</li>
</ul>
</li>
<li>컬럼 단위 집중화, 로우 단위 집중화를 분석하여 테이블 분리 검토<ul>
<li>트랜잭션에서 많은 컬럼들을 항상 다 사용하는가 ? 테이블 분리가 가능한가 ?</li>
<li>트랜잭션에서 특정 범위 단위로 작업을 많이 하는가 ? 해당 범위별로 파티셔닝이 가능한가 ?</li>
</ul>
</li>
</ol>
<h2 id="5절-데이터베이스-구조와-성능"><a href="#5절-데이터베이스-구조와-성능" class="headerlink" title="5절 데이터베이스 구조와 성능"></a>5절 데이터베이스 구조와 성능</h2><h3 id="5-1-슈퍼-서브타입-데이터-모델링"><a href="#5-1-슈퍼-서브타입-데이터-모델링" class="headerlink" title="5.1 슈퍼/서브타입 데이터 모델링"></a>5.1 슈퍼/서브타입 데이터 모델링</h3><ul>
<li>공통부분을 슈퍼타입으로 모델링하고 이를 상속받아서 차이가 있는 속성별로 별도의 서브엔터티로 구분</li>
<li>논리적 데이터 모델링, 분석단계에서 사용됨</li>
<li>물리적으로는 3가지 형태로 구현함 ( One to One Type (1:1) , Plus Type (슈퍼+서브), Single Type (All in One) )</li>
<li>트랜잭션의 유형을 보고 각각의 형태로 구현해야 한다.</li>
</ul>
<h5 id="1-개별로-발생하는-트랜잭션에는-개별로-구현하는게-유리-1-1"><a href="#1-개별로-발생하는-트랜잭션에는-개별로-구현하는게-유리-1-1" class="headerlink" title="1. 개별로 발생하는 트랜잭션에는 개별로 구현하는게 유리 (1:1)"></a>1. 개별로 발생하는 트랜잭션에는 개별로 구현하는게 유리 (1:1)</h5><p>부동산거래 관리 어플리케이션에서 계약 내역에 이해관계자들(매수인,매도인,중개인)이 표시가 되고 상세를 눌렀을 경우 해당 인물에 대한 상세정보가 나오는 경우라면 이해관계자들을 별도의 테이블로 관리하는 것이 좋습니다.</p>
<ul>
<li>계약 Table : 계약번호(PK), … , 중개인번호(FK), 매도인번호(FK), 매수인번호(FK)</li>
<li>이해관계자 Table : 이해관계자번호(FK) , 역할, …</li>
</ul>
<h5 id="2-슈파타입-서브타입에-대해-발생되는-트랜잭션에-대해서는-슈퍼타입-서브타입으로-구분"><a href="#2-슈파타입-서브타입에-대해-발생되는-트랜잭션에-대해서는-슈퍼타입-서브타입으로-구분" class="headerlink" title="2. 슈파타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입으로 구분"></a>2. 슈파타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입으로 구분</h5><p>위 예제에서 중개인이 10만명, 매수인이 500만명, 매도인이 500만명인 경우 (즉, 이해관계자 Table은 1010만건)<br>중개인에 대한 처리가 필요한 경우 최대10만건의 데이터가 필요한데 최대1010만건을 읽을 경우도 발생할 수 있다.<br>이럴때는 슈퍼/서브타입으로 분리하는 것이 좋다.</p>
<ul>
<li>계약 Table : 계약반호(PK), …</li>
<li>이해관계자 Table : 계약번호(PK), 중개인번호(FK), 매도인번호(FK), 매수인번호(FK)</li>
<li>중개인 Table : 중개인번호(PK), …</li>
<li>매도인 Table : 매도인번호(PK), …</li>
<li>매수인 Table : 매수인번호(PK), …</li>
</ul>
<h5 id="3-전체를-하나로-묶어서-트랜잭션이-발생하는-경우"><a href="#3-전체를-하나로-묶어서-트랜잭션이-발생하는-경우" class="headerlink" title="3. 전체를 하나로 묶어서 트랜잭션이 발생하는 경우"></a>3. 전체를 하나로 묶어서 트랜잭션이 발생하는 경우</h5><p>항상 계약관련 사항을 조회하는데, 각 이해관계자들의 정보까지 동시에 화면에 출력이 되는 경우라면 하나의 테이블로 관리하는게 유리하다.</p>
<ul>
<li>계약 Table : 계약번호(PK), … , 중개인 정보들, 매도인 정보들), 매수인 정보들</li>
</ul>
<h3 id="5-2-INDEX-특성을-고려한-PK-FK-설정"><a href="#5-2-INDEX-특성을-고려한-PK-FK-설정" class="headerlink" title="5.2 INDEX 특성을 고려한 PK/FK 설정"></a>5.2 INDEX 특성을 고려한 PK/FK 설정</h3><ul>
<li>PK는 Unique Index를 자동으로 생성한다. 이하 생략 (자세한 내용은 뒤에 나올 Index 부분을 참조)</li>
<li>FK도 Index를 생성한다. FK가 없어도 WHERE 절에서 조건을 적어주는 것으로 SQL 작성이 가능하지만, Full Table Scan이 될 수 있다. 가능하면 일단 FK를 생성하는 것을 기본 정책으로하고, 트랜잭션을 분석하여 거의 활용되지 않을때는 지우는 것이 적절한 방법이다.</li>
</ul>
<h2 id="6절-분산-데이터베이스와-성능"><a href="#6절-분산-데이터베이스와-성능" class="headerlink" title="6절 분산 데이터베이스와 성능"></a>6절 분산 데이터베이스와 성능</h2><h3 id="6-1-분산-데이터베이스의-투명성-transparency-6가지-조건을-만족해야-한다"><a href="#6-1-분산-데이터베이스의-투명성-transparency-6가지-조건을-만족해야-한다" class="headerlink" title="6.1 분산 데이터베이스의 투명성(transparency) : 6가지 조건을 만족해야 한다."></a>6.1 분산 데이터베이스의 투명성(transparency) : 6가지 조건을 만족해야 한다.</h3><ul>
<li>분할 투명성 (단편화) : 하나의 논리적인 relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장</li>
<li>위치 투명성 : 위치정보는 system catalog에 유지되어야 하며, 사용자가 데이터 사용시는 명시할 필요가 없어야 함</li>
<li>지역사상 투명성 : 지역DBMS와 물리적 DB 사이의 Mapping 보장. 지역시스템과 무관한 이름 사용 가능</li>
<li>중복 투명성 : DB 객체가 여러 site에 중복되어 있는지 알 필요가 없음</li>
<li>장애 투명성 : DBMS의 장애와 무관하게 Transaction 일관성 유지</li>
<li>병행 투명성 : 다수 Transaction 수행시 일관성 유지, 분산 2단계 Locking을 이용하여 구현</li>
</ul>
<h3 id="6-2-장단점"><a href="#6-2-장단점" class="headerlink" title="6.2 장단점"></a>6.2 장단점</h3><ul>
<li>장점<ul>
<li>신뢰성, 가용성</li>
<li>빠른 응답 속도와 통신비용 절감</li>
<li>각 지역 사용자의 요구 수용 증대</li>
<li>지역 자치성, 점증적 시스템 용량 확장</li>
</ul>
</li>
<li>단점<ul>
<li>소프트웨어 개발 비용</li>
<li>처리 비용</li>
<li>설계, 관리의 복잡성과 비용</li>
<li>불규칙한 응답속도</li>
<li>통제가 어려움</li>
</ul>
</li>
</ul>
<h3 id="6-3-적용-기법"><a href="#6-3-적용-기법" class="headerlink" title="6.3 적용 기법"></a>6.3 적용 기법</h3><h4 id="1-테이블-분산"><a href="#1-테이블-분산" class="headerlink" title="1. 테이블 분산"></a>1. 테이블 분산</h4><p>테이블을 위치별로 분산 (ex. 자재품목은 본사, 생산제품은 지사)</p>
<h4 id="2-테이블-분할-fragmentation-분산"><a href="#2-테이블-분할-fragmentation-분산" class="headerlink" title="2. 테이블 분할(fragmentation) 분산"></a>2. 테이블 분할(fragmentation) 분산</h4><ul>
<li>수평분할 : 지사별로 각각 다른 PK를 가진 레코드들을 저장. 통합처리시 수행속도가 느려짐</li>
<li>수직분할 : 사이트별로 동일한 PK를 가진 레코드를 저장하나 컬럼을 분리해서 저장 (ex. 본사에는 단가를 저장, 각 지사에는 지사별 재고량을 저장)</li>
</ul>
<h4 id="3-테이블-복제-replication-분산"><a href="#3-테이블-복제-replication-분산" class="headerlink" title="3. 테이블 복제(replication) 분산"></a>3. 테이블 복제(replication) 분산</h4><p>동일한 테이블을 여러 곳에서 동시에 생성하여 관리</p>
<ul>
<li>부분복제(segment replication) : 통합본은 본사에 있고, 각 지사별로 수평분할 형태. 데이터 입력은 지사에서 하고, 본사에서 지사 데이터를 이용하여 통합</li>
<li>광역복제 (broadcast replication) : 본사의 데이터를 지사에서도 동일하게 가지고 있음. 본사를 통해서 입력을하고, 주기별로 해당 데이터를 지사로 복사</li>
</ul>
<h4 id="4-테이블-요약-summarization-분산"><a href="#4-테이블-요약-summarization-분산" class="headerlink" title="4. 테이블 요약(summarization) 분산"></a>4. 테이블 요약(summarization) 분산</h4><ul>
<li>분석요약 (rollup replication) : 지사별로 존재하는 요약정보를 본사에서 통합하여 지사로 전송 (모든 지사가 동일 정보)</li>
<li>통합요약 (consolidation replication) : 지사별로 존재하는 다른 정보를 본사에서 통합하여 관리 (모든 지사가 다른 정보)</li>
</ul>
<h3 id="6-4-분산-데이터베이스를-통한-성능-향상-사례"><a href="#6-4-분산-데이터베이스를-통한-성능-향상-사례" class="headerlink" title="6.4 분산 데이터베이스를 통한 성능 향상 사례"></a>6.4 분산 데이터베이스를 통한 성능 향상 사례</h3><p>인사팀DB에만 직원 정보가 있는 경우 업무DB에서는 항상 인사팀DB를 JOIN해야함.<br>직원 정보를 각 업무DB로 복사를 하면 성능이 향상 됨</p>
<ul>
<li>성능이 중요한 사이트에 적용</li>
<li>master 성격의 table을 분산하면 성능이 향상됨</li>
<li>실시간 동기화가 요구되지 않으면 유리. 특정시간에 batch로 동기화</li>
<li>특정 서버에 부하가 집중될떄 분산시킬수 있음</li>
<li>백업사이트를 구성할 때 분산기능을 적용할 수 있음</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/20/01.02.modeling_performance/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/01/20/01.02.modeling_performance/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/20/01.01.modeling/">
                            SQLP 1-1 데이터 모델링
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-20T00:00:00+09:00">
	
		    Jan 20, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="1과목-데이터-모델링의-이해"><a href="#1과목-데이터-모델링의-이해" class="headerlink" title="1과목 데이터 모델링의 이해"></a>1과목 데이터 모델링의 이해</h2><ul>
<li>10문제</li>
<li>외우기 보다는 반복적으로 읽어서 전반적인 내용을 이해하는 수준에서 마무리 하는것을 목표로 잡아야 겠습니다.</li>
</ul>
<h2 id="제-1장-데이터-모델링의-이해"><a href="#제-1장-데이터-모델링의-이해" class="headerlink" title="제 1장 데이터 모델링의 이해"></a>제 1장 데이터 모델링의 이해</h2><h3 id="1절-데이터-모델의-이해"><a href="#1절-데이터-모델의-이해" class="headerlink" title="1절 데이터 모델의 이해"></a>1절 데이터 모델의 이해</h3><h4 id="모델링의-특징"><a href="#모델링의-특징" class="headerlink" title="모델링의 특징"></a>모델링의 특징</h4><ul>
<li><code>추상화</code> : 일정한 형식에 맞추어 표현</li>
<li><code>단순화</code> : 약속된 규약에 의해 제한</li>
<li><code>명확화</code> : 애매모호함을 제거 정확하게 기술</li>
</ul>
<h4 id="모델링의-3가지-관점"><a href="#모델링의-3가지-관점" class="headerlink" title="모델링의 3가지 관점"></a>모델링의 3가지 관점</h4><ul>
<li>데이터 관점 (what) : 업무가 어떤 데이터와 관려이 있는지, 데이터간의 관계가 무엇인지</li>
<li>프로세스 관점 (how) : 업무가 실제하고 있는 일이 무엇인지, 무엇을 해야 하는지</li>
<li>데이터와 프로세스의 상관관점 (interaction) : 업무가 처리됨에 따라 데이터는 어떻게 영향을 받고 있는지</li>
</ul>
<h4 id="데이터-모델링이란…"><a href="#데이터-모델링이란…" class="headerlink" title="데이터 모델링이란…"></a>데이터 모델링이란…</h4><ul>
<li>정보시스템을 구축하기 위한 데이터관점의 업무 분석 기법</li>
<li>현실세계의 데이터(what)에 대해 약속된 표기법에 의해 표현하는 과정</li>
<li>데이터베이스를 구축하기 위한 분석/설계의 과정</li>
</ul>
<h4 id="데이터-모델의-중요성"><a href="#데이터-모델의-중요성" class="headerlink" title="데이터 모델의 중요성"></a>데이터 모델의 중요성</h4><ul>
<li>파급효과(leverage) : 데이터 모델이 잘못되어서 나중에 변경될때에는 전체 시스템에 큰 변경 사항이 발생함</li>
<li>복잡한 정보 요구사항의 간결한 표현(conciseness) : 요구사항을 정확하고 간결하게 표현. 요구사항 파악시 데이터 모델을 리뷰하는 것이 더 빠름.</li>
<li>데이터 품질(data quality) : 기간이 오래되고 쌓인 데이터를 활용하려면 품질이 중요. (정확성, 중복데이터 등…). 품질이 안좋으면 활용하지 못한 쓰레기가 될수 있음</li>
</ul>
<h4 id="데이터-모델링의-유의점"><a href="#데이터-모델링의-유의점" class="headerlink" title="데이터 모델링의 유의점"></a>데이터 모델링의 유의점</h4><ul>
<li><code>중복(duplication)</code> : 여러 곳에 같은 정보 저장하지 않도록</li>
<li><code>비유연성(inflexibility)</code> : 데이터 정의와 사용 프로세스를 분리. 각각의 작은 변화가 서로에게 영향을 미치지 않도록</li>
<li><code>비일관성(inconsistency)</code> : 서로 영향을 미치는 데이터간 상호 연관 관계에 대한 명확한 정의가 필요 (ex. 납부이력과 신용상태)</li>
</ul>
<h4 id="데이터-모델링의-3단계-진행-추상화-수준에-따라"><a href="#데이터-모델링의-3단계-진행-추상화-수준에-따라" class="headerlink" title="데이터 모델링의 3단계 진행 (추상화 수준에 따라)"></a>데이터 모델링의 3단계 진행 (추상화 수준에 따라)</h4><ul>
<li><code>개념적 데이터 모델(conceptual)</code><ul>
<li>추상화 수준이 높고 업무중신적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링, EA수립시 많이 이용</li>
<li>엔티티 - 관계 다이어그램 생성</li>
<li>전사적 데이터 모델링 (enterprise)</li>
<li>중요한 2가지 기능<ol>
<li>사용자와 시스템 개발자가 데이터 요구 사항을 발견하는 것을 지원</li>
<li>현 시스템이 어떻게 변형되어야 하는지를 이해하는데 유용</li>
</ol>
</li>
</ul>
</li>
<li><code>논리적 데이터 모델 (logical)</code><ul>
<li>시스템으로 구축하고자 하는 업무에 대한 Key, 속성, 관계 등을 정확하게 표현, 재사용성이 높음</li>
<li>식별자 확정, 정규화, M:M 관계 해소, 참조 무결성 규칙 정의 등</li>
<li>데이터베이스 설계 프로세스의 input으로 비즈니스 정보의 논리적인 구조와 규칙을 명확하게 표현하는 기법 또는 과정</li>
</ul>
</li>
<li><code>물리적 데이터 모델 (physical)</code><ul>
<li>실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등 무리적인 성격을 고려하여 설계</li>
<li>물리적 스키마 : 데이터가 물리적으로 컴퓨터에 어떻게 저장될 것인가에 대한 정의</li>
<li>테이블, 칼럼 등의 저장구조와 저장 장치, 접근 방법 등</li>
</ul>
</li>
</ul>
<h4 id="데이터-독립성의-필요성-lt-gt-데이터-종속성"><a href="#데이터-독립성의-필요성-lt-gt-데이터-종속성" class="headerlink" title="데이터 독립성의 필요성 &lt;-&gt; 데이터 종속성"></a>데이터 독립성의 필요성 &lt;-&gt; 데이터 종속성</h4><ul>
<li>유지보수 비용증가</li>
<li>데이터 중복성 증가</li>
<li>데이터복잡도 증가</li>
<li>요구사항 대응 저하</li>
</ul>
<h4 id="데이터-독립성-확보시-효과"><a href="#데이터-독립성-확보시-효과" class="headerlink" title="데이터 독립성 확보시 효과"></a>데이터 독립성 확보시 효과</h4><ul>
<li>각 View의 독립성을 유지하고 계층별 View에 영향을 주지 않고 변경 가능</li>
<li>단계별 Schema에 따라 DDL과 DML가 다름을 제공</li>
</ul>
<h4 id="데이터베이스-3단계-구조"><a href="#데이터베이스-3단계-구조" class="headerlink" title="데이터베이스 3단계 구조"></a>데이터베이스 3단계 구조</h4><ol>
<li>외부단계 (External Schema) : 사용자 관점<ul>
<li>DB의 개개 user나 application이 접근하는 DB 정의</li>
</ul>
</li>
<li>개념적단계 (Conceptual Schema) : 통합 관점<ul>
<li>사용자가 처리하는 데이터 유형의 공통적인 사항을 처리하는 통합된 뷰를 스키마 구조로 디자인한 형태</li>
<li>모든 사용자 관점을 통합한 조직 전체의 DB</li>
<li>모든 user와 application이 필요로하는 데이터를 통합한 조직 전체의 DB를 기술</li>
<li>DB에 저장되는 데이터와 그들간의 관계를 표현하는 스키마</li>
</ul>
</li>
<li>내부적단계 (Internal Schema) : 물리적 저장구조</li>
</ol>
<h4 id="논리적-물리직-독립성"><a href="#논리적-물리직-독립성" class="headerlink" title="논리적, 물리직 독립성"></a>논리적, 물리직 독립성</h4><table>
<thead>
<tr>
<th>독립성</th>
<th>내용</th>
<th>특징</th>
</tr>
</thead>
<tbody>
<tr>
<td>논리적 독립성</td>
<td>- 개념 스키마가 변경되어도 외부 스키마에는 영향 없음  - 논리적 구조가 변경되어도 Application에는 영향 없음</td>
<td>- 사용자 특성에 맞는 변경가능  - 통합 구조 변경가능</td>
</tr>
<tr>
<td>물리적 독립성</td>
<td>- 내부스키마가 변경되어도 외부/개념 스키마에 영향 없음  - 저장장치의 구조변경은 Application과 개념스키마에 영향 없음</td>
<td>- 물리구조, 개념구조를 서로 영향없이 변경가능</td>
</tr>
</tbody>
</table>
<h4 id="사상-Mapping"><a href="#사상-Mapping" class="headerlink" title="사상 (Mapping)"></a>사상 (Mapping)</h4><ul>
<li>논리적 mapping (외부적 &lt;-&gt; 개념적) : 외부적 뷰와 개념적 뷰의 상호 관련성 정의<ul>
<li>사용자가 접근하는 뷰의 필드는 다른 타입을 가질 수 있으나, 개념적 뷰의 필드 타입은 변화가 없음</li>
</ul>
</li>
<li>물리적 mapping (개념적 &lt;-&gt; 내부적) : 개념적 뷰와 데이터베이스의 상호 관련성 정의<ul>
<li>데이터베이스 구조가 바뀔 경우 물리적 mapping이 바뀌어야 함. 개념적 스키마는 안바뀌도록 해야 함</li>
</ul>
</li>
</ul>
<h4 id="데이터-모델링의-3가지-개념"><a href="#데이터-모델링의-3가지-개념" class="headerlink" title="데이터 모델링의 3가지 개념"></a>데이터 모델링의 3가지 개념</h4><ul>
<li>업무가 관여하는 어떤 것 : things (table)</li>
<li>어떤 것이 가지는 성격 : attributes (column)</li>
<li>업무가 관여하는 어떤 것 간의 관계 : relationships</li>
</ul>
<h4 id="좋은-데이터-모델의-요소"><a href="#좋은-데이터-모델의-요소" class="headerlink" title="좋은 데이터 모델의 요소"></a>좋은 데이터 모델의 요소</h4><ul>
<li>완전성 (completeness) : 업무에 필요한 모든 데이터가 데이터 모델에 정의되어 있어야 함</li>
<li>중복배제 (non-redundancy) : 동일한 사실은 반드시 한 번만 기록 (ex. 나이, 생년월일 은 중복)</li>
<li>업무규칙 (business rules) : 수많은 업무규칙을 데이터 모델에 표현</li>
<li>데이터 재사용 (data reusability) : 데이터 통합성, 독립성을 충분히 고려</li>
<li>의사소통 (communication) :  데이터 모델은 업무를 데이터 관점에서 분석하고 설계하여 나오는 최종 산출물. 모든 업무 규칙을 엔티티, 서브타입, 속성, 관계 등의 형태로 최대한 자세하게 표현. 업무관련자들은 이를 업무 규칙과 동일하게 받아들이고 정보시스템 활용</li>
<li>통합성 (integration) : 각 부서별 따로 존재했던 데이터 중 중복적인 성격들(마스터 테이블)을 통합 관리</li>
</ul>
<h3 id="2절-엔터티-entity"><a href="#2절-엔터티-entity" class="headerlink" title="2절 엔터티 (entity)"></a>2절 엔터티 (entity)</h3><h4 id="2-1-엔터티의-특성"><a href="#2-1-엔터티의-특성" class="headerlink" title="2.1 엔터티의 특성"></a>2.1 엔터티의 특성</h4><ul>
<li>업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것(thing)</li>
<li>반드시 필요한 정보</li>
<li>unique하게 식별이 가능</li>
<li>반드시 속성(attribute)를 가져야 함</li>
<li>업무 프로세스에서 사용되어야 함</li>
<li>최소 한 개 이상의 다른 엔터티와의 관계 필수</li>
<li>영속적으로 존재하는 인스턴스(instance)의 집합</li>
</ul>
<h4 id="2-2-엔터티의-분류"><a href="#2-2-엔터티의-분류" class="headerlink" title="2.2 엔터티의 분류"></a>2.2 엔터티의 분류</h4><ul>
<li>유무형에 따른 분류<ul>
<li>유형엔터티 : 사원, 물품</li>
<li>개념엔터티 : 부서, 보험상품</li>
<li>사건엔터티 : 주문, 청구</li>
</ul>
</li>
<li>발생시점에 따른 분류<ul>
<li>기본 엔터티 (fundamental entity, key entity) : 독립적 생성 가능, 다른 엔터티의 주어 역할 (ex. 사원 부서, 고객, 상품)</li>
<li>중심 엔터티 (main entity) : 기본 엔터티로 부터 발생하고, 업무의 중심 역할 (ex. 계약, 주문, 매출)</li>
<li>행위 엔터티 (active entity) :  2개 이상의 부모로 부터 발생하고 자주 바뀌거나 데이터량이 증가되는 성격을 가짐 (ex. 주문목록, 사원변경이력)</li>
</ul>
</li>
</ul>
<h4 id="2-3-인스턴스-instance"><a href="#2-3-인스턴스-instance" class="headerlink" title="2.3 인스턴스 (instance)"></a>2.3 인스턴스 (instance)</h4><ul>
<li>엔터티로부터 생성된 하나의 개체</li>
<li>entity가 class하면 instance 는 object</li>
</ul>
<h3 id="3절-속성-attribute"><a href="#3절-속성-attribute" class="headerlink" title="3절 속성 (attribute)"></a>3절 속성 (attribute)</h3><h4 id="3-1-속성의-특징"><a href="#3-1-속성의-특징" class="headerlink" title="3.1 속성의 특징"></a>3.1 속성의 특징</h4><ul>
<li>의미상 더 이상 분리되지 않음 : 2개 이상의 값을 가질 경우 분리해야 함</li>
<li>엔터티를 설명하고 인스턴스의 구성요소</li>
<li>정규화 규칙에 의거해 주식별자에 함수적 종속성을 가져야 함</li>
<li>업무상 필요로 해야한다.</li>
</ul>
<h4 id="3-2-속성의-분류"><a href="#3-2-속성의-분류" class="headerlink" title="3.2 속성의 분류"></a>3.2 속성의 분류</h4><ul>
<li>특성에 의한 분류<ul>
<li>기본속성 (basic attribute) : 업무로부터 추출한 모든 속성</li>
<li>설계속성 (designed attribute) : 업무를 규칙화하기 위해 새로 만들거나 변형한 속성 (ex. 일련번호)</li>
<li>파생속성 (derived attribute) : 다른 속성에 영향을 받는 속성. 주로 계산 값들. 되도록이면 적게 정의하는게 좋음</li>
</ul>
</li>
<li>구성방식에 따른 분류<ul>
<li>PK (primary key), FK (foreign key), 일반속성 등…</li>
</ul>
</li>
</ul>
<h4 id="3-3-도메인-domain"><a href="#3-3-도메인-domain" class="headerlink" title="3.3 도메인 (domain)"></a>3.3 도메인 (domain)</h4><ul>
<li>속성이 가질 수 있는 값의 범위</li>
</ul>
<h3 id="4절-관계-relationship"><a href="#4절-관계-relationship" class="headerlink" title="4절 관계 (relationship)"></a>4절 관계 (relationship)</h3><ul>
<li>인스턴스 사이의 연관성</li>
</ul>
<h4 id="4-1-관계의-분류"><a href="#4-1-관계의-분류" class="headerlink" title="4.1 관계의 분류"></a>4.1 관계의 분류</h4><ul>
<li>존재에 의한 관계 : 부서 (1) : 사원 (M)</li>
<li>행위에 의한 관계 : 고객 (1) : 주문 (M)</li>
</ul>
<h4 id="4-2-관계-차수-degree-cardinality"><a href="#4-2-관계-차수-degree-cardinality" class="headerlink" title="4.2 관계 차수(degree, cardinality)"></a>4.2 관계 차수(degree, cardinality)</h4><ul>
<li>1 : 1 관계 : 사원 - 병역사항</li>
<li>1 : M 관계 : 부서 (1) : 사원 (M)</li>
<li>M : M 관계 : 주문 (M) : 제품 (M)</li>
</ul>
<h3 id="5절-식별자-identifiers"><a href="#5절-식별자-identifiers" class="headerlink" title="5절 식별자 (identifiers)"></a>5절 식별자 (identifiers)</h3><ul>
<li>entity 내에서 instance의 구분자</li>
</ul>
<h4 id="5-1-식별자의-특징"><a href="#5-1-식별자의-특징" class="headerlink" title="5.1 식별자의 특징"></a>5.1 식별자의 특징</h4><ul>
<li>유일성 : 주식별자에 의해 엔터티 내의 모든 인스턴스가 유일하게 부분</li>
<li>최소성 : 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수</li>
<li>불변성 : 자주 변하지 않는 값이어야 함</li>
<li>존재성 : 반드시 값이 있어야함 (NOT NULL)</li>
</ul>
<h4 id="5-2-주식별자-도출기준"><a href="#5-2-주식별자-도출기준" class="headerlink" title="5.2 주식별자 도출기준"></a>5.2 주식별자 도출기준</h4><ul>
<li>업무에서 자주 이용되는 속성 : PK로 등록 = index 생성</li>
<li>명칭, 내역등과 같은 이름은 피해야 함 : 다른 적당한 구분자가 존재하지 않으면 일변번호 같은 것을 새로 생성</li>
<li>속성수가 많아지지 않도록 함 : WHERE 조건이 복잡해짐. 새로운 인조식별자를 생성하는게 편함</li>
</ul>
<h4 id="5-3-외부식별자-foreign-identifier-와의-관계"><a href="#5-3-외부식별자-foreign-identifier-와의-관계" class="headerlink" title="5.3 외부식별자 (foreign identifier)와의 관계"></a>5.3 외부식별자 (foreign identifier)와의 관계</h4><h5 id="5-3-1-식별관계-비식별관계"><a href="#5-3-1-식별관계-비식별관계" class="headerlink" title="5.3.1 식별관계, 비식별관계"></a>5.3.1 식별관계, 비식별관계</h5><ul>
<li>식별자관계 : 부모의 식별자를 자식의 식별자로 사용<ul>
<li>FK가 NOT NULL이어야 함</li>
<li>종속관계 : <code>1 : 1</code> 또는 <code>1 : M</code></li>
<li>상속받은 주식별자속성을 타 엔터티에 이전 필요</li>
</ul>
</li>
<li>비식별관계 : 부모없는 자식이 생성될 수 있음<ul>
<li>자식의 일반 속성에 생성 됨 : NULL 일 수 있음</li>
<li>부모와 자식의 생명주기(life cycle)을 달리할 경우 유용함</li>
<li>자식 엔터티의 주 식별자로 사용되어도 되지만, 따로 생성하는게 더 유리하다고 판단 될 경우</li>
</ul>
</li>
</ul>
<h5 id="5-4-2-관계에-대한-주의사항"><a href="#5-4-2-관계에-대한-주의사항" class="headerlink" title="5.4.2 관계에 대한 주의사항"></a>5.4.2 관계에 대한 주의사항</h5><ul>
<li>식별관계 / 비식별관계 결정<ul>
<li>어떻게 관계를 짓는냐에 따라 속성의 정의 및 SQL 작성시에 달라지므로 SQL 전략에 맞게 결정해야 한다.</li>
</ul>
</li>
<li>식별관계로만 설정할 경우 문제점<ul>
<li>PK 속성의 수가 데이터 모델 흐름에 따라 계속 증가하게 된다. : 자식의 PK 속성수는 부모의 PK 속성수 + n</li>
<li>JOIN 할때 적어줘야 할 WHERE절의 조건 수가 늘어난다.</li>
</ul>
</li>
<li>비식별관계로만 설정할 경우 문제점<ul>
<li>자식 엔터티의 데이터를 조회할때 부모 엔터티에 WHERE 조건을 추가해 주어야 할 경우가 발생한다.</li>
</ul>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/20/01.01.modeling/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/01/20/01.01.modeling/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        <li class="pagination-prev">
            
                <a class="btn btn--default btn--small" href="/categories/Database/page/2/">
            
                <i class="fa fa-angle-left text-base icon-mr"></i>
                    <span>NEWER POSTS</span>
            </a>
        </li>
        
        
        <li class="pagination-number">page 3 of 3</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 Yun Seok-joon. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">Yun Seok-joon</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Seoul, South Korea
            </div>
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">no post found</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2015/11/10/Devops.Jenkins/">
                            <h3 class="media-heading">Install Jenkins</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Nov 10, 2015
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/20/01.01.modeling/">
                            <h3 class="media-heading">SQLP 1-1 데이터 모델링</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 20, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/20/01.02.modeling_performance/">
                            <h3 class="media-heading">SQLP 1-2 데이터 모델과 성능</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 20, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/21/02.01.sql.basic/">
                            <h3 class="media-heading">SQLP 2-1 SQL 기본</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 21, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/23/02.02.sql.adv/">
                            <h3 class="media-heading">SQLP 2-2-1 SET, Hierarchical Query, Sub-query</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 23, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/25/02.03.group/">
                            <h3 class="media-heading">SQLP 2-2-2 GROUP function</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 25, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/25/02.04.window/">
                            <h3 class="media-heading">SQLP 2-2-3 Window function</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 25, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/26/02.05.dcl/">
                            <h3 class="media-heading">SQLP 2-2-4 DCL</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 26, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/26/02.06.plsql/">
                            <h3 class="media-heading">SQLP 2-2-5 PL/SQL</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 26, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/27/02.07.optimizer/">
                            <h3 class="media-heading">SQLP 2-3 Optimizing SQL</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 27, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="no post found"
                data-message-one="1 post found"
                data-message-other="{n} posts found">
                59 posts found
            </p>
        </div>
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/jquery.fancybox-thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    </body>
</html>
