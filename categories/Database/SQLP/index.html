
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Dev Star SJ">
    <title>Category: SQLP - Dev Star SJ</title>
    <meta name="author" content="Yun Seok-joon">
    
    
    
    <meta name="description" content="Sharing the common developer&apos;s try-on">
<meta property="og:type" content="blog">
<meta property="og:title" content="Dev Star SJ">
<meta property="og:url" content="http://DevStarSJ.github.io/categories/Database/SQLP/index.html">
<meta property="og:site_name" content="Dev Star SJ">
<meta property="og:description" content="Sharing the common developer&apos;s try-on">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dev Star SJ">
<meta name="twitter:description" content="Sharing the common developer&apos;s try-on">
    
    
        
    
    
        <meta property="og:image" content="http://DevStarSJ.github.io/assets/images/sjyun.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-eoqrdyagg8lofwhg4unnxmhyxznbkxgjkodxgdtletmltlwb2wgngdrld76m.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Dev Star SJ</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/sjyun.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/sjyun.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Yun Seok-joon</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://DevLunaSJ.github.com/" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.facebook.com/seokjoon.yun.9" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-facebook"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://plus.google.com/u/1/108379332089647292574" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-google-plus"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/in/sjyun/" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-linkedin"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:seokjoon.yun@gmail.com" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/13/05.01.sql/">
                            SQLP etc-1 외워야 할 SQL 문법
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-02-13T02:00:00+09:00">
	
		    Feb 13, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="핵심정리"><a href="#핵심정리" class="headerlink" title="핵심정리"></a>핵심정리</h1><h2 id="5-외워야-할-SQL-문법"><a href="#5-외워야-할-SQL-문법" class="headerlink" title="5. 외워야 할 SQL 문법"></a>5. 외워야 할 SQL 문법</h2><h3 id="1-Hirarchical-SQL-계층형-질의"><a href="#1-Hirarchical-SQL-계층형-질의" class="headerlink" title="1. Hirarchical SQL (계층형 질의)"></a>1. Hirarchical SQL (계층형 질의)</h3><p>root에서 시작해서 주어진 조건에 맞게 전개하는 방식으로 Query</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ...</div><div class="line">  <span class="keyword">FROM</span> table_name</div><div class="line"> <span class="keyword">WHERE</span> ...</div><div class="line"> <span class="keyword">START</span> <span class="keyword">WITH</span> (root condition)</div><div class="line"> <span class="keyword">CONNECT</span> <span class="keyword">BY</span> [<span class="keyword">NOCYCLE</span>] <span class="keyword">PRIOR</span> (root <span class="keyword">id</span>) = (<span class="keyword">child</span><span class="string">'s root id)</span></div><div class="line"> [ORDER SIBLINGS BY (columns...)]</div></pre></td></tr></table></figure>
<ul>
<li><p>가상 Coluns</p>
<ul>
<li>LEVEL : root = 1, leaf 방향으로 1씩 증가</li>
<li>CONNECT_BY_ISLEAF : leaf면 1 (자식이 있으면 0, 없으면 1)</li>
<li>CONNECT_BY_ISCYCLE : leaf가 아니면서 조상 중에 자기자신이 있으면 1 (cycle에 속해 있으면 1, 아니면 0)</li>
</ul>
</li>
<li><p>전용 함수</p>
<ul>
<li>SYS_CONNECT_BY_PATH(column, separator) : root부터 현재까지 경로</li>
<li>CONNECT_BY_ROOT column : root 데이터의 컬럼을 표시</li>
</ul>
</li>
<li><p>Oracle SCOTT.EMP Table에서 MANAGER = NULL부터 전개</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> EMP.*,</div><div class="line">       <span class="keyword">LPAD</span>(<span class="string">' '</span>,<span class="keyword">LEVEL</span> - <span class="number">1</span>) || <span class="keyword">LEVEL</span> <span class="string">"LEVEL"</span>,</div><div class="line">       <span class="keyword">CONNECT_BY_ISLEAF</span> ISLEAF,</div><div class="line">       <span class="keyword">SUBSTR</span>(SYS_CONNECT_BY_PATH(ENAME,<span class="string">'-'</span>),<span class="number">2</span>) <span class="keyword">PATH</span>,</div><div class="line">       <span class="keyword">CONNECT_BY_ROOT</span> ENAME ROOT</div><div class="line">  <span class="keyword">FROM</span> EMP</div><div class="line"> <span class="keyword">START</span> <span class="keyword">WITH</span> MGR <span class="keyword">IS</span> <span class="literal">NULL</span></div><div class="line"> <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">PRIOR</span> EMPNO = MGR</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">SIBLINGS</span> <span class="keyword">BY</span> HIREDATE;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/05.01.sql.01.png?raw=true"></p>
<ul>
<li>반대로 MILLER(7934)로 부터 직속상관들을 전개<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> EMP.*,</div><div class="line">       <span class="keyword">LPAD</span>(<span class="string">' '</span>, <span class="keyword">LEVEL</span> - <span class="number">1</span>) || <span class="keyword">LEVEL</span> <span class="string">"LEVEL"</span>,</div><div class="line">       <span class="keyword">SUBSTR</span>(SYS_CONNECT_BY_PATH(ENAME, <span class="string">'-'</span>),<span class="number">2</span>) NAME_PATH,</div><div class="line">       <span class="keyword">SUBSTR</span>(SYS_CONNECT_BY_PATH(JOB,<span class="string">'-'</span>),<span class="number">2</span>) JOB_PATH</div><div class="line">  <span class="keyword">FROM</span> EMP</div><div class="line"> <span class="keyword">START</span> <span class="keyword">WITH</span> EMPNO = <span class="number">7934</span></div><div class="line"> <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">PRIOR</span> MGR = EMPNO</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/05.01.sql.01.png?raw=true"></p>
<h3 id="2-ROLLUP-Group-Function"><a href="#2-ROLLUP-Group-Function" class="headerlink" title="2. ROLLUP (Group Function)"></a>2. ROLLUP (Group Function)</h3><p>각 단계별 소계를 계산</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ...</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> (소계를 적용하지 않을 column...), <span class="keyword">ROLLUP</span> (소계 적용할 columns...)</div><div class="line"><span class="comment">-- ROLLUP 안에서 column들을 괄호로 묶을시 계층구조가 아닌 같은 level로 소계를 구분</span></div></pre></td></tr></table></figure>
<ul>
<li>GROUPING(column) 함수 : 해당 소계에 속한 column에 대해서 1을 출력</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DECODE</span>(<span class="keyword">GROUPING</span>(DNAME), <span class="number">1</span>,<span class="string">'Total DEPT'</span>, DNAME) DNAME,</div><div class="line">       <span class="keyword">DECODE</span>(<span class="keyword">GROUPING</span>(JOB), <span class="number">1</span>,<span class="string">'Toal JOB'</span>, JOB) JOB,</div><div class="line">       <span class="keyword">COUNT</span>(*) TOTAL_EMP,</div><div class="line">       <span class="keyword">SUM</span>(SAL) TOTAL_SAL</div><div class="line">  <span class="keyword">FROM</span> EMP e, DEPT d</div><div class="line"> <span class="keyword">WHERE</span> e.DEPTNO = d.DEPTNO</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (DNAME, JOB);</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.03.group.05.png?raw=true"></p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/02/13/05.01.sql/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/11/04.04.partition/">
                            SQLP 3-5-4 Partition, Batch Job
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-02-11T02:00:00+09:00">
	
		    Feb 11, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="3과목-SQL-고급-활용-및-Tuning"><a href="#3과목-SQL-고급-활용-및-Tuning" class="headerlink" title="3과목 SQL 고급 활용 및 Tuning"></a>3과목 SQL 고급 활용 및 Tuning</h1><h2 id="5장-고급-SQL-Tuning"><a href="#5장-고급-SQL-Tuning" class="headerlink" title="5장 고급 SQL Tuning"></a>5장 고급 SQL Tuning</h2><h3 id="5-4-Partition-활용"><a href="#5-4-Partition-활용" class="headerlink" title="5.4 Partition 활용"></a>5.4 Partition 활용</h3><ul>
<li><p>Partitioning 이란 ?</p>
<ul>
<li>Table, Index를 Partition 단위로 나누어 저장</li>
<li>Partition Key에 따라 물리적으로 별도의 Segment에 저장</li>
</ul>
</li>
<li><p>Partition 장점</p>
<ul>
<li>관리적 측면 : Partition 단위 백업, 추가, 삭제, 변경이 편리</li>
<li>성능적 측면 : Partition 단위로 Query, DML이 수행되어서 Transaction 경합 및 부하 분산</li>
</ul>
</li>
</ul>
<h4 id="5-4-1-Partition-유형"><a href="#5-4-1-Partition-유형" class="headerlink" title="5.4.1 Partition 유형"></a>5.4.1 Partition 유형</h4><h5 id="1-Range-Partition"><a href="#1-Range-Partition" class="headerlink" title="1. Range Partition"></a>1. Range Partition</h5><ul>
<li>Partition Key 값의 범위(Range)로 분할</li>
<li>가장 일반적인 형태</li>
</ul>
<blockquote>
<p>e.g. 날짜 칼럼 기준으로 판매데이터를 월별로 분할</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 주문</div><div class="line">(</div><div class="line">    ...</div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(주문일자)</div><div class="line">(</div><div class="line">    <span class="keyword">PARTITION</span> P2009_Q1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="string">'20090401'</span>),</div><div class="line">    <span class="keyword">PARTITION</span> P2009_Q2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="string">'20090701'</span>),</div><div class="line">    ...</div><div class="line">    <span class="keyword">PARTITION</span> P9999_MX <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (MAXVALUE)</div><div class="line">)<span class="string">'</span></div></pre></td></tr></table></figure>
<h5 id="2-Hash-Partition"><a href="#2-Hash-Partition" class="headerlink" title="2. Hash Partition"></a>2. Hash Partition</h5><ul>
<li>Partition Key 값의 Hash 함수를 적용하여 그 값으로 Mapping</li>
<li>고르게 분산되는 대신 각 Row의 저장위치 예측이 불가</li>
<li>병렬처리 시 성능효과 극대화</li>
<li>DML 경합 분산에 효과적</li>
</ul>
<blockquote>
<p>e.g. 고객번호, 주문일련번호</p>
</blockquote>
<h5 id="3-List-Partition"><a href="#3-List-Partition" class="headerlink" title="3. List Partition"></a>3. List Partition</h5><ul>
<li>불연속적인 값의 목록을 각 Partition에 지정</li>
</ul>
<blockquote>
<p>e.g. 판매 데이터를 지역별로 분할</p>
</blockquote>
<h5 id="4-Composite-Partition"><a href="#4-Composite-Partition" class="headerlink" title="4. Composite Partition"></a>4. Composite Partition</h5><ul>
<li>2개 이상의 Partition 구성 (단, 맨 처음에 Hash가 올 순 없음)</li>
<li>Range나 List Partition에 Range, Hash, List를 Sub-partition으로 구성</li>
</ul>
<p>e.g. Range + Hash로 구성<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 주문</div><div class="line">(</div><div class="line">    ...</div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(주문일자)</div><div class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>(고객<span class="keyword">ID</span>) <span class="keyword">SUBPARTITIONS</span> <span class="number">8</span></div><div class="line">(</div><div class="line">    <span class="keyword">PARTITION</span> P2009_Q1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="string">'20090401'</span>),</div><div class="line">    <span class="keyword">PARTITION</span> P2009_Q2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="string">'20090701'</span>),</div><div class="line">    ...</div><div class="line">    <span class="keyword">PARTITION</span> P9999_MX <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (MAXVALUE) </div><div class="line">);</div></pre></td></tr></table></figure></p>
<h4 id="5-4-2-Partition-Pruning"><a href="#5-4-2-Partition-Pruning" class="headerlink" title="5.4.2 Partition Pruning"></a>5.4.2 Partition Pruning</h4><ul>
<li>Optimizer가 SQL의 대상 Table과 조건을 분석하여 불필요한 Partition을액세스 대상에서 제외하는 기능</li>
</ul>
<ol>
<li>Static Partition Pruning<ul>
<li>액세스할 Partition을 Compile-Time에 미리 결정</li>
<li>상수 조건으로 조회할 경우 작동</li>
</ul>
</li>
<li>Dynamic Partition Pruning<ul>
<li>액세스할 Partition을 Run-Time에 결정</li>
<li>Bind Variable로 조회하는 경우</li>
<li>NL Join시 Inner Table이 Join 칼럼 기준으로 Partition 되 있는 경우</li>
</ul>
</li>
</ol>
<h4 id="5-4-3-Index-Partitioning"><a href="#5-4-3-Index-Partitioning" class="headerlink" title="5.4.3 Index Partitioning"></a>5.4.3 Index Partitioning</h4><ul>
<li><p>Local vs Global</p>
<ul>
<li>Local Partition Index<ul>
<li>Table Partition과 1:1 대응하도록 Index Partitioning</li>
<li>Index Partition Key를 사용자가 따로 지정하지 않고, DBMS가 자동으로 관리</li>
</ul>
</li>
<li>Global Partition Index<ul>
<li>Table Partition과는 독립적으로 구성</li>
</ul>
</li>
</ul>
</li>
<li><p>Prefixed vs NonPrefixed</p>
<ul>
<li>Prefixed Partition Index : Partition Key Column이 Index의 왼쪽 선두에 위치</li>
<li>NonPrefixed Partition Index : Partition Key Column이 Index의 왼쪽 선두에 있지 않거나, 아에 속하지 않을 경우</li>
</ul>
</li>
<li><p>위 조합중 Global NonPrefixed Partition Index는 Oracle에서 지원하지 않음</p>
</li>
<li><p>Index Partitioning Guide</p>
<ul>
<li>NonPartitioned Index (일반 Index)<ul>
<li>Partition Key Column이 조건절에 누락되면 여러 Index Partition을 액세스해야 하므로 비효율적</li>
<li>특히 OLTP환경에서는 성능에 미치는 영향이 크므로 NonPartitioned 전략이 유용할 수 있음</li>
<li>NL Join에서 Partition Key에 대한 넓은 범위검색 조건을 가지고 Inner Table에 Partitioned Index로 액세스하면 비효율적 -&gt; NonPartitioned Index 사용을 고려</li>
<li>Partition Index를 이용하면 SORT ORDER BY 대체 효과 상실 -&gt; Sort 연산을 대체함으로 부분범위 처리를 활용하고자 할 경우 NonPartitioned Index가 유리함</li>
<li>Table Partition 이동,삭제 등 작업시 unsuable 되므로 적용 시 주의</li>
</ul>
</li>
<li>Global Prefixed<ul>
<li>Index 경합 분산에 효과적</li>
<li>여러 Local Index Partition을 액세스하는 것이 비효율적일 경우 대안으로 활용</li>
<li>Table Partition 이동,삭제 등 작업시 unsuable 되므로 적용 시 주의</li>
</ul>
</li>
<li>Local Prefixed<ul>
<li>관리적 측면에서 유용 : Table Partition에 대한 추가, 삭제 등의 작업이 빈번할 때</li>
<li>이력성 데이터를 주로 관리하는 DB 환경에 효과적</li>
<li>Partition Key Column이 <code>=</code> 조건으로 사용될 때 유용</li>
<li>Partition Key Column에 대한 검색 조건이 없으면 정상적 사용이 불가 (Index Full Scan으로는 선택가능)</li>
<li>Partition Key Column이 범위검색 (LIKE, BETWEEN, 부등호) 일 경우 불리</li>
</ul>
</li>
<li>Local NonPrefixed<ul>
<li>Local Prefixed와 거의 같은 특징이긴하나</li>
<li>범위검색이 주로 사용될 경우 NonPrefixed가 더 유리 (단, 좁은 범위검색이어야 함)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-5-Batch-Program-Tuning"><a href="#5-5-Batch-Program-Tuning" class="headerlink" title="5.5 Batch Program Tuning"></a>5.5 Batch Program Tuning</h3><ul>
<li><p>Batch Program이란 ?</p>
<ul>
<li>User와의 상호작용(Interface)없이</li>
<li>대량의 데이터를 처리하는</li>
<li>일련의 작업들을 묶어</li>
<li>정기적으로 반복 수행하거나 (정기 배치)</li>
<li>정해진 규칙에 따라 (이벤트 배치)</li>
<li>자동으로 수행 (수동으로 On-Demand 배치로도 수행가능)</li>
</ul>
</li>
<li><p>Batch 환경의 변화</p>
<ul>
<li>과거 : 일, 월 단위로 주로 야간에 수행되었으며, Online과 Batch가 명확하게 구분되어서 사용되었지만,</li>
<li>현재 : 시간, 분 단위의 짧은 시간에 수행되는 경우가 많으며 On-Demand Batch도 제한적이나마 허용되어야 한다.</li>
</ul>
</li>
<li><p>성능개선 목표 설정</p>
<ul>
<li>전체 Batch Program 들의 최종 수행시간 단축<ul>
<li>Batch Window를 보고 Batch Program 간의 선후 관계를 따져가면서 전체적으로 고려</li>
</ul>
</li>
<li>System 부하도 고려해야 함<ul>
<li>병렬도 (DOP : Degree of Parallelism)를 32로 하여 5분에 수행되는것보다는 병렬처리 없이 10분 소요되는게 더 나을 수 있다.</li>
</ul>
</li>
<li>경합을 최소화<ul>
<li>CPU 자원 대량 사용 및 동일한 자원(데이터)에 접근하는 Batch Program을 분산</li>
</ul>
</li>
</ul>
</li>
<li><p>Batch Program 구현 Pattern과 Tuning 방안</p>
<ul>
<li>절차형으로 작성된 Program<ul>
<li>Application Cursor를 열고, Loop 내에서 다른 SQL이나 Sub Procedure를 호출하면서 반복처리</li>
<li>(One SQL 보다) 구현이 쉽다. </li>
<li>아무리 Tuning을 잘해도 다음과 같은 최적화 한계가 있음<ul>
<li>반복적인 DB Call 발생</li>
<li>Random I/O 위주</li>
<li>동일한 데이터 중복 액세스</li>
</ul>
</li>
<li>Tuning Guide<ul>
<li>병목을 일으키는 SQL을 찾아 I/O Tuning : Index 재구성 및 액세스 경로 최적화</li>
<li>Program Parallel 활용 : SQL이 읽는 데이터 범위를 달리하여 여러 Program이 동시에 수행</li>
<li>Array Processing 활용</li>
<li>One SQL로 다시 구현;;;</li>
</ul>
</li>
</ul>
</li>
<li>One SQL<ul>
<li>One SQL로 구현하거나, 집합적으로 정의된 여러 SQL을 단계적으로 실행</li>
<li>구현하기 어렵고, 업무가 복잡할 경우 여러 SQL들을 통합했다가 결과가 틀려질 수 있음</li>
<li>Tuning Guide<ul>
<li>병목을 일으키는 오퍼레이션을 찾아 I/O Tuning<ul>
<li>Index Scan 대신 Full Table Scan으로</li>
<li>NL Join 보다 Hash Join으로</li>
</ul>
</li>
<li>임시 Table 활용</li>
<li>Partition 활용</li>
<li>병렬처리 활용</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>병렬 처리 활용</p>
<ul>
<li><code>SELECT /*+ full(T) parallel(T, 4) */ ...</code> : T Table을 Full Scan으로 4개로 병렬처리</li>
<li><code>SELECT /*+ index_ffs(T t_idx) parallel(T, t_idx, 4) */ ...</code> : T Table의 t_idx Index를 Fast Full Scan으로 4개로 병렬처리</li>
<li>QC (Query Cordinator)<ul>
<li>병렬 SQL문을 발행한 Session</li>
<li>병렬로 처리되지 않는 Table은 QC가 직접처리</li>
<li>각 병렬 Server로부터의 산출물을 통합하는 작업 수행</li>
<li>최종 결과 집합을 User에게 전송</li>
</ul>
</li>
<li>Parallel Server Process<ul>
<li>병렬 SQL을 실제로 수행하는 개별 Session</li>
</ul>
</li>
<li>Operation Parallelism<ul>
<li>Intra-Opertarion Parallelism<ul>
<li>서로 배타적인 범위를 독립적으로 처리</li>
<li>각각의 데이터를 Process별로 읽는 작업</li>
<li>전달받은 데이터를 각각의 Process에서 처리</li>
</ul>
</li>
<li>Inter-Operation Parallelism<ul>
<li>다른 서버 집합으로 분배하거나 정렬된 결과를 QC에게 전송하는 작업을 병렬로 동시에 진행</li>
<li>Process간의 통신이 발생</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/02/11/04.04.partition/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/11/04.03.dml/">
                            SQLP 3-5-3 DML Tuning
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-02-11T01:00:00+09:00">
	
		    Feb 11, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="3과목-SQL-고급-활용-및-Tuning"><a href="#3과목-SQL-고급-활용-및-Tuning" class="headerlink" title="3과목 SQL 고급 활용 및 Tuning"></a>3과목 SQL 고급 활용 및 Tuning</h1><h2 id="5장-고급-SQL-Tuning"><a href="#5장-고급-SQL-Tuning" class="headerlink" title="5장 고급 SQL Tuning"></a>5장 고급 SQL Tuning</h2><h3 id="5-3-DML-Tuning"><a href="#5-3-DML-Tuning" class="headerlink" title="5.3 DML Tuning"></a>5.3 DML Tuning</h3><ul>
<li>DML 수행시<ul>
<li>Table 변경</li>
<li>Index 변경 : Update  수행시 Index는 Delete &amp; Insert 수행</li>
<li>Redo, Undo 생성</li>
</ul>
</li>
</ul>
<h4 id="5-3-1-Insert-Tuning"><a href="#5-3-1-Insert-Tuning" class="headerlink" title="5.3.1 Insert Tuning"></a>5.3.1 Insert Tuning</h4><ol>
<li>Direct Path Insert<ul>
<li>Freelist 조회없이, Buffer Cache를 거치지 않고 datafile에 바로 입력하는 방식</li>
<li>INSERT SELECT 문장에 <code>/*+ append */</code> Hint 사용</li>
<li>Parallel Mode로 INSERT</li>
<li>direct 옵션을 지정하고 SQL#Loader(sqlldr)로 데이터 로드</li>
<li>CTAS (CREATE TABLE … AS SELECT) 문장을 수행</li>
</ul>
</li>
<li>nologging 모드 Insert<ul>
<li><code>ALTER TABLE 테이블명 NOLOGGING;</code></li>
<li>Redo Log까지 최소화 (DPI에서는 Freelist 조회X, Buffer Cache X)</li>
<li>Direct Path Insert 시에만 작동</li>
<li>단 Exclusive Mode Table Lock이 걸리므로 다른 Transaction이 해당 Table에 DML 수행을 차단</li>
<li>nologging 상태에서 입력한 데이터는 장애 발생시 복구가 불가능<ul>
<li>입력후 바로 Backup을 해야 함 </li>
<li>언제든 재생 가능한 데이터라면 상관없음<ul>
<li>e.g. 배치 프로그램에서 중간 단계 임시 Table</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="5-3-2-Update-Tuning"><a href="#5-3-2-Update-Tuning" class="headerlink" title="5.3.2 Update Tuning"></a>5.3.2 Update Tuning</h5><h5 id="1-Truncate-amp-Insert-방식"><a href="#1-Truncate-amp-Insert-방식" class="headerlink" title="1. Truncate &amp; Insert 방식"></a>1. Truncate &amp; Insert 방식</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> contract <span class="keyword">SET</span> <span class="keyword">status</span> = <span class="string">'9999'</span> <span class="keyword">WHERE</span> ord_date &lt; _TO_DATE(<span class="string">'20000101'</span>, <span class="string">'yyyymmdd);</span></div></pre></td></tr></table></figure>
<ul>
<li>대량의 데이터를 UPDATE하면 상당히 오랜시간이 걸린다.<ul>
<li>UPDATE 자체 작업</li>
<li>Index Delete &amp; Insert</li>
<li>Datafile을 Buffer Cache로 load한 후에 갱신</li>
<li>Redo, Undo 정보 생성</li>
<li>Block에 빈 공간이 없는 경우 새 블록 할당 -&gt; Row Migration</li>
</ul>
</li>
<li>그래서 차라리 Table을 새로 생성하여서 작업을 한 후에 Index를 생성하는 것이 더 효율적일 수 있다.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tmp_cont <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> contract;  <span class="comment">-- 임시 Table로 데이터 복사</span></div><div class="line"></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> cont_pk;              <span class="comment">-- INDEX 삭제</span></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> contract.cont_idx;</div><div class="line"></div><div class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> contract;                          <span class="comment">-- Table 데이터 삭제 (No Undo)</span></div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> contract (ord_no, ord_date, <span class="keyword">status</span>)   <span class="comment">-- UPDATE 문에 대응하는 INSERT INTO SELECT 문</span></div><div class="line"><span class="keyword">SELECT</span> ord_no, ord_date,</div><div class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> ord_date &gt;= <span class="keyword">TO_DATE</span>(<span class="string">'20000101'</span>, <span class="string">'yyyymmdd'</span>) <span class="keyword">then</span> <span class="string">'9999'</span> <span class="keyword">ELSE</span> <span class="keyword">status</span> <span class="keyword">END</span></div><div class="line"> <span class="keyword">FROM</span> tmp_cont;</div><div class="line"></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> contract <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> cont_pk PRIMARY <span class="keyword">KEY</span> (ord_no, ord_date);    <span class="comment">-- INDEX 다시 생성</span></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> cont_idx <span class="keyword">ON</span> contract(ord_date, <span class="keyword">status</span>);</div><div class="line"></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> tmp_cont;                              <span class="comment">-- 임시 Table 삭제</span></div></pre></td></tr></table></figure>
<p>이 작업은 UPDATE 뿐만 아니라 DELETE 에도 적용이 가능하다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DELETE</span> contract <span class="keyword">WHERE</span> ord_date &lt; <span class="keyword">TO_DATE</span>(<span class="string">'20010101'</span>,<span class="string">'yyyymmdd'</span>);</div></pre></td></tr></table></figure>
<p>위 문장을 수행하는 것보다 아래가 더 효율적일 수 있다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tmp_cont                  <span class="comment">-- DELETE 문에 대응하는 CTAS</span></div><div class="line"><span class="keyword">AS</span></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> contract</div><div class="line"> <span class="keyword">WHERE</span> ord_date &gt;= <span class="keyword">TO_DATE</span>(<span class="string">'20010101'</span>,<span class="string">'yyyymmdd'</span>);</div><div class="line"></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> cont_pk;</div><div class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> contract.cont_pk;</div><div class="line"></div><div class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> contract;</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> contract</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tmp_cont;</div><div class="line"></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> cont_pk PRIMARY <span class="keyword">KEY</span> (ord_no, ord_date);</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> cont_idx <span class="keyword">ON</span> contract(ord_date, <span class="keyword">status</span>);</div><div class="line"></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> tmp_cont;</div></pre></td></tr></table></figure></p>
<h5 id="2-Join을-내포한-Update-Tuning"><a href="#2-Join을-내포한-Update-Tuning" class="headerlink" title="2. Join을 내포한 Update Tuning"></a>2. Join을 내포한 Update Tuning</h5><ul>
<li>UPDATE 자체 성능보다는 Join 과정의 비효율 때문에 성능이 느려지는 경우가 더 많다.</li>
</ul>
<ul>
<li><p>최근 1달안에 거래내역이 있는 고객의 최종거래일시와 1달간의 거래금액을 UPDATE하는 문장에 대한 예제이다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> 고객</div><div class="line">   <span class="keyword">SET</span> (최종거래일시, 최근거래금액) = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(거래일시), <span class="keyword">SUM</span>(거래금액)</div><div class="line">                                         <span class="keyword">FROM</span> 거래</div><div class="line">                                        <span class="keyword">WHERE</span> 고객번호 = 고객.고객번호</div><div class="line">                                          <span class="keyword">AND</span> 거래일시 &gt;= TRUNC(ADD_MONTHS(<span class="keyword">SYSDATE</span>, <span class="number">-1</span>)))</div><div class="line"> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> 거래</div><div class="line">                <span class="keyword">WHERE</span> 고객번호 = 고객.고객번호</div><div class="line">                  <span class="keyword">AND</span> 거래일시 &gt;= TRUNC(ADD_MONTHS(<span class="keyword">SYSDATE</span>, <span class="number">-1</span>)));</div></pre></td></tr></table></figure>
</li>
<li><p>문제점</p>
<ul>
<li>거래 Table을 2번 참조했다.</li>
<li>[고객번호 + 거래일시] Index가 필요하다.</li>
<li>Index에 데이터가 많으면 Random 액세스로 Join을 수행하기 때문에 비효율적이다.</li>
</ul>
</li>
<li><p>해결방안1</p>
<ul>
<li>Sub-query에서 <code>unnest</code> 와 <code>hash_sj</code> Hint를 이용해서 Semi Join 방법을 유도</li>
<li>그래도 여전히 Table을 2번 참조하긴 해야 한다.</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> 고객</div><div class="line">   <span class="keyword">SET</span> (최종거래일시, 최근거래금액) = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(거래일시), <span class="keyword">SUM</span>(거래금액)</div><div class="line">                                         <span class="keyword">FROM</span> 거래</div><div class="line">                                        <span class="keyword">WHERE</span> 고객번호 = 고객.고객번호</div><div class="line">                                          <span class="keyword">AND</span> 거래일시 &gt;= TRUNC(ADD_MONTHS(<span class="keyword">SYSDATE</span>, <span class="number">-1</span>)))</div><div class="line"> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ unnest hash_sj */</span> <span class="number">1</span></div><div class="line">                <span class="keyword">FROM</span> 거래</div><div class="line">               <span class="keyword">WHERE</span> 고객번호 = 고객.고객번호</div><div class="line">                 <span class="keyword">AND</span> 거래일시 &gt;= TRUNC(ADD_MONTH(<span class="keyword">SYSDATE</span>, <span class="number">-1</span>)));</div></pre></td></tr></table></figure>
<ul>
<li>해결방안2<ul>
<li>수정가능 조인뷰 (Updatable Join View) 활용</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> <span class="comment">/*+ bypass_ujvc */</span></div><div class="line">       (<span class="keyword">SELECT</span> c.최종거래일시, c.최근거래금액, t.거래일시, t.거래금액</div><div class="line">          <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> 고객번호, <span class="keyword">MAX</span>(거래일시) 거래일시, <span class="keyword">SUM</span>(거래금액) 거래금액</div><div class="line">                  <span class="keyword">FROM</span> 거래</div><div class="line">                 <span class="keyword">WHERE</span> 거래일시 &gt;= TRUNC(ADD_MONTH(<span class="keyword">SYSDATE</span>, <span class="number">-1</span>))</div><div class="line">                 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 고객번호) t,</div><div class="line">               고객 c</div><div class="line">         <span class="keyword">WHERE</span> c.고객번호 = t.고객번호)</div><div class="line">   <span class="keyword">SET</span> 최종거래일시 = 거래일시,</div><div class="line">       최근거래금액 = 거래금액;</div></pre></td></tr></table></figure>
<ul>
<li><p>Updatable Join View 란 ?</p>
<ul>
<li>Join View : FROM 절에 2 개의 Table을 가진 View</li>
<li>Unique Index가 있는 Table 쪽의 Unique 한 경우에만 UPDATE가 가능<ul>
<li>GROUP BY를 통하면 결과가 무조건 Unique한데도 불구하고 Unique Index가 없으면 수정 불가</li>
</ul>
</li>
</ul>
</li>
<li><p>Oracle MERGE문 활용</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> 대상테이블 t <span class="keyword">using</span> 소스테이블 s <span class="keyword">ON</span> (t.id = s.id)  <span class="comment">-- 조건</span></div><div class="line"><span class="keyword">WHEN</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span></div><div class="line">    <span class="keyword">UPDATE</span> <span class="keyword">SET</span> t.a = s.a, ...</div><div class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span></div><div class="line">    <span class="keyword">INSERT</span> (t.컬렴<span class="keyword">list</span>) <span class="keyword">VALUES</span> (s.컬럼<span class="keyword">list</span>);</div></pre></td></tr></table></figure>
<ul>
<li>Oracle 9i, MS-SQL 2008부터 지원</li>
<li>Oracle 10g부터는 UPDATE, INSERT 를 선택적으로 따로 처리가 가능</li>
</ul>
<p>MERGE문으로 앞에서 본 Updatable Join View를 대체 할 수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> 고객 c</div><div class="line">     <span class="keyword">USING</span> (<span class="keyword">SELECT</span> 고객번호, <span class="keyword">MAX</span>(거래일시) 거래일시, <span class="keyword">SUM</span>(거래금액) 거래금액</div><div class="line">             <span class="keyword">FROM</span> 거래</div><div class="line">            <span class="keyword">WHERE</span> 거래일시 &gt;= TRUNC(ADD_MONTHS(<span class="keyword">SYSDATE</span>,<span class="number">-1</span>))</div><div class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> 고객번호) t</div><div class="line">        <span class="keyword">ON</span> (c.고객번호 = t.고객번호)</div><div class="line"><span class="keyword">WHEN</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span></div><div class="line">    <span class="keyword">UPDATE</span> <span class="keyword">SET</span> c.최종거래일시 = t.거래일시,</div><div class="line">               c.최근거래금액 = t.거래금액</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/02/11/04.03.dml/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/09/04.02.sort/">
                            SQLP 3-5-2 Sort Tuning
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-02-09T01:00:00+09:00">
	
		    Feb 09, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="3과목-SQL-고급-활용-및-Tuning"><a href="#3과목-SQL-고급-활용-및-Tuning" class="headerlink" title="3과목 SQL 고급 활용 및 Tuning"></a>3과목 SQL 고급 활용 및 Tuning</h1><h2 id="5장-고급-SQL-Tuning"><a href="#5장-고급-SQL-Tuning" class="headerlink" title="5장 고급 SQL Tuning"></a>5장 고급 SQL Tuning</h2><h3 id="5-2-Sort-Tuning"><a href="#5-2-Sort-Tuning" class="headerlink" title="5.2 Sort Tuning"></a>5.2 Sort Tuning</h3><h4 id="5-2-1-Sort-Tuning-전략"><a href="#5-2-1-Sort-Tuning-전략" class="headerlink" title="5.2.1 Sort Tuning 전략"></a>5.2.1 Sort Tuning 전략</h4><ul>
<li>Data Modeling 측면에서 검토<ul>
<li>GROUP BY, DISTINCT, UNION 연산이 자주 일어난다면 정규화를 잘하면 많이 해소된다.</li>
<li>M:M 관계에서 조회하려면 Sort 연산이 많이 일어난다.</li>
</ul>
</li>
<li>Sort 발생하지 않도록 SQL 작성<ul>
<li>UNION -&gt; UNION ALL</li>
<li>DISTINCT -&gt; EXISTS</li>
<li>불필요한 COUNT 연산 제거</li>
</ul>
</li>
<li>Index를 이용한 Sort 연산 대체<ul>
<li>Sort Order By, Sort Group By, Min, Max 등…</li>
</ul>
</li>
<li>Sort Area를 적게 사용하도록 SQL 작성<ul>
<li>Sort 완료 후 데이터 가공<ul>
<li><code>||</code> 연산으로 붙인 후 Sort하지 말고 먼저 Sort한 것을 Inline View로 구한 뒤 결합하자.</li>
</ul>
</li>
<li>Top-N Query</li>
</ul>
</li>
<li>Sort 영역 크기 조정<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">SESSION</span> <span class="keyword">SET</span> WORKAREA_SIZE_POLICY = <span class="keyword">MANUAL</span>;</div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">SESSION</span> <span class="keyword">SET</span> SORT_AREA_SIZE = N;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-2-2-Memory-Sort-vs-Disk-Sort"><a href="#5-2-2-Memory-Sort-vs-Disk-Sort" class="headerlink" title="5.2.2 Memory Sort vs Disk Sort"></a>5.2.2 Memory Sort vs Disk Sort</h4><ul>
<li>Memory Sort<ul>
<li>전체 정렬 작업을 할당받은 Sort Area (PGA) 내에서 완료</li>
<li>Internal Sort, Optimal Sort 라고도 함</li>
</ul>
</li>
<li>Disk Sort<ul>
<li>할당받은 Sort Area 안에서 완료못해서 Disk까지 사용</li>
<li>External Sort 라고도 함<ul>
<li>Onepass Sort : disk에 한 번만 기록</li>
<li>Multipass Sort : disk에 여러 번 기록</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-2-3-Sort-Operation"><a href="#5-2-3-Sort-Operation" class="headerlink" title="5.2.3 Sort Operation"></a>5.2.3 Sort Operation</h4><h5 id="1-Sort-Aggregate"><a href="#1-Sort-Aggregate" class="headerlink" title="1. Sort Aggregate"></a>1. Sort Aggregate</h5><ul>
<li>집계 함수 수행. (실제로 Sort가 발생하진 않음)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(SAL), <span class="keyword">MAX</span>(SAL), <span class="keyword">MIN</span>(SAL) <span class="keyword">FROM</span> EMP;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STATEMENT</span> OPTIMIZER=ALL_ROWS</div><div class="line">    <span class="keyword">SORT</span> (<span class="keyword">AGGREGATE</span>)</div><div class="line">        <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">FULL</span>) <span class="keyword">OF</span> <span class="string">`EMP`</span> (<span class="keyword">TABLE</span>)</div></pre></td></tr></table></figure>
<h5 id="2-Sort-Order-By"><a href="#2-Sort-Order-By" class="headerlink" title="2. Sort Order By"></a>2. Sort Order By</h5><ul>
<li>ORDER BY (Index가 있는 컬럼에 대해서는 발생하지 않음)<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STATEMENT</span> OPTIMIZER=ALL_ROWS</div><div class="line">    <span class="keyword">SORT</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span>)</div><div class="line">        <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">FULL</span>) <span class="keyword">OF</span> <span class="string">'EMP'</span> (<span class="keyword">TABLE</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">ORDER</span> <span class="keyword">BY</span> EMPNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STATEMENT</span> OPTIMIZER=ALL_ROWS</div><div class="line">    <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">BY</span> <span class="keyword">INDEX</span> <span class="keyword">ROWID</span>) <span class="keyword">OF</span> <span class="string">`EMP`</span> (<span class="keyword">TABLE</span>)</div><div class="line">        <span class="keyword">INDEX</span> (<span class="keyword">FULL</span> <span class="keyword">SCAN</span>) <span class="keyword">OF</span> <span class="string">'PK_EMP'</span> (<span class="keyword">INDEX</span> (<span class="keyword">UNIQUE</span>))</div></pre></td></tr></table></figure>
<h5 id="3-Sort-Group-By"><a href="#3-Sort-Group-By" class="headerlink" title="3. Sort Group By"></a>3. Sort Group By</h5><ul>
<li>GROUP BY<ul>
<li>예전에는 GROUP BY가 Sort된 형태의 결과를 보장했지만, 요즘은 Optimizer가 대신 Hash를 사용 할 수도 있기 때문에 순서를 보장하지 않음</li>
<li>따로 ORDER BY를 붙여줘야지만 순서를 보장함<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> JOB, <span class="keyword">SUM</span>(SAL) <span class="keyword">FROM</span> EMP <span class="keyword">GROUP</span> <span class="keyword">BY</span> JOB <span class="keyword">ORDER</span> <span class="keyword">BY</span> JOB;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STATEMENT</span> OPTIMIZER=ALL_ROWS</div><div class="line">    <span class="keyword">SORT</span> (<span class="keyword">GROUP</span> <span class="keyword">BY</span>)</div><div class="line">        <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">FULL</span>) <span class="keyword">OF</span> <span class="string">'EMP'</span> (<span class="keyword">TABLE</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> JOB, <span class="keyword">SUM</span>(SAL) <span class="keyword">FROM</span> EMP <span class="keyword">GROUP</span> <span class="keyword">BY</span> JOB;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STATEMENT</span> OPTIMIZER=ALL_ROWS</div><div class="line">    <span class="keyword">HASH</span> (<span class="keyword">GROUP</span> <span class="keyword">BY</span>)</div><div class="line">        <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">FULL</span>) <span class="keyword">OF</span> <span class="string">'EMP'</span> (<span class="keyword">TABLE</span>)</div></pre></td></tr></table></figure>
<h5 id="4-Sort-Unique"><a href="#4-Sort-Unique" class="headerlink" title="4. Sort Unique"></a>4. Sort Unique</h5><ul>
<li>UNION, DISTINCT 연산자 사용시<ul>
<li>GROUP BY 같이 Sort를 보장해주지 않으므로 ORDER BY를 안붙여주면 Optimizer가 Hash로 실행할 가능성이 높음</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DEPTNO <span class="keyword">FROM</span> EMP <span class="keyword">ORDER</span> <span class="keyword">BY</span> DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STATEMENT</span> OPTIMIZER=ALL_ROWS</div><div class="line">    <span class="keyword">SORT</span> (<span class="keyword">UNIQUE</span>)</div><div class="line">        <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">FULL</span>) <span class="keyword">OF</span> <span class="string">'EMP'</span> (<span class="keyword">TABLE</span>)</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DEPTNO <span class="keyword">FROM</span> EMP;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STATEMENT</span> OPTIMIZER=ALL_ROWS</div><div class="line">    <span class="keyword">HASH</span> (<span class="keyword">UNIQUE</span>)</div><div class="line">        <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">FULL</span>) <span class="keyword">OF</span> <span class="string">`EMP`</span> (<span class="keyword">TABLE</span>)</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> SAL &lt;= <span class="number">1500</span></div><div class="line"> <span class="keyword">UNION</span></div><div class="line"><span class="keyword">SELECT</span> DNAME <span class="keyword">FROM</span> DEPT;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STATEMENT</span> OPTIMIZER=ALL_ROWS</div><div class="line">    <span class="keyword">SORT</span> (<span class="keyword">UNIQUE</span>)</div><div class="line">        <span class="keyword">UNION</span>-ALL</div><div class="line">            <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">BY</span> <span class="keyword">INDEX</span> <span class="keyword">ROWID</span>) <span class="keyword">OF</span> <span class="string">'EMP'</span> (<span class="keyword">TABLE</span>)</div><div class="line">                <span class="keyword">INDEX</span> (<span class="keyword">RANGE</span> <span class="keyword">SCAN</span>) <span class="keyword">OF</span> <span class="string">'EMP_SAL_IDX'</span> (<span class="keyword">INDEX</span>)</div><div class="line">            <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">FULL</span>) <span class="keyword">OF</span> <span class="string">'DEPT'</span> (<span class="keyword">TABLE</span>)</div></pre></td></tr></table></figure>
<h5 id="5-Sort-Join"><a href="#5-Sort-Join" class="headerlink" title="5. Sort Join"></a>5. Sort Join</h5><ul>
<li>Sort Merge Join 수행시 (Index 사용할 경우에는 발생하지 않을 수 있음)<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ordered use_merge(d) */</span> * <span class="keyword">FROM</span> EMP e, DEPT d <span class="keyword">WHERE</span> e.DEPTNO = d.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STATEMENT</span> OPTIMIZER=ALL_ROWS</div><div class="line">    <span class="keyword">MERGE</span> <span class="keyword">JOIN</span></div><div class="line">        <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">BY</span> <span class="keyword">INDEX</span> <span class="keyword">ROWID</span>) <span class="keyword">OF</span> <span class="string">'EMP'</span> (<span class="keyword">TABLE</span>)</div><div class="line">            <span class="keyword">INDEX</span> (<span class="keyword">FULL</span> <span class="keyword">SCAN</span>) <span class="keyword">OF</span> <span class="string">'EMP_DEPT_IDX'</span> (<span class="keyword">INDEX</span>)</div><div class="line">        <span class="keyword">SORT</span> (<span class="keyword">JOIN</span>)</div><div class="line">            <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">FULL</span>) <span class="keyword">OF</span> <span class="string">'EMP'</span> (<span class="keyword">TABLE</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="6-Window-Sort"><a href="#6-Window-Sort" class="headerlink" title="6. Window Sort"></a>6. Window Sort</h5><ul>
<li>Window 함수에서 ORDER BY 수행시<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> EMPNO, ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> HIREDATE) <span class="keyword">FROM</span> EMP;</div><div class="line"></div><div class="line">SELETE STATEMENT OPTIMIZER=ALL_ROWS</div><div class="line">    WINDOW (SORT)</div><div class="line">        TABLE ACCESS (FULL) OF 'EMP' (TABLE)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-2-4-Sort가-발생하지-않도록-SQL-작성"><a href="#5-2-4-Sort가-발생하지-않도록-SQL-작성" class="headerlink" title="5.2.4 Sort가 발생하지 않도록 SQL 작성"></a>5.2.4 Sort가 발생하지 않도록 SQL 작성</h4><h5 id="1-UNION을-UNION-ALL로-대체"><a href="#1-UNION을-UNION-ALL로-대체" class="headerlink" title="1. UNION을 UNION ALL로 대체"></a>1. UNION을 UNION ALL로 대체</h5><ul>
<li>UNION : 중복 제거를 위해 SORT UNIQUE 연산을 수행한다.</li>
<li>UNION ALL : 중복을 허용하고 두 집합을 단순히 결합한다.</li>
<li>두 연산의 결과가 같다는게 보장된다면 UNION보다는 UNION ALL을 사용하는게 성능상 도움이 된다.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO = <span class="number">10</span></div><div class="line"> <span class="keyword">UNION</span></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO = <span class="number">20</span>;</div><div class="line"></div><div class="line">SELETE STATEMENT OPTIMIZER=ALL_ROWS</div><div class="line">    SORT (UNIQUE)</div><div class="line">        UNION-ALL</div><div class="line">            TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE)</div><div class="line">                INDEX (RANGE SCAN) OF 'EMP_DEPT_IDX' (INDEX)</div><div class="line">            TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE)</div><div class="line">                INDEX (RANGE SCAN) OF 'EMP_DEPT_IDX' (INDEX)</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO = <span class="number">10</span></div><div class="line"> <span class="keyword">UNION</span> ALL</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO = <span class="number">20</span>;</div><div class="line"></div><div class="line">SELETE STATEMENT OPTIMIZER=ALL_ROWS</div><div class="line">    UNION-ALL</div><div class="line">        TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE)</div><div class="line">            INDEX (RANGE SCAN) OF 'EMP_DEPT_IDX' (INDEX)</div><div class="line">        TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE)</div><div class="line">            INDEX (RANGE SCAN) OF 'EMP_DEPT_IDX' (INDEX)</div></pre></td></tr></table></figure>
<p>실행계획을 보면 나머진 똑같은데 SORT (UNIQUE) 연산이 빠졌다.</p>
<h5 id="2-DISTINCT를-EXISTS-Sub-query로-대체"><a href="#2-DISTINCT를-EXISTS-Sub-query로-대체" class="headerlink" title="2. DISTINCT를 EXISTS Sub-query로 대체"></a>2. DISTINCT를 EXISTS Sub-query로 대체</h5><ul>
<li>중복제거를 위해 DISTINCT를 사용하는게 대표적인데, EXISTS로 대체가 가능하다.</li>
<li>EXISTS의 경우에는 조건에 맞는 것 1개만 찾으면 바로 다음으로 넘어가버리기 때문에 성능상 유리하다.</li>
<li>이럴 경우 DISTINCT한 값들이 들어가 있는 Table (주로 Master Table)이 필수적으로 필요하다.</li>
<li>Master Table이 없는 경우 별도로 생성하는 경우도 있다. (e.g. 연월 Table)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DEPTNO <span class="keyword">FROM</span> EMP <span class="keyword">ORDER</span> <span class="keyword">BY</span> DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STATEMENT</span> OPTIMIZER=ALL_ROWS</div><div class="line">    <span class="keyword">SORT</span> (<span class="keyword">UNIQUE</span>)</div><div class="line">        <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">FULL</span>) <span class="keyword">OF</span> <span class="string">'EMP'</span> (<span class="keyword">TABLE</span>)</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO <span class="keyword">FROM</span> DEPT <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO = DEPT.DEPTNO) <span class="keyword">ORDER</span> <span class="keyword">BY</span> DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STATEMENT</span> OPTIMIZER=ALL_ROWS</div><div class="line">    <span class="keyword">NESTED</span> LOOPS (SEMI)</div><div class="line">        <span class="keyword">INDEX</span> (<span class="keyword">FULL</span> <span class="keyword">SCAN</span>) <span class="keyword">OF</span> <span class="string">'PK_DEPT'</span> (<span class="keyword">INDEX</span> (<span class="keyword">UNIQUE</span>))</div><div class="line">        <span class="keyword">INDEX</span> (<span class="keyword">RANGE</span> <span class="keyword">SCAN</span>) <span class="keyword">OF</span> <span class="string">'EMP_DEPT_IDX'</span> (<span class="keyword">INDEX</span>)</div></pre></td></tr></table></figure>
<ul>
<li>Semi Join<ul>
<li>Subquery unnesting의 대표적인 결과</li>
<li>Join 조건에 만족하는 것이 하나라도 있으면 다음으로 넘어감</li>
</ul>
</li>
</ul>
<h5 id="3-불필요한-COUNT-연산-제거"><a href="#3-불필요한-COUNT-연산-제거" class="headerlink" title="3. 불필요한 COUNT 연산 제거"></a>3. 불필요한 COUNT 연산 제거</h5><p>이건 근본적으로 잘못 짜여진 SQL에서 비롯된 문제이다.<br>해당 데이터가 있는지 그 여부를 알기 위해서  </p>
<ul>
<li><code>COUNT(*)</code>를 사용하면 : <code>SORT AGGREGATE</code> 가 발생하고</li>
<li><code>ROWNUM &lt;= 1</code> 조건을 사용하면 : <code>COUNT STOPKEY</code>가 발생한다.</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/02/09/04.02.sort/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/09/04.01.onesql/">
                            SQLP 3-5-1 One SQL
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-02-09T00:00:00+09:00">
	
		    Feb 09, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="3과목-SQL-고급-활용-및-Tuning"><a href="#3과목-SQL-고급-활용-및-Tuning" class="headerlink" title="3과목 SQL 고급 활용 및 Tuning"></a>3과목 SQL 고급 활용 및 Tuning</h1><h2 id="5장-고급-SQL-Tuning"><a href="#5장-고급-SQL-Tuning" class="headerlink" title="5장 고급 SQL Tuning"></a>5장 고급 SQL Tuning</h2><h3 id="5-1-One-SQL-구현-기법"><a href="#5-1-One-SQL-구현-기법" class="headerlink" title="5.1 One SQL 구현 기법"></a>5.1 One SQL 구현 기법</h3><h4 id="5-1-1-CASE-DECODE-활용"><a href="#5-1-1-CASE-DECODE-활용" class="headerlink" title="5.1.1 CASE(DECODE) 활용"></a>5.1.1 CASE(DECODE) 활용</h4><p>One SQL 기법중 가장 기본인 CASE를 이용하여 record로 나눠져 있는 데이터를 한 row에 표현하는 방법이다.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">월별납입방법별집계</div><div class="line"># 고객번호</div><div class="line"># 납입월</div><div class="line"># 납입방법코드</div><div class="line">* 납입금액</div></pre></td></tr></table></figure>
<p>위 Table을 읽어서 아래 형식으로 가공하고자 할 경우</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">월별요금납부실적</div><div class="line"># 고객번호</div><div class="line"># 납입월</div><div class="line">* 지로 금액</div><div class="line">* 자동이체 금액</div><div class="line">* 신용카드 금액</div><div class="line">* 핸드폰 금액</div><div class="line">* 인터넷 금액</div></pre></td></tr></table></figure>
<p>CASE를 이용한 One SQL로 구현해보자. (이건 너무 자주 나온 방법이라… 별 다른 설명이 필요없을듯 하다.)  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> 고객번호, 납입월,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(납입방법코드, <span class="string">'지로'</span>,     납입금액))) 지로,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(납입방법코드, <span class="string">'자동이체'</span>, 납입금액))) 자동이체,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(납입방법코드, <span class="string">'신용카드'</span>, 납입금액))) 신용카드,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(납입방법코드, <span class="string">'인터넷'</span>,   납입금액))) 인터넷,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(납입방법코드, <span class="string">'핸드폰'</span>,   납입금액))) 핸드폰</div><div class="line">  <span class="keyword">FROM</span> 월별납입방법별집계</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> 고객번호, 납입월;</div></pre></td></tr></table></figure>
<h4 id="5-1-2-Table-복제-기법"><a href="#5-1-2-Table-복제-기법" class="headerlink" title="5.1.2 Table 복제 기법"></a>5.1.2 Table 복제 기법</h4><p>Data를 복제를 해서 활용을 해야하는 경우 예전에는 복제용 Table을 생성해 두고 묻지마 JOIN을 활용하여 복제하였다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> COPY_T (<span class="keyword">no</span> <span class="built_in">NUMBER</span>);             <span class="comment">-- 복사용 Table을 생성해 두고,</span></div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COPY_T</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">ROWNUM</span> <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt;= <span class="number">10</span>;   <span class="comment">-- 1 ~ 10의 값을 넣어두고 (최대 10배까지 복사)</span></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP, COPY_T                    <span class="comment">-- 복사할 값에 대해서 묻지마 JOIN</span></div><div class="line"> <span class="keyword">WHERE</span> COPY_T.NO &lt;= <span class="number">2</span>;                       <span class="comment">-- no에 대한 조건으로 복사건수 입력</span></div></pre></td></tr></table></figure>
<p>Oracle 9i부터는 dual Table에 start with 없는 connect by 구문으로 inline view로 활용이 가능하다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">ROWNUM</span> <span class="keyword">FROM</span> dual <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">LEVEL</span> &lt;= <span class="number">2</span>; <span class="comment">-- 2개의 값을 가진 임시 복제 Table</span></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP, (<span class="keyword">SELECT</span> <span class="keyword">ROWNUM</span> <span class="keyword">FROM</span> dual <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">LEVEL</span> &lt;= <span class="number">2</span>);  <span class="comment">-- 2개로 복제</span></div></pre></td></tr></table></figure>
<p>그럼 복사를 이용해서 emp Table을 1번만 읽고 JOB별 SAL의 합계와 전체 합계를 구해보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DECODE</span>(<span class="keyword">no</span>, <span class="number">1</span>, job, <span class="string">'Total'</span>) <span class="keyword">as</span> JOB,</div><div class="line">       <span class="keyword">SUM</span>(sal) <span class="keyword">as</span> SAL</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> job, <span class="keyword">no</span>, sal</div><div class="line">          <span class="keyword">FROM</span> EMP, (<span class="keyword">SELECT</span> <span class="keyword">ROWNUM</span> <span class="keyword">no</span> <span class="keyword">FROM</span> dual <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">LEVEL</span> &lt;= <span class="number">2</span>))</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">no</span>, <span class="keyword">DECODE</span>(<span class="keyword">no</span>, <span class="number">1</span>, job, <span class="string">'Total'</span>)</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> job, <span class="keyword">no</span>;</div></pre></td></tr></table></figure>
<p>사실 위 방식도 옜날 방식이긴하다.<br>그냥 ROLLUP을 이용하면 쉽게 가능하다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECR DECODE(GROUPING(job), 0, job, 'Total') JOB,</div><div class="line">       SUM(sal) SAL</div><div class="line">  FROM emp</div><div class="line"> GROUP BY ROLLUP(job)</div><div class="line"> ORDER BY job;</div></pre></td></tr></table></figure>
<p>ROLLUP을 이용한게 메모리도 훨씬 더 적게 사용한다.</p>
<ul>
<li>dual을 이용한 복제 Table 방식의 Execute Plan<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMIZER=ALL_ROWS</div><div class="line">    SORT (GROUP BY) (Bytes=125)</div><div class="line">        MERGE JOIN (CARTESIAN) (Bytes=350)</div><div class="line">            VIEW</div><div class="line">                 COUNT</div><div class="line">                     CONNECT BY (WITHOUT FILTERING)</div><div class="line">                         FAST DUAL</div><div class="line">            BUFFER (SORT) (Bytes=168)</div><div class="line">                TABLE ACCESS (FULL) OF &apos;EMP&apos; (TABLE) (Bytes=168)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>위 경우에는 MERGE JOIN 단계에서 Table 크기의 2배만큼의 메모리를 사용한다.</p>
<ul>
<li>ROLLUP을 이용한 Execute Plan<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMIZER=ALL_ROWS</div><div class="line">    SORT (ORDER BY) (Bytes=60)</div><div class="line">        SORT (GROUP BY) (Bytes=60)</div><div class="line">            TABLE ACCESS (FULL) OF &apos;EMP&apos; (TABLE) (Bytes=168)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-1-3-UNION-ALL을-활용한-M-M-Join"><a href="#5-1-3-UNION-ALL을-활용한-M-M-Join" class="headerlink" title="5.1.3 UNION ALL을 활용한 M:M Join"></a>5.1.3 UNION ALL을 활용한 M:M Join</h4><p>M:M 관계 Join이나 Full Outer Join을 대신해서 UNION ALL을 활용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">부서별판매계획          채널별판매실적</div><div class="line"># 상품                  # 상품</div><div class="line"># 계획연월              # 판매연월</div><div class="line"># 판매부서              # 판매채널</div><div class="line">* 계획수량              * 판매수량</div></pre></td></tr></table></figure>
<p>위와 같은 2개의 Table을 이용하여 월별로 각 상품의 계획 대비 판매 실적을 집계할려면 M:M 관계로 Join을 해야한다.<br>하지만 아래와 같이 무턱대로 Full Outer Join을 하면 잘못된 결과가 출력된다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> NVL(a.상품, b.상품)         상품,</div><div class="line">       NVL(a.계획연월, b.판매연월) 연월,</div><div class="line">       <span class="keyword">SUM</span>(계획수량)               계획,</div><div class="line">       <span class="keyword">SUM</span>(판매수량)               판매</div><div class="line">  <span class="keyword">FROM</span> 부서별판매계획 a <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> 채널별판매실적 b</div><div class="line">       <span class="keyword">ON</span>  a.상품 = b.상품</div><div class="line">       <span class="keyword">AND</span> a.계획연월 = b.판매연월</div><div class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> NVL(a.상품, b.상품)   , NVL(a.계획연월, b.판매연월)</div><div class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> NVL(a.상품, b.상품)   , NVL(a.계획연월, b.판매연월);</div></pre></td></tr></table></figure>
<p>어떤 잘못된 결과가 나오는지 SQL만 보고 판단이 가능한가 ?<br>예를 들어서 상품A, 201501 대해서 계획에서는 1개의 record가 있고, 판매에는 2개의 record가 있다면 SUM(계획수량)에는 계획수량 X 2 개의 값이 나온다.<br>만약 Join 조건에 판매부서, 판매채널도 포함시킨다면 위와 같은 문제없이 정상적으로 활용이 가능하다.  </p>
<p>그럼 판매부서를 Join조건에서 뺀 상태에서 동일 데이터가 2번 집계되지 않도록 하려면 어떻게 해야 할까 ?<br>그렇다면 미리 [상품 + 연월] 별로 GROUP BY 한 결과들로 Full Outer Join을 하면 된다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> NVL(a.상품, b.상품) 상품,</div><div class="line">       NVL(a.연월, b.연월) 연월,</div><div class="line">       <span class="keyword">SUM</span>(계획) 계획,</div><div class="line">       <span class="keyword">SUM</span>(판매) 판매</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> 상품, 계획연월 연월, <span class="keyword">SUM</span>(계획수량) 계획</div><div class="line">          <span class="keyword">FROM</span> 부서별판매계획 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 상품, 계획연월) a</div><div class="line">       <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></div><div class="line">       (<span class="keyword">SELECT</span> 상품, 판매연월 연월, <span class="keyword">SUM</span>(판매수량) 판매</div><div class="line">          <span class="keyword">FROM</span> 채널별판매실적 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 상품, 판매연월) b</div><div class="line">       <span class="keyword">ON</span> a.상품 = b.상품</div><div class="line">      <span class="keyword">AND</span> a.연월 = b.연월</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> NVL(a.상품, b.상품), NVL(a.연월, b.연월)</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NVL(a.상품, b.상품), NVL(a.연월, b.연월);</div></pre></td></tr></table></figure>
<p>원하는대로 출력된다.<br>책에는 Execute Plan이 비효율적이라고 나왔다는데, Oracle 11g에서는 별로 비효율적이지 않았다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMZER=ALL_ROWS</div><div class="line">    SORT (GROUP BY)</div><div class="line">        VIEW OF &apos;임시&apos; (VIEW)</div><div class="line">            HASH JOIN (FULL OUTER)</div><div class="line">                VIEW</div><div class="line">                    HASH</div><div class="line">                        TABLE ACCESS (FULL) OF &apos;채널별판매실적&apos; (TABLE)</div><div class="line">                VIEW</div><div class="line">                    HASH</div><div class="line">                        TABLE ACCESS (FULL) OF &apos;부서별판매계획&apos; (TABLE)</div></pre></td></tr></table></figure>
<p>전형적인 Hash Join의 Execute Plan이다.<br>위와 같은 SQL문 보다는 UNION ALL일 이용하면 더 간단히 구현이 가능하다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> 상품, 연월, <span class="keyword">SUM</span>(계획) 계획, <span class="keyword">SUM</span>(판매) 판매</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> 상품, 계획연월 연월, <span class="keyword">SUM</span>(계획수량) 계획, <span class="literal">NULL</span> 판매</div><div class="line">          <span class="keyword">FROM</span> 부서별판매계획 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 상품, 계획연월</div><div class="line">         <span class="keyword">UNION</span> ALL</div><div class="line">        <span class="keyword">SELECT</span> 상품, 판매연월, <span class="literal">NULL</span>, <span class="keyword">SUM</span>(판매수량)</div><div class="line">          <span class="keyword">FROM</span> 채널별판매실적 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 상품, 판매연월)</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> 상품, 연월</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> 상품, 연월;</div></pre></td></tr></table></figure>
<p>실행계획도 보면 Hash Join이 아닌 UNION ALL로 바뀌었다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMIZER=ALL_ROWS</div><div class="line">    SORT (GROUP BY)</div><div class="line">        VIEW</div><div class="line">            UNION-ALL</div><div class="line">                HASH (GROUP BY)</div><div class="line">                    TABLE ACCESS (FULL) OF &apos;부서별판매계획&apos; (TABLE)</div><div class="line">                HASH (GROUP BY)</div><div class="line">                    TABLE ACCESS (FULL) OF &apos;채널별판매실적&apos; (TABLE)</div></pre></td></tr></table></figure></p>
<h4 id="5-1-4-Paging-처리"><a href="#5-1-4-Paging-처리" class="headerlink" title="5.1.4 Paging 처리"></a>5.1.4 Paging 처리</h4><p>Webpage에서 게시판을 보여줄 경우 한번에 모든 목록을 다 보여주지않고, Page 단위로 끊어서 목록을 보여준다.<br>이럴 경우 Paging 처리를 해주지 않고, 무조건적으로 읽은 다음 FETCH로 넘기디가 필요한 만큼만 보여주고 끝내는 방식으로 구현했다가는 DB에 엄청난 부하가 걸린다.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BBS</div><div class="line"># Catalog</div><div class="line"># num</div><div class="line">* RegDate</div><div class="line">* Title</div><div class="line">* Description</div><div class="line">* Writer</div></pre></td></tr></table></figure>
<p>위와 같이 게시판을 관리하는 Table이 있는 경우 Paging 처리는 다음과 같이 하면 된다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">ROWNUM</span> <span class="keyword">no</span>, <span class="keyword">num</span>, title,</div><div class="line">               <span class="keyword">COUNT</span>(*) <span class="keyword">OVER</span> () CNT                                       <span class="comment">-- #1   </span></div><div class="line">          <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">num</span>, title                                 </div><div class="line">                  <span class="keyword">FROM</span> bbs</div><div class="line">                 <span class="keyword">WHERE</span> RegDate &gt;= :dt</div><div class="line">                   <span class="keyword">AND</span> <span class="keyword">Catalog</span> = :cat</div><div class="line">                 <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>)</div><div class="line">         <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt;= :page * :pageSize + <span class="number">1</span>)                           <span class="comment">-- #2  </span></div><div class="line">  <span class="keyword">WHERE</span> <span class="keyword">no</span> <span class="keyword">BETWEEN</span> (:page - <span class="number">1</span>) * :pagesize + <span class="number">1</span> <span class="keyword">AND</span> :pageSize * :page;     <span class="comment">-- #3</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT Optimizer=ALL_ROWS</div><div class="line">    VIEW</div><div class="line">        WINDOW (BUFFER)</div><div class="line">            COUNT (STOPKEY)</div><div class="line">                VIEW</div><div class="line">                    TABLE ACCESS (BY INDEX ROWID) OF &apos;BBS&apos; (TABLE)</div><div class="line">                        INDEX (RANGE SCAN) OF &apos;BBS_PK&apos; (INDEX (UNIQUE))</div></pre></td></tr></table></figure>
<ul>
<li>#1 : 다음 page에 데이터가 있는지 확인할 용도이다. 가장 안쪽 Inline View의 record 수가 return 된다. 이 값을 no값과 비교해서 더 크다면 다음 page에 출력할 값이 있다고 판단 할 수 있다.</li>
<li>#2 : List의 첫 page 부터 현재 page까지의 데이터를 출력한다. 사실 비효율적이긴 하다. (index + first_rows(n)을 활용해서 부분범위 처리해야 한다.)</li>
<li>#3 : 현재 page에 보여줄 내용만 걸러낸다.</li>
</ul>
<p>성능과 I/O효율을 위해서는 num의 index가 필요하다. 그러면 sort 작업을 수행하지 않아도 되며, first_rows(N) Hint를 활용해서 부분범위 처리를 유도할수도 있다.  </p>
<p>위 예제는 1 page만 볼때는 괜찮은데, 다음 page 조회를 자주 할 경우에는 비효율적이다.<br>매번 보여줄 필요가 없는 앞 page들의 데이터를 다 읽어와야 한다.<br>다음 page 버튼을 눌렀을때의 SQL문은 간단히 구현이 가능하다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">num</span>, title</div><div class="line">  <span class="keyword">FROM</span> bbs</div><div class="line"> <span class="keyword">WHERE</span> <span class="keyword">Catalog</span> = :cat</div><div class="line">   <span class="keyword">AND</span> <span class="keyword">num</span> &lt; :<span class="keyword">no</span>            <span class="comment">-- 현재 page의 마지막 num값</span></div><div class="line">   <span class="keyword">AND</span> <span class="keyword">rownum</span> &lt;= :pageSize</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure>
<p>위 SQL이 맞게 보일수도 있다. 더군다가 읽은 데이터도 딱 한 page에 보여줄 만큼만 읽었다.<br>하지만, Index가 어떻게 설정되어 있냐에 따라 다른 값이 나올 수 있다.<br>이 경우에는 성능보다는 어떤 상황에서도 정확한 값이 나오는게 더 중요하기 때문에 아래와 같이 Inline View로 처리를 해주어야 안전하다.  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">num</span>, title</div><div class="line">         <span class="keyword">FROM</span> bbs</div><div class="line">        <span class="keyword">WHERE</span> <span class="keyword">Catalog</span> = :cat</div><div class="line">          <span class="keyword">AND</span> <span class="keyword">num</span> &lt; :<span class="keyword">no</span>        <span class="comment">-- 현재 page의 마지막 num값</span></div><div class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>)</div><div class="line"> <span class="keyword">WHERE</span> <span class="keyword">rownum</span> &lt;= :pageSize</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT Optimzer=ALL_ROWS</div><div class="line">    COUNT (STOPKEY)</div><div class="line">        VIEW</div><div class="line">            TABLE ACCESS (BY INDEX ROWID) OF &apos;BBS&apos; (TABLE)</div><div class="line">                INDEX (RANGE SCAN DESCENDING) OF &apos;BBS_PK&apos; (INDEX (UNIQUE))</div></pre></td></tr></table></figure>
<p>그럼 이전 page는 ???</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">num</span>, title</div><div class="line">          <span class="keyword">FROM</span> bbs</div><div class="line">         <span class="keyword">WHERE</span> <span class="keyword">Catalog</span> = :cat</div><div class="line">           <span class="keyword">AND</span> <span class="keyword">num</span> &gt; :<span class="keyword">no</span>            <span class="comment">-- 현재 page의 첫번째 num값</span></div><div class="line">           <span class="keyword">AND</span> <span class="keyword">rownum</span> &lt;= :pageSize</div><div class="line">         <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>)</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure>
<p>이 경우에는 rownum 비교를 Inline View 안으로 넣어서 읽는 데이터 수를 줄였다.<br>이건 index 구성과 화면에 보여주는 data의 순서를 생각해서 다음 page, 이전 page 둘 중 하나는 안에 넣는게 가능하다.<br>다음 page의 SQL문 같이 밖으로 빼도 결과는 똑같다.  </p>
<p>그럼 다음 page 와 이전 page를 하나의 SQL문으로 묶을순 없을까 ?<br>UNION ALL을 이용하면 된다.<br>어느 버튼을 눌렀는지에 대한 조건만 추가를 해주면 된다.<br>만약 다음 page를 눌렀을때 ‘N’을 전달하고, 이전 page를 눌렀을때 ‘P’를 전달하다고 하면 다음과 같이 작성이 가능하다.  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">num</span>, title</div><div class="line"> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">num</span>, title</div><div class="line">         <span class="keyword">FROM</span> bbs</div><div class="line">        <span class="keyword">WHERE</span> <span class="string">'N'</span> = :btn</div><div class="line">          <span class="keyword">AND</span> <span class="keyword">Catalog</span> = :cat</div><div class="line">          <span class="keyword">AND</span> <span class="keyword">num</span> &lt; :<span class="keyword">no</span></div><div class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>)</div><div class="line"> <span class="keyword">WHERE</span> <span class="keyword">rownum</span> &lt;= :pageSize</div><div class="line"> <span class="keyword">UNION</span> ALL               </div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">num</span>, title</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">num</span>, title</div><div class="line">          <span class="keyword">FROM</span> bbs</div><div class="line">         <span class="keyword">WHERE</span> <span class="string">'P'</span> = :btn</div><div class="line">          <span class="keyword">AND</span> <span class="keyword">Catalog</span> = :cat</div><div class="line">           <span class="keyword">AND</span> <span class="keyword">num</span> &gt; :<span class="keyword">no</span></div><div class="line">           <span class="keyword">AND</span> <span class="keyword">rownum</span> &lt;= :pageSize</div><div class="line">         <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>)</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure>
<p>얼핏 생각하면 아래,위의 Inline View를 UNION ALL로 하고 겉에 SELECT로 씌우는게 가능할것 같지만, 안된다.<br>겉의 SELECT까지 해야 원하는 데이터가 순서래도 출력되기 때문이다.  </p>
<h4 id="5-1-5-Window-함수-활용"><a href="#5-1-5-Window-함수-활용" class="headerlink" title="5.1.5 Window 함수 활용"></a>5.1.5 Window 함수 활용</h4><p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/04.01.onesql.01.png?raw=true"></p>
<p>왼쪽 그럼과 같이 저장되어 있는 Table에서 오른쪽과 같은 형태로 출력하고 싶을 때 Query를 어떻게 만들어야 할까 ?</p>
<ol>
<li>먼저 STATUS 값이 NULL이면 자신보다 이전 값중에 NULL이 아닌 최근값을 찾아야 하는데… (이 부분에서 Sub-query로 한겹)</li>
<li>그러기 위해서는 STATUS가 NULL이 아닌 최근값의 SN을 구해야 한다. (이 부분에서 다시 Sub-query)</li>
</ol>
<p>즉 다음과 같은 Query를 작성해야 한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> a.SN,</div><div class="line">       NVL(a.STATUS, (<span class="keyword">SELECT</span> b.STATUS</div><div class="line">                        <span class="keyword">FROM</span> EQ_MES b</div><div class="line">                       <span class="keyword">WHERE</span> b.SN  = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(SN)</div><div class="line">                                        <span class="keyword">FROM</span> EQ_MES c</div><div class="line">                                       <span class="keyword">WHERE</span> c.SN &lt; a.SN</div><div class="line">                                         <span class="keyword">AND</span> c.STATUS <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>))) <span class="keyword">STATUS</span>,</div><div class="line">       a.VALUE</div><div class="line">  <span class="keyword">FROM</span> EQ_MES a;</div></pre></td></tr></table></figure>
<p>SN에 PK가 설정되어 있다는 가정하에서 생각해보면,</p>
<ol>
<li>가장 안쪽의 Sub-query에서 MAX(SN)을 구하기 위해서 INDEX RANGE SCAN</li>
<li>해당 SN값으로 b.STATUS값을 구하기 위해서 INDEX UNIQUE SCAN</li>
<li>위 1,2 과정을 모든 레코드 별로 1번씩 수행. 필터링 캐시 ? 입력값이 늘 다르므로 의미없음</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STATEMENT</span> OPTIMIZER=ALL_ROWS</div><div class="line">    <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">BY</span> <span class="keyword">INDEX</span> <span class="keyword">ROWID</span>) <span class="keyword">OF</span> <span class="string">'EQ_MES'</span> (<span class="keyword">TABLE</span>)</div><div class="line">        <span class="keyword">INDEX</span> (<span class="keyword">UNIQUE</span> <span class="keyword">SCAN</span>) <span class="keyword">OF</span> <span class="string">'EQ_MES_PK'</span> (<span class="keyword">INDEX</span> (<span class="keyword">UNIQUE</span>))</div><div class="line">            <span class="keyword">SORT</span> (<span class="keyword">AGGREGATE</span>)</div><div class="line">                <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">BY</span> <span class="keyword">INDEX</span> <span class="keyword">ROWID</span>) <span class="keyword">OF</span> <span class="string">`EQ_MES`</span> (<span class="keyword">TABLE</span>)</div><div class="line">                    <span class="keyword">INDEX</span> (<span class="keyword">RANGE</span> <span class="keyword">SCAN</span>) <span class="keyword">OF</span> <span class="string">`EQ_MES_PK`</span> (<span class="keyword">INDEX</span> (<span class="keyword">UNIQUE</span>))</div><div class="line">    <span class="keyword">TABLE</span> <span class="keyword">ACCESS</span> (<span class="keyword">FULL</span>) <span class="keyword">OF</span> <span class="string">`EQ_MES`</span> (<span class="keyword">TABLE</span>)</div></pre></td></tr></table></figure>
<p>SN에 PK가 설정되어 있으면 그냥 간단하게 index를 활용하여 NULL이 아닌 첫번째 값을 가져오게끔도 가능하다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> a.SN,</div><div class="line">       NVL(a.STATUS, (<span class="keyword">SELECT</span> <span class="comment">/*+ index_desc(b EQ_MES_PK) */</span> b.STATUS</div><div class="line">                        <span class="keyword">FROM</span> EQ_MES b</div><div class="line">                       <span class="keyword">WHERE</span> b.SN  &lt; a.SN</div><div class="line">                         <span class="keyword">AND</span> b.STATUS <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">                         <span class="keyword">AND</span> <span class="keyword">ROWNUM</span> &lt;= <span class="number">1</span>)) <span class="keyword">STATUS</span>,</div><div class="line">       a.VALUE</div><div class="line">  <span class="keyword">FROM</span> EQ_MES a;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMIZER=ALL_ROWS</div><div class="line">    COUNT (STOPKEY)</div><div class="line">        TABLE ACCESS (BY INDEX ROWID) OF `EQ_MES` (TABLE)</div><div class="line">            INDEX (RANGE SCAN DESCENDING) OF EQ_MES_PK` (INDEX (UNIQUE))</div><div class="line">    TABLE ACCESS (FULL) OF `EQ_MES` (TABLE)</div></pre></td></tr></table></figure>
<p>앞에서 배운 Window 함수를 이용하면 쉽게 해결이 가능하다.</p>
<ul>
<li>LAST_VALUE : Partition 내에서 가장 마지막 값을 출력</li>
</ul>
<p><code>IGNORE NULLS</code> 옵션을 사용해서 바로 가져 올 수가 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> SN,</div><div class="line">       <span class="keyword">LAST_VALUE</span>(<span class="keyword">STATUS</span> <span class="keyword">IGNORE</span> <span class="keyword">NULLS</span>) <span class="keyword">OVER</span></div><div class="line">           (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SN <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span>) <span class="keyword">STATUS</span>,</div><div class="line">       <span class="keyword">VALUE</span></div><div class="line">  <span class="keyword">FROM</span> EQ_MES</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SN;</div></pre></td></tr></table></figure>
<ul>
<li>IGNORE NULLS : NULL값은 무시하고 마지막값을 가져옴</li>
<li>PARTITION 은 여기서 지정하지 않았음</li>
<li>ORDER BY SN : SN 순으로 정렬</li>
<li>BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW : 검색 RANGE를 이전의 모든 데이터에서 현재까지</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMIZER=ALL_ROWS</div><div class="line">    WINDOW(SORT)</div><div class="line">        TABLE ACCESS (FULL) OF `EQ_MES` (TABLE)</div></pre></td></tr></table></figure>
<h4 id="5-1-6-WITH-활용"><a href="#5-1-6-WITH-활용" class="headerlink" title="5.1.6 WITH 활용"></a>5.1.6 WITH 활용</h4><p>PL/SQL 에서 내부적으로 임시 테이블을 생성하여 재활용이 가능하다.  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WITH 임시테이블명</div><div class="line">AS</div><div class="line">(<span class="keyword">SELECT</span> ... )</div></pre></td></tr></table></figure>
<p>로 선언을 해두고 재활용이 가능하다.<br>하지만 이것을 활용한 성능향상은 Oracle (9i이후)만 가능하다.<br>MS-SQL은 Inline 방식으로 항상 해당 Query를 새로 실행한다.<br>Oracle은 <code>materialize</code>, <code>inline</code> Hint를 활용하여 임시 테이블로 결과를 저장하고 재사용할 것인지, View같이 항상 새로 실행한 것인지의 선택이 가능하다.</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/02/09/04.01.onesql/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/07/03.07.join.adv/">
                            SQLP 3-4-3 고급 Join 기법
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-02-07T00:00:00+09:00">
	
		    Feb 07, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="3과목-SQL-고급-활용-및-Tuning"><a href="#3과목-SQL-고급-활용-및-Tuning" class="headerlink" title="3과목 SQL 고급 활용 및 Tuning"></a>3과목 SQL 고급 활용 및 Tuning</h1><h2 id="4장-Index와-Join"><a href="#4장-Index와-Join" class="headerlink" title="4장 Index와 Join"></a>4장 Index와 Join</h2><h3 id="4-4-고급-Join-기법"><a href="#4-4-고급-Join-기법" class="headerlink" title="4.4 고급 Join 기법"></a>4.4 고급 Join 기법</h3><h4 id="Inline-View-활용"><a href="#Inline-View-활용" class="headerlink" title="Inline View 활용"></a>Inline View 활용</h4><p>대부분의 JOIN은 1:M 관계이다.<br>M쪽 집합을 1쪽 집합 단위로 Grouping해야 한다면 미리 Grouping한 뒤 JOIN하는 것이 유리하다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(b.상품명) 상품명, <span class="keyword">SUM</span>(a.판매수량) 판매수량, <span class="keyword">SUM</span>(a.판매금액) 판매금액</div><div class="line">  <span class="keyword">FROM</span> 일병상품판매 a, 상품 b</div><div class="line"> <span class="keyword">WHERE</span> a.상품코드 = b.상품코드</div><div class="line">   <span class="keyword">AND</span> a.판매일자 <span class="keyword">BETWEEN</span> <span class="string">'20090101'</span> <span class="keyword">AND</span> <span class="string">'20091231'</span></div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> b.상품코드;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMIZER=ALL_ROWS</div><div class="line">    SORT GROUP BY</div><div class="line">        NESTED LOOPS</div><div class="line">            TABLE ACCESS FULL 일별상품판매 (Table)</div><div class="line">            TABLE ACCESS BY INDEX ROWID 상품 (Table)</div><div class="line">                INDEX UNIQUE SCAN 상품_PK (Index)</div></pre></td></tr></table></figure>
<p>위 상황에서 일별상품판매에서 조건에 맞는 모든 record에 대해서 상품 과 JOIN을 수행한 후에 마지막에 SORT GROUP BY를 수행하였다.<br>미리 상품코드 별로 GROUP BY를 한 후에 JOIN을 하는 것으로 수정해 보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> b.상품명, a.판매수량, a.판매금액</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> 상품코드, <span class="keyword">SUM</span>(판매수량) 판매수량, <span class="keyword">SUM</span>(판매금액) 판매금액</div><div class="line">          <span class="keyword">FROM</span> 일별상품판매</div><div class="line">         <span class="keyword">WHERE</span> 판매일자 <span class="keyword">BETWEEN</span> <span class="string">'20090101'</span> <span class="keyword">AND</span> <span class="string">'20091231'</span></div><div class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> 상품코드) a, 상품 b</div><div class="line"> <span class="keyword">WHERE</span> a.상품코드 = b.상품코드;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMIZER=ALL_ROWS</div><div class="line">    NESTED LOOPS</div><div class="line">        VIEW</div><div class="line">            SORT GROUP BY</div><div class="line">                TABLE ACCESS FULL 일별상품판매 (Table)</div><div class="line">        TABLE ACCESS BY INDEX ROWID 상품 (Table)</div><div class="line">            INDEX UNIQUE SCAN 상품_PK (Index)</div></pre></td></tr></table></figure>
<h4 id="베타적-관계의-JOIN"><a href="#베타적-관계의-JOIN" class="headerlink" title="베타적 관계의 JOIN"></a>베타적 관계의 JOIN</h4><ul>
<li><p>상호배타적 관계란 ?</p>
<ul>
<li>어떤 엔터티가 두 개 이상의 다른 엔터티의 합집합과 관계를 갖는 것</li>
<li>e.g. 작업지시 Table의 작업일련번호 가 개통신청 Table의 개통신청번호 와도 관계를 가지고, 장애접수 Table의 장애접수번호 와도 관계를 가지는 경우</li>
<li>이 경우 3가지로 구현이 가능하다.<ol>
<li>작업일련번호 1개의 컬럼으로 2개의 Table로 연결하여 관련있는 레코드만 각 테이블에 입력 (#1)</li>
<li>개통신청번호, 장애접수번호 두 칼럼을 따로 두고 각 레코드별로 둘 중 하나에만 값을 입력 (#2)</li>
<li>접수번호 와 작업구분 칼럽을 두고 작업구분의 값으로 개통신청, 장애접수를 구분 (#3)</li>
</ol>
</li>
</ul>
</li>
<li><p>예제 SQL (#1)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ordered use_nl(b) use_nl(c) */</span></div><div class="line">       a.작업일련번호, a.작업자<span class="keyword">ID</span>,</div><div class="line">       NVL(b.고객번호, c.고객번호) 고객번호,</div><div class="line">       NVL(b.주소, c.주소) 주소</div><div class="line">  <span class="keyword">FROM</span> 작업지시 a, 개통신청 b, 장애접수 c</div><div class="line"> <span class="keyword">WHERE</span> a.작업일련번호 = b.작업지시번호(+)</div><div class="line">   <span class="keyword">AND</span> a.작업일련번호 = c.장애접수번호(+)</div><div class="line">   <span class="keyword">AND</span> a.접수일자 <span class="keyword">BETWEEN</span> :fromDate <span class="keyword">AND</span> :toDate;</div></pre></td></tr></table></figure>
</li>
<li><p>예제 SQL (#2)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ordered use_nl(b) use_nl(c) */</span></div><div class="line">       NVL(a.개통신청번호, b.장애접수번호) 작업일련번호,</div><div class="line">       a.작업자<span class="keyword">ID</span>,</div><div class="line">       <span class="keyword">DECODE</span>(a.개통신청번호, <span class="literal">NULL</span>, c.고객번호, b.고객번호) 고객번호,</div><div class="line">       <span class="keyword">DECODE</span>(a.개통신청번호, <span class="literal">NULL</span>, c.주소, b.주소) 주소</div><div class="line">  <span class="keyword">FROM</span> 작업지시 a, 개통신청 b, 장애접수 c</div><div class="line"> <span class="keyword">WHERE</span> a.개통신청번호 = b.개통신청번호(+)</div><div class="line">   <span class="keyword">AND</span> a.장애접수번호 = c.장애접수번호(+)</div><div class="line">   <span class="keyword">AND</span> a.접수일자 <span class="keyword">BETWEEN</span> :fromDate <span class="keyword">AND</span> :toDate;</div><div class="line"></div><div class="line"><span class="comment">-- 위의 경우 필요없는 JOIN 시도 횟수가 많아지기 때문에 2가지 경우를 나누어서 UNION ALL하는게 효율이 좋다.</span></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> a.개통신청번호 작업일련번호,</div><div class="line">       a.작업자<span class="keyword">ID</span>, b.고객번호, b.주소</div><div class="line">  <span class="keyword">FROM</span> 작업지시 a, 개통신청 b</div><div class="line"> <span class="keyword">WHERE</span> a.개통신청번호 = b.개통신청번호</div><div class="line">   <span class="keyword">AND</span> a.개통신청번호 <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">   <span class="keyword">AND</span> a.접수일자 <span class="keyword">BETWEEN</span> :fromDate <span class="keyword">AND</span> :toDate</div><div class="line"> <span class="keyword">UNION</span> ALL</div><div class="line"><span class="keyword">SELECT</span> a.장애접수번호 작업일련번호,</div><div class="line">       a.작업자<span class="keyword">ID</span>, b.고객번호, b.주소</div><div class="line">  <span class="keyword">FROM</span> 작업지시 a, 장애접수 b</div><div class="line"> <span class="keyword">WHERE</span> a.장애접수번호 = b.장애접수번호</div><div class="line">   <span class="keyword">AND</span> a.장애접수번호 <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">   <span class="keyword">AND</span> a.접수일자 <span class="keyword">BETWEEN</span> :fromDate <span class="keyword">AND</span> :toDate</div></pre></td></tr></table></figure>
</li>
<li><p>예제 SQL (#3)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> a.작업일련번호,</div><div class="line">       a.작업자<span class="keyword">ID</span>, b.고객번호, b.주소</div><div class="line">  <span class="keyword">FROM</span> 작업지시 a, 개통신청 b</div><div class="line"> <span class="keyword">WHERE</span> a.작업일련번호 = b.개통신청번호</div><div class="line">   <span class="keyword">AND</span> a.작업구분 = <span class="number">1</span></div><div class="line">   <span class="keyword">AND</span> a.접수일자 <span class="keyword">BETWEEN</span> :fromDate <span class="keyword">AND</span> :toDate</div><div class="line"> <span class="keyword">UNION</span> ALL</div><div class="line"><span class="keyword">SELECT</span> a.작업일련번호,</div><div class="line">       a.작업자<span class="keyword">ID</span>, b.고객번호, b.주소</div><div class="line">  <span class="keyword">FROM</span> 작업지시 a, 장애접수 b</div><div class="line"> <span class="keyword">WHERE</span> a.작업일련번호 = b.장애접수번호</div><div class="line">   <span class="keyword">AND</span> a.작업구분 = <span class="number">2</span></div><div class="line">   <span class="keyword">AND</span> a.접수일자 <span class="keyword">BETWEEN</span> :fromDate <span class="keyword">AND</span> :toDate</div></pre></td></tr></table></figure>
</li>
</ul>
<p>마지막 예제의 경우 Index가 [작업구분 + 접수일자]로 구성되었다면 읽는 범위의 중복이 없겠지만,<br>[접수일자 + 작업구분]일 경우 중복해서 읽어야 하며,<br>[접수일자]만으로 구성된 Index를 사용한다면 작업구분을 필터링하기위해 Random 액세스까지 중복으로 발생한다.<br>그럴 경우 아래와 같이 수정을 하면 중복 액세스의 비효율을 해소할 수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ordered use_nl(b) use_nl(c) */</span></div><div class="line">       a.작업일련번호, a.작업자<span class="keyword">ID</span>,</div><div class="line">       NVL(b.고객번호, c.고객번호) 고객번호,</div><div class="line">       NVL(b.주소, c.주소) 주소</div><div class="line">  <span class="keyword">FROM</span> 작업지시 a, 개통신청 b, 장애접수 c</div><div class="line"> <span class="keyword">WHERE</span> b.개통신청번호(+) = <span class="keyword">DECODE</span>(a.작업구분, <span class="number">1</span>,a.작업일련번호)</div><div class="line">   <span class="keyword">AND</span> c.장애접수번호(+) = <span class="keyword">DECODE</span>(a.작업구분, <span class="number">2</span>,a.작업일련번호)</div><div class="line">   <span class="keyword">AND</span> a.접수일자 <span class="keyword">BETWEEN</span> :fromDate <span class="keyword">AND</span> :toDate;</div></pre></td></tr></table></figure>
<h4 id="부등호-JOIN"><a href="#부등호-JOIN" class="headerlink" title="부등호 JOIN"></a>부등호 JOIN</h4><p>‘=’ 조건이 아닌 BETWEEN, LIKE 등과 같은 부등호 연산과 JOIN해야 할 때도 있다.</p>
<p>아래 그림의 왼쪽 그림과 같은 월별지점매출 Table을 이용하여 오른쪽 그림의 누적매출을 구해보자.</p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/03.07.sql.adv.01.png?raw=true"></p>
<p>Oracle의 Window 함수를 이용하면 간단하다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> 지점, 판매월, 매출,</div><div class="line">       <span class="keyword">SUM</span>(매출) <span class="keyword">OVER</span></div><div class="line">           (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 지점 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 판매월</div><div class="line">            <span class="keyword">RANGE</span> <span class="keyword">BETWEEN</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span>) 누적매출</div><div class="line">  <span class="keyword">FROM</span> 월별지점매출</div></pre></td></tr></table></figure></p>
<p>Window 함수를 사용하지 않고 BETWEEN을 JOIN조건으로 넣어서도 가능하다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> a.지점, a.판매월, <span class="keyword">MIN</span>(a.매출) 매출, <span class="keyword">SUM</span>(b.매출) 누적매출</div><div class="line">  <span class="keyword">FROM</span> 월별지점매출 a, 월별지점매출 b</div><div class="line"> <span class="keyword">WHERE</span> a.지점 = b.지점</div><div class="line">   <span class="keyword">AND</span> a.판매월 &gt;= b.판매월</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.지점, a.판매월</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.지점, a.판매월</div></pre></td></tr></table></figure></p>
<h4 id="BETWEEN-JOIN"><a href="#BETWEEN-JOIN" class="headerlink" title="BETWEEN JOIN"></a>BETWEEN JOIN</h4><ul>
<li>이력관리 방식<ul>
<li>선분이력<ul>
<li>시작일자, 종료일자 형식으로 2개의 일자 컬럼으로 이력을 관리</li>
<li>특정시점 이력을 조회할때 BETWEEN 조건으로 간편하게 가능<ul>
<li><code>:dt BETWEEN 시작일자 AND 종료일자</code></li>
<li>현재시점 : <code>종료일자 = &#39;99991231&#39;</code></li>
</ul>
</li>
<li>PK값 변경이 자주 발생함<ul>
<li>PK를 [Master Key + 시작일자 + 종료일자]로 관리해야 하는데, 새로운 이력이 들어오면 기존의 마지막 종료일자가 변경되어야 함</li>
</ul>
</li>
</ul>
</li>
<li>점이력<ul>
<li>주로 시작일자만을 저장하여 관리</li>
<li>특정시점 이력을 조회할때 Subquery를 이용하여 그 시점의 마지막 이력일자를 먼저 구한뒤에 조회</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 선분이력으로 관리할때의 특정시점 조회</span></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> 고객번호, 연체금액, 연체기간</div><div class="line">  <span class="keyword">FROM</span> 고객별연체금액</div><div class="line"> <span class="keyword">WHERE</span> 고객번호 = :<span class="keyword">no</span></div><div class="line">   <span class="keyword">AND</span> :<span class="built_in">date</span> <span class="keyword">BETWEEN</span> 시작일자 <span class="keyword">AND</span> 종료일자;</div><div class="line"></div><div class="line"><span class="comment">-- 점이력</span></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> a.고객번호, a.연체금액, a.연체기간</div><div class="line">  <span class="keyword">FROM</span> 고객별연체금액 a,</div><div class="line">       (<span class="keyword">SELECT</span> 고객번호, <span class="keyword">MAX</span>(a.시작일자) 시작일자</div><div class="line">          <span class="keyword">FROM</span> 고객별연체금액</div><div class="line">         <span class="keyword">WHERE</span> 고객번호 = :<span class="keyword">no</span></div><div class="line">           <span class="keyword">AND</span> 시작일자 &lt;= :<span class="built_in">date</span>) b</div><div class="line"> <span class="keyword">WHERE</span> a.고객번호 = b.고객번호</div><div class="line">   <span class="keyword">AND</span> a.시작일자 = b.시작일자;</div><div class="line"></div><div class="line"><span class="comment">-- 또는 체크조건으로</span></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> a.고객번호, a.연체금액, a.연체기간</div><div class="line">  <span class="keyword">FROM</span> 고객별연체금액 a</div><div class="line"> <span class="keyword">WHERE</span> a.고객번호 = :<span class="keyword">no</span></div><div class="line">   <span class="keyword">AND</span> a.시작일자 = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(b.시작일자) <span class="keyword">FROM</span> 고객별연체금액 b</div><div class="line">                      <span class="keyword">WHERE</span> a.고객번호 = b.고객번호</div><div class="line">                        <span class="keyword">AND</span> b.시작일자 &lt;= :<span class="built_in">date</span>);</div></pre></td></tr></table></figure>
<ul>
<li>선분이력 JOIN<ul>
<li>고객 Table, 등급변경이력 Table, 전화번호변경이력 Table이 있고, 각각의 이력Table에서 선분이력으로 관리하고 있는 경우 특정시점의 등급과 전화번호를 조회할 경우</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> a.고객명, b.등급, c.전화번호</div><div class="line">  <span class="keyword">FROM</span> 고객 a, 등급변경이력 b, 전화번호이력 c</div><div class="line"> <span class="keyword">WHERE</span> a.고객<span class="keyword">ID</span> = :<span class="keyword">id</span></div><div class="line">   <span class="keyword">AND</span> a.고객<span class="keyword">ID</span> = b.고객<span class="keyword">ID</span></div><div class="line">   <span class="keyword">AND</span> a.고객<span class="keyword">ID</span> = c.고객<span class="keyword">ID</span></div><div class="line">   <span class="keyword">AND</span> :dt <span class="keyword">BETWEEN</span> b.시작일자 <span class="keyword">AND</span> b.종료일자</div><div class="line">   <span class="keyword">AND</span> :dt <span class="keyword">BETWEEN</span> c.시작일자 <span class="keyword">AND</span> c.종료일자;</div></pre></td></tr></table></figure>
<h4 id="점이력관리에서-ROWID-이용"><a href="#점이력관리에서-ROWID-이용" class="headerlink" title="점이력관리에서 ROWID 이용"></a>점이력관리에서 ROWID 이용</h4><ul>
<li>앞서 살펴본 점이력관리의 경우 동일한 Table을 2번 액세스해야 한다.<br>-<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> a.고객번호, a.연체금액, a.연체기간</div><div class="line">  <span class="keyword">FROM</span> 고객별연체금액 a</div><div class="line"> <span class="keyword">WHERE</span> a.고객번호 = :<span class="keyword">no</span></div><div class="line">   <span class="keyword">AND</span> a.시작일자 = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(b.시작일자) <span class="keyword">FROM</span> 고객별연체금액 b</div><div class="line">                      <span class="keyword">WHERE</span> a.고객번호 = b.고객번호</div><div class="line">                        <span class="keyword">AND</span> b.시작일자 &lt;= :<span class="built_in">date</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMIZER=ALL_ROWS</div><div class="line">    NESTED LOOPS</div><div class="line">        TABLE ACCESS (BY INDEX ROWID) OF &apos;고객별연체금액&apos;</div><div class="line">            INDEX (RANGE SCAN) OF &apos;IDX_고객별연체금액_고객_일자&apos; (NON-UNIQUE)</div><div class="line">        SORT</div><div class="line">            FIRST ROW</div><div class="line">                INDEX (RANGE SCAN (MIN/MAX) OF &apos;IDX_고객별연체금액_고객_일자&apos; (NON-UNIQUE)</div></pre></td></tr></table></figure>
<p>이 경우 Subquery에서 rowid를 구해서 Main Query로 전달해주면 조금 더 성능을 향상 시킬 수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> a.고객번호, a.연체금액, a.연체기간</div><div class="line">  <span class="keyword">FROM</span> 고객별연체금액 a</div><div class="line"> <span class="keyword">WHERE</span> a.고객번호 = :<span class="keyword">no</span></div><div class="line">   <span class="keyword">AND</span> a.rowid = (<span class="keyword">SELECT</span> <span class="comment">/*+ index_desc(b IDX_고객별연체금액_고객_일자) */</span> <span class="keyword">rowid</span></div><div class="line">                       <span class="keyword">FROM</span> 고객별연체금액 b</div><div class="line">                      <span class="keyword">WHERE</span> a.고객번호 = b.고객번호</div><div class="line">                        <span class="keyword">AND</span> b.시작일자 &lt;= :<span class="built_in">date</span></div><div class="line">                        <span class="keyword">AND</span> <span class="keyword">rownum</span> &lt;= <span class="number">1</span>);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMZER=ALL_ROWS</div><div class="line">    NESTED LOOPS</div><div class="line">        TABLE ACCESS (BY INDEX ROWID) OF &apos;고객별연체금액&apos;</div><div class="line">            INDEX (RANGE SCAN) OF &apos;IDX_고객별연체금액_고객_일자&apos; (NON-UNIQUE)</div><div class="line">        TABLE ACCESS (BY USER ROWID) OF &apos;고객별연체금액&apos;</div><div class="line">            COUNT (STOPKEY)</div><div class="line">                INDEX (RANGE SCAN) OF &apos;IDX_고객별연체금액_고객_일자&apos; (NON-UNIQUE)</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/02/07/03.07.join.adv/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/06/03.06.join/">
                            SQLP 3-4-2 Join
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-02-06T00:00:00+09:00">
	
		    Feb 06, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="3과목-SQL-고급-활용-및-Tuning"><a href="#3과목-SQL-고급-활용-및-Tuning" class="headerlink" title="3과목 SQL 고급 활용 및 Tuning"></a>3과목 SQL 고급 활용 및 Tuning</h1><h2 id="4장-Index와-Join"><a href="#4장-Index와-Join" class="headerlink" title="4장 Index와 Join"></a>4장 Index와 Join</h2><h3 id="4-3-JOIN"><a href="#4-3-JOIN" class="headerlink" title="4.3 JOIN"></a>4.3 JOIN</h3><h4 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested Loop Join"></a>Nested Loop Join</h4><ul>
<li><p>Index 상황</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* PK_DELP        : DEPT.DEPTNO</div><div class="line">* DEPT_LOC_IDX   : DEPT.LOC</div><div class="line">* PK_EMP         : EMP.EMPNO</div><div class="line">* EMP_DEPTNO_IDX : EMP.DEPTNO</div><div class="line">* EMP_SAL_IDX    : EMP.SAL</div></pre></td></tr></table></figure>
</li>
<li><p>Query</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ORDERED USE_NL(e) */</span> E.EMPNO, E.ENAME, D.DNAME, E.JOB, E.SAL</div><div class="line">  <span class="keyword">FROM</span> DEPT d, EMP e</div><div class="line"> <span class="keyword">WHERE</span> e.DEPTNO = d.DEPTNO    <span class="comment">-- #1</span></div><div class="line">   <span class="keyword">AND</span> d.LOC    = <span class="string">'DALLAS'</span>    <span class="comment">-- #2</span></div><div class="line">   <span class="keyword">AND</span> e.SAL   &gt;= <span class="number">1500</span>        <span class="comment">-- #3</span></div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>위의 경우 실행계획은 다음과 같다.</p>
<ul>
<li><p>Execution Plan</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMIZER = ALL_ROWS</div><div class="line">    SORT (ORDER BY)</div><div class="line">        NESTED LOOPS</div><div class="line">            NESTED LOOPS</div><div class="line">                TABLE ACCESS (BY INDEX ROWID) OF &apos;DEPT&apos; (TABLE)</div><div class="line">                    INDEX (RANGE SCAN) OF &apos;DEPT_LOC_IDX&apos; (INDEX)</div><div class="line">                INDEX (RANGE SCAN) OF &apos;EMP_DEPT_INDEX&apos; (INDEX)</div><div class="line">            TABLE ACCESS (BY INDEX ROWID) OF &apos;EMP&apos; (TABLE)</div></pre></td></tr></table></figure>
</li>
<li><p>순서를 살펴보면 다음과 같다.</p>
<ol>
<li><code>DEPT_LOC_IDX</code> Index를 이용하여 <code>LOC = &#39;DALLAS&#39;</code> 조건에 맞는 ROWID를 찾아낸다.</li>
<li>해당 ROWID를 이용하여 <code>DEPT</code> Table에서 record를 찾는다.</li>
<li>위 조건에 만족하는 Table의 DEPTNO 칼럼과 <code>EMP_DEPT_INDEX</code> Index의 DEPTNO 칼럼을 NL Join한다.</li>
<li>NL Join 결과에서의 <code>EMP_DEPT_INDEX</code>의 ROWID로 <code>EMP</code> Table을 액세스 해서 <code>SAL &gt;= 1500</code> 조건에 만족하는 record를 찾는다.</li>
<li>2번과 5번의 record를 NL Join 한다.</li>
<li>그 결과를 <code>SAL DESC</code> 기준으로 정렬한다.</li>
</ol>
</li>
<li><p>NL Join의 특징</p>
<ol>
<li>DBMS는 Block단위 I/O를 수행하는데, Random 액세스 하므로 아무리 Index 구성이 완벽해도 대량의 데이터를 JOIN하면 매우 비효율적이다.</li>
<li>record 단위로 순차적으로 JOIN을 수행하므로 대용량 데이터 처리시 매우 치명적이다.</li>
<li>하지만, 부분범위처리가 가능한 상황에서 최초의 응답시간은 매우 짧다.</li>
<li>순차적으로 처리되는 특징때문에 Driving Table의 처리 범위에 의해 전체 일량이 결정된다.</li>
<li>Index 구성 전략이 중요하다.</li>
<li>소량 데이터를 주로 처리하거나 부분범위처리가 가능한 온라인 트랜잭션 환경에 적합하다.</li>
</ol>
</li>
</ul>
<h4 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort Merge Join"></a>Sort Merge Join</h4><ul>
<li><p>진행 단계</p>
<ol>
<li>Sort : 양쪽 집합을 JOIN 컬럼 기준으로 정렬 (단, Oracle의 경우 Outer Table에 해당 컬럼에 대한 Index가 있다면 생략 가능)</li>
<li>Merge : 정렬된 양쪽 집합을 Merge</li>
</ol>
</li>
<li><p>SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ORDERED USE_MERGE(e) */</span> d.deptno, d.name, e.empno, e.ename</div><div class="line">  <span class="keyword">FROM</span> dept d, emp e</div><div class="line"> <span class="keyword">WHERE</span> d.deptno = e.deptno</div></pre></td></tr></table></figure>
</li>
<li><p>Execute Plan</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMIZER = ALL_ROWS</div><div class="line">    MERGE JOIN</div><div class="line">        TABLE ACCESS (BY INDEX ROWID) OF &apos;DEPT&apos; (TABLE)</div><div class="line">            INDEX (FULL SCAN) OF &apos;PK_DEPT&apos; (INDEX (UNIQUE))</div><div class="line">        SORT (JOIN)</div><div class="line">            TABLE ACCESS (FULL) OF &apos;EMP&apos; (TABLE)</div></pre></td></tr></table></figure>
</li>
<li><p>특징</p>
<ul>
<li>JOIN하기 전에 양쪽 집합을 정렬한다.<ul>
<li>대용량 Table의 경우 Sort자체가 큰 비용을 수반하기 때문에 비효율적일 수 있다.</li>
<li>하지만, Cluster나 Index처럼 미리 정렬된 오브젝트를 이용하면 효과적이다.</li>
</ul>
</li>
<li>부분적으로 부분범위 처리가 가능하다.<ul>
<li>Outer 집합이 미리 정렬된 상태에서 일부만 Fet하다 멈춘다면 Outer 집합은 끝까지 읽을 필요가 없다.</li>
</ul>
</li>
<li>Table별 검색 조건에 의해 전체 일량이 결정<ul>
<li>NL Join의 경우 Outer 집합에서 조인 대상이 되는 건수에 의해 좌우된다.</li>
<li>Sort Merge Join의 경우 각 집합의 크기, 즉 각 테이블별 검색 조건에 의해 좌우된다.</li>
</ul>
</li>
<li>Inner Table을 반복 액세스하지 않는다.</li>
</ul>
</li>
</ul>
<h4 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h4><ul>
<li><p>진행 단계</p>
<ol>
<li>둘 중 작은 집합(Build input)을 읽어 Hash Area에 Hash Map을 생성 (Hash Bucket으로 구성된 배열)</li>
<li>큰 집합(Probe Input)을 읽어 Hash Map을 탐색하면서 JOIN</li>
</ol>
</li>
<li><p>SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ORDERED USE_HASH(e) */</span> d.deptno, d.dname, e.empno, e.ename</div><div class="line">  <span class="keyword">FROM</span> dept d, emp e</div><div class="line"> <span class="keyword">WHERE</span> d.deptno = e.deptno</div></pre></td></tr></table></figure>
</li>
<li><p>Execute Plan</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT STATEMENT OPTIMIZER = ALL_ROWS</div><div class="line">  HASH JOIN</div><div class="line">      TABLE ACCESS (FULL) OF &apos;DEPT&apos; (TABLE)</div><div class="line">      TABLE ACCESS (FULL) OF &apos;EMP&apos;  (TABLE)</div></pre></td></tr></table></figure>
</li>
<li><p>특징</p>
<ul>
<li>NL Join처럼 Random 액세스 부하도 없으며, Sort Merge Join 처럼 Sort에 대한 부하도 없다.</li>
<li>Build Input의 크기가 작아야 효과적이다.</li>
<li>Hash Join 자체는 전체 Table을 다 읽어야 하지만, Probe Input을 Scan하는 단계는 NL Join처럼 부분범위처리가 가능하다.</li>
<li>Build Input이 Memory 공간을 초과하는 경우<ol>
<li>Partition 단계 : 양쪽 테이블 모두 Hash값에 따라 동적으로 파티셔닝</li>
<li>Join 단계 : 각 파티션별로 크기가 작은 쪽을 Build Input으로 큰 쪽을 Probe Input으로 해서 Hash Join 수행</li>
</ol>
<ul>
<li>Join 하기위해서는 Memory로 Load해야 하는데 그 과정에서 가용 Memory를 초과하면 계속해서 Recursive 하게 Partition 단계를 수행한다.</li>
</ul>
</li>
<li>Build Input의 Hash Key 중복이 많을 경우 비효율적이게 된다.<ul>
<li>Hash Bucket에서는 Sequential Scan을 해야 하므로 엔트리가 많아지면 그만큼 비효율적이다.</li>
</ul>
</li>
</ul>
</li>
<li><p>Hash Join 전략</p>
<ul>
<li>가장 극적으로 효과가 좋기 위한 조건<ul>
<li>한 쪽 Table이 가용 Memory에 담길 정도로 충분히 작아야 함</li>
<li>Build Input HashKey 칼럼의 중복 값이 거의 없어야 함</li>
</ul>
</li>
<li>다음과 같은 경우 Hash Join의 사용을 고려해 보아야 한다.<ul>
<li>Join 칼럼에 적당한 Index가 없어 NL Join이 비효율적일 때</li>
<li>Index가 있더라도 Driving 집합에서 Inner 쪽으로 Join 액세스가 많아 Random 액세스 부하가 심할 때</li>
<li>Sort Merge Join을 하기에 두 테이블이 너무 커 Sort 부하가 심할 때</li>
<li>수행빈도가 낮고 수행 시간이 오래 걸리는 대용량 Table Join 시<ul>
<li>Hash 결과는 일회용이다. (재사용이 안된다.)</li>
<li>수행빈도가 높은 작업을 Hash로 하면 메모리 확보를 위해 Latch 경합이 발생해 시스템 동시성을 떨어뜨릴 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Scalar-Subquery"><a href="#Scalar-Subquery" class="headerlink" title="Scalar Subquery"></a>Scalar Subquery</h4><ul>
<li>Scalar Subquery : 1개의 data (1 row 1 column)만 반환. SQL문 중 column이 위치할 수 있는 대부분의 곳에 사용 가능</li>
</ul>
<p>대부분의 Scalar Subquery는 Outer Join문으로 변경이 가능하다.  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> empno, ename, sal, hiredate,</div><div class="line">       (<span class="keyword">SELECT</span> d.dname <span class="keyword">FROM</span> dept d <span class="keyword">WHERE</span> d.deptno = e.deptno) dname</div><div class="line">  <span class="keyword">FROM</span> EMP e</div><div class="line"> <span class="keyword">WHERE</span> sal &gt;= <span class="number">2000</span>;</div><div class="line"></div><div class="line"> <span class="keyword">SELECT</span> empno, ename, sal, hiredate, dname</div><div class="line">   <span class="keyword">FROM</span> emp e, dept d</div><div class="line">  <span class="keyword">WHERE</span> e.deptno(+) = d.deptno</div><div class="line">    <span class="keyword">AND</span> sal &gt;= <span class="number">2000</span>;</div></pre></td></tr></table></figure>
<p>결과만 100% 같을 뿐 아니라 처리 경로도 동일하다.<br>하지만 Scarlar Subquery는 내부적으로 Caching 기법이 작용한다.</p>
<ul>
<li><p>Scarlar Subquery Cache</p>
<ul>
<li>Subquery의 입력값과 출력값을 Cache에 저장</li>
<li>Main Query에서 같은 입력값이 들어오면 캐시된 출력값을 리턴</li>
<li>Hash 알고리즘을 이용하여 찾기 때문에 입력값의 종류가 소수일 경우 더욱 효과적</li>
</ul>
</li>
<li><p>2개 이상의 값을 return하고 싶을 땐</p>
<ul>
<li>값을 결합하여 1개로 만들어서  return하고 밖에서 SUBSTR로 분리하는 방법을 사용</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> d.deptno, d.dname, avg_sal, min_sal, max_sal</div><div class="line">  <span class="keyword">FROM</span> dept d,</div><div class="line">       (<span class="keyword">SELECT</span> deptno, <span class="keyword">AVG</span>(sal) avg_sal, <span class="keyword">MIN</span>(sal) min_sal, <span class="keyword">MAX</span>(sal) max_sal <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno) e</div><div class="line"> <span class="keyword">WHERE</span> d.deptno = e.deptno(+)</div><div class="line">   <span class="keyword">AND</span> d.loc = <span class="string">'CHICAGO'</span>;</div></pre></td></tr></table></figure>
<p>위의 경우에는 일단 Inline View를 만들기 위해 emp 테이블 전체를 읽어야 한다.  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> d.deptno, d.dname,</div><div class="line">      (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.deptno = d.deptno) avg_sal,</div><div class="line">      (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.deptno = d.deptno) min_sal,</div><div class="line">      (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.deptno = d.deptno) max_sal</div><div class="line">  <span class="keyword">FROM</span> dept d</div><div class="line"> <span class="keyword">WHERE</span> d.loc = <span class="string">'CHICAGO'</span>;</div></pre></td></tr></table></figure>
<p>위의 경우에는 emp를 3번 호출하였다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> deptno, dname, </div><div class="line">       TO_NUMBER(<span class="keyword">SUBSTR</span>(ret,<span class="number">1</span>,<span class="number">5</span>)) avg_sal, </div><div class="line">       TO_NUMBER(<span class="keyword">SUBSTR</span>(ret,<span class="number">6</span>,<span class="number">5</span>)) min_sal, </div><div class="line">       TO_NUMBER(<span class="keyword">SUBSTR</span>(ret,<span class="number">11</span>,<span class="number">5</span>)) max_sal</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> d.deptno, d.dname,</div><div class="line">               (<span class="keyword">SELECT</span> <span class="keyword">LPAD</span>(<span class="keyword">AVG</span>(sal),<span class="number">5</span>) || <span class="keyword">LPAD</span>(<span class="keyword">MIN</span>(sal),<span class="number">5</span>) || <span class="keyword">LPAD</span>(<span class="keyword">MAX</span>(sal),<span class="number">5</span>) </div><div class="line">                  <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.deptno = d.deptno) ret</div><div class="line">          <span class="keyword">FROM</span> dept d</div><div class="line">         <span class="keyword">WHERE</span> d.loc = <span class="string">'CHICAGO'</span>);</div></pre></td></tr></table></figure>
<p>다소 Query가 좀 복잡해 졌지만, emp 테이블을 1번만 읽고도 같은 결과를 출력하였다.</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/02/06/03.06.join/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/05/03.05.index/">
                            SQLP 3-4-1 Index
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-02-05T00:00:00+09:00">
	
		    Feb 05, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="3과목-SQL-고급-활용-및-Tuning"><a href="#3과목-SQL-고급-활용-및-Tuning" class="headerlink" title="3과목 SQL 고급 활용 및 Tuning"></a>3과목 SQL 고급 활용 및 Tuning</h1><h2 id="4장-Index와-Join"><a href="#4장-Index와-Join" class="headerlink" title="4장 Index와 Join"></a>4장 Index와 Join</h2><h3 id="4-1-Index"><a href="#4-1-Index" class="headerlink" title="4.1 Index"></a>4.1 Index</h3><h4 id="Index의-NULL값"><a href="#Index의-NULL값" class="headerlink" title="Index의 NULL값"></a>Index의 NULL값</h4><ul>
<li>Oracle : 모두 NULL인 값은 저장하지 않음. NULL은 맨 뒤에 저장</li>
<li>MS-SQL : 모두 NULL인 값도 저장. NULL은 맨 앞에 저장</li>
</ul>
<h4 id="Index-탐색"><a href="#Index-탐색" class="headerlink" title="Index 탐색"></a>Index 탐색</h4><ul>
<li>수직 탐색<ul>
<li>수평적 탐색을 위한 시작점을 찾는 과정</li>
<li>Root Node에서 Leaf Node까지의 검색</li>
<li>Index 조건에 맞는 첫번째 값을 찾아가는 연산</li>
</ul>
</li>
<li>수평 탐색<ul>
<li>Leaf Node끼리 연결된 Link를 통해서 범위 검색</li>
</ul>
</li>
</ul>
<h4 id="Index-Scan-방식"><a href="#Index-Scan-방식" class="headerlink" title="Index Scan 방식"></a>Index Scan 방식</h4><h5 id="1-Index-Range-Scan"><a href="#1-Index-Range-Scan" class="headerlink" title="1. Index Range Scan"></a>1. Index Range Scan</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INDEX (RANGE SCAN) OF &apos;인덱스명&apos; (INDEX)</div></pre></td></tr></table></figure>
<ul>
<li>수직 탐색 후 Leaf Block을 필요한 범위만 Scan</li>
<li>B*Tree Index의 가장 일반적이고 정상적인 형태</li>
<li>Index 구성 칼럼 중 선두 컬럼이 조건절에 사용되어야만 가능</li>
<li>생성된 결과집합은 Index 컬럼 순대로 정렬된 상태 (ORDER BY, MIN, MAX 처리 가능)</li>
</ul>
<h5 id="2-Index-Full-Scan"><a href="#2-Index-Full-Scan" class="headerlink" title="2. Index Full Scan"></a>2. Index Full Scan</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INDEX (FULL SCAN) OF &apos;인덱스명&apos; (INDEX)</div></pre></td></tr></table></figure>
<ul>
<li>수직 탐색 없이 Leaf Block을 처음부터 끝까지 수평적으로 Scan</li>
<li>대개의 경우 Index의 선두 컬럼이 조건절에 없으면 Optimizer는 Table Full Scan을 고려한다.</li>
<li>하지만 다음 경우에는 Optimzer가 전략적으로 Index Full Scan을 고려한다.<ul>
<li>Table이 대용량이거나, Index의 나머지 칼럼으로 대부분의 record를 filtering하고 일부에 대해서만 Table 액세스가 발생하는 경우</li>
<li>ORDER BY 연산을 해야하는데 <code>first_rows</code> Hint를 이용하여 부분범위 처리를 할 경우. 하지만 이 경우 사용자가 FETCH를 끝까지 다 할 경우 Table Full Scan보다 더 비효율적이게 된다.</li>
</ul>
</li>
</ul>
<h5 id="3-Index-Unique-Scan"><a href="#3-Index-Unique-Scan" class="headerlink" title="3. Index Unique Scan"></a>3. Index Unique Scan</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INDEX (UNIQUE SCAN) OF &apos;PK 또는 Unique Index명` (UNIQUE)</div></pre></td></tr></table></figure>
<ul>
<li>수직 탐색만으로 Scan</li>
<li>Unique Index를 = 조건으로 검색할 경우에만 작동</li>
</ul>
<h4 id="4-Index-Skip-Scan"><a href="#4-Index-Skip-Scan" class="headerlink" title="4. Index Skip Scan"></a>4. Index Skip Scan</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INDEX (SKIP SCAN) OF &apos;인덱스명&apos; (INDEX)</div></pre></td></tr></table></figure>
<ul>
<li>INDEX의 선두컬럼이 조건절에 빠졌을 경우 대부분 Table Full Scan을 사용하지만 9i에서 새로 생긴 방식</li>
<li>선두 컬럼의 DISTICT 수가 적고, 후행 컬럼의 DISTINCT 수가 많을 경우 효과적</li>
</ul>
<h5 id="5-Index-Fast-Full-Scan"><a href="#5-Index-Fast-Full-Scan" class="headerlink" title="5. Index Fast Full Scan"></a>5. Index Fast Full Scan</h5><ul>
<li>Index에 포함된 컬럼만으로 조회가 가능한 경우</li>
<li>Index Tree구조를 무시하고 Segment 전체를 Multiblock Read 방식으로 Scan</li>
<li>결과집합 순서가 보장 안됨</li>
<li>Parallel Scan 가능</li>
</ul>
<h5 id="6-Index-Range-Scan-Descending"><a href="#6-Index-Range-Scan-Descending" class="headerlink" title="6. Index Range Scan Descending"></a>6. Index Range Scan Descending</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INDEX (RANGE SCAN DESCENDING) OF &apos;인덱스명&apos; (INDEX)</div></pre></td></tr></table></figure>
<ul>
<li>Index Range Scan과 동일한 방법이나 뒤에서 앞으로 Scan</li>
<li>Index에 저장된 순서와는 반대로 정렬된 결과집합을 출력</li>
<li>MIN / MAX 값을 구할 경우 1건만 읽고 멈추는 실행계획으로 유도할 경우에 좋음</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INDEX (RANGE SCAN (MIN/MAX)) OF &apos;인덱스명&apos; (INDEX)</div></pre></td></tr></table></figure>
<h4 id="Index-종류"><a href="#Index-종류" class="headerlink" title="Index 종류"></a>Index 종류</h4><h5 id="1-B-Tree-Index"><a href="#1-B-Tree-Index" class="headerlink" title="1. B*Tree Index"></a>1. B*Tree Index</h5><ul>
<li>가장 기본적인 Index 형식</li>
<li>최적의 성능을 위해서는 Index Fragmentation을 고려해야 함<ol>
<li>Unbalnaced Index<ul>
<li>Root에서 Leaf Node까지의 Height가 다른 경우</li>
<li>B<em>Tree에서는 이런 현상이 발생하지 않음 (Balanced</em>Tree에서 Unbalanced 현상이 생기는건 말이 안됨)</li>
</ul>
</li>
<li>Index Skew<ul>
<li>Index Enrty가 한쪽으로 치우치는 현상</li>
<li>대량의 delete 작업 후에는 한쪽의 Leaf Node들이 empty 상태가 됨</li>
<li>empty Node들은 언제든 재사용 가능하지만, 다시 채워질 때까지는 Index Scan 효율이 떨어짐</li>
<li>MS-SQL은 주기적으로 Index를 정리해주므로 이런 현상이 나타나지 않음</li>
</ul>
</li>
<li>Index Sparse<ul>
<li>Index Block 내의 밀도(density)가 떨어지는 현상</li>
<li>아래와 같은 현상이 일어나면 Index Sparse라 판단<ul>
<li>Index 내의 record는 많이 삭제했지만, Index Scan Block 수는 변화가 없음</li>
<li>Index record수는 일정한데, Index 사용 공간이 점점 커짐</li>
</ul>
</li>
</ul>
</li>
<li>Index 재생성<ul>
<li>위와 같은 Fragmentation 현상을 제거하기 위해 Index를 삭제 후 재생성</li>
<li>재생성은 수행시간과 부하가 큰 작업이므로 아래와 같이 예상효과가 확실할 때만 시행하는게 바람직함<ol>
<li>Index 분할에 의한 경합이 현저히 높을 때</li>
<li>자주 사용되는 Index Scan 효율을 높이고자 할 때. 특히 NL Join에서 반복 액세스 되는 경우</li>
<li>대량의 delete 작업 이후 새로운 record가 입력될 때까지 오랜 시간이 걸릴 때</li>
<li>총 record수가 일정한데도 Index가 계속 커질 때</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="2-Bitmap-Index"><a href="#2-Bitmap-Index" class="headerlink" title="2 Bitmap Index"></a>2 Bitmap Index</h5><ul>
<li>Column이 가질수 있는 값의 DISTINCT 수만큼의 BIT(0,1)를 2차원 배열로 표현</li>
<li>여러 INDEX를 동시에 활용할 수 있어서, 정형화되지 않은 ad-hoc query가 많은 환경에 효과적</li>
<li>DISTICT수가 적을 경우에는 B*Tree Index보다 적은 공간을 차지하지만, DISTINCT수가 많으면 더 큰 공간을 차지할 수도 있다.</li>
<li>등치(=), 부정(&lt;&gt;), NULL 조건을 찾는데 효과적이다.</li>
<li>하나의 record만 변경되더라도 전체에 Lock이 걸리므로 OLTP환경에서는 쓸수 없음</li>
<li>대용량의 DW(OLAP) 환경에 적합</li>
</ul>
<h5 id="3-FBI-Function-Based-Index"><a href="#3-FBI-Function-Based-Index" class="headerlink" title="3. FBI (Function Based Index)"></a>3. FBI (Function Based Index)</h5><ul>
<li>컬럼값 자체가 아닌 함수결과값으로 B*Tree Index를 생성</li>
<li>Index 컬럼 자체를 가공하면 정상적인 Index 사용이 불가능한데, 이 경우 효과적으로 Scan 가능</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> EMP_NVL_COMM <span class="keyword">ON</span> EMP(NVL(COMM,<span class="number">0</span>));      <span class="comment">-- 상여금이 없는 경우 0</span></div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> EMP_UPPER_ENAME <span class="keyword">ON</span> EMP(<span class="keyword">UPPER</span>(ENAME));  <span class="comment">-- 이름을 대소문자 구분없이 검색해야 할 경우</span></div></pre></td></tr></table></figure>
<h5 id="4-Reverse-Key-Index"><a href="#4-Reverse-Key-Index" class="headerlink" title="4. Reverse Key Index"></a>4. Reverse Key Index</h5><ul>
<li>Key 값을 Reverse() 함수를 거쳐서 저장</li>
<li>한쪽으로만 치우치는 형태의 값을 분산적으로 저장하고자 할 경우 효과적<ul>
<li>주문일시의 경우 항상 증가된 값이 들어오르모 오른쪽 Leaf Block에만 데이터가 쌓인다. (Right Growing Index)</li>
<li>이럴 경우 주문일자를 거꾸로 입력하면 Leaf 전체에 고르게 저장되므로 Transaction을 분산시키는 효과를 얻을 수 있다.</li>
</ul>
</li>
<li>하지만, 등치(=) 조건으로만 검색이 가능 (부등호, BETWEEN, LIKE로의 검색은 불가능)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_주문_주문일시 <span class="keyword">ON</span> 주문(<span class="keyword">REVERSE</span>(주문일시));</div></pre></td></tr></table></figure>
<h5 id="5-Cluster-Index"><a href="#5-Cluster-Index" class="headerlink" title="5. Cluster Index"></a>5. Cluster Index</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> CLUSTER C_DEPTNO (DEPTNO <span class="built_in">NUMBER</span>(<span class="number">2</span>)) <span class="keyword">INDEX</span>;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span>   I_DEPTNO <span class="keyword">ON</span> CLUSTER C_DEPTNO;</div></pre></td></tr></table></figure>
<ul>
<li>Oracel Clusterd Table : 값은 Key값을 가진 record를 한 block에 저장 (1 block의 크기가 넘으면 cluster chain으로 연결)</li>
<li>CLUSTER에 대한 Index를 생성<ul>
<li>Index Key값은 Unique</li>
<li>Index Key : Table Record가 1:M 관계 (일반 Index는 1:1)</li>
<li>Index Key에서 Random Scan, Cluster 내에서는 Sqeuential Scan</li>
</ul>
</li>
<li>다음과 같은 경우 유리<ul>
<li>Scan 범위가 넓을 경우</li>
<li>크기가 작고 NL Join으로 반복 Lookup하는 Table</li>
<li>Column 수가 적고 rocord가 많은 Table</li>
<li>데이터 입력 패턴과 조회 패턴이 서로 다른 Table<ul>
<li>ex. 실적등록 및 조회의 경우<ul>
<li>입력은 일자별로 진행되지만, 조회는 사원별로 하는 경우</li>
<li>일반 Table의 경우 사원마다 365일의 데이터 페이지를 Random 액세스 해야함</li>
<li>사번을 기준으로 CLUSTER를 생성하면 효과적</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-Index-Tuning"><a href="#4-2-Index-Tuning" class="headerlink" title="4.2 Index Tuning"></a>4.2 Index Tuning</h3><h4 id="Index-Tuning-기초"><a href="#Index-Tuning-기초" class="headerlink" title="Index Tuning 기초"></a>Index Tuning 기초</h4><ul>
<li><p>Index 선두 컬럼이 조건절에 사용되더라도 Index Range Scan이 불가능하거나 Index를 사용못하는 경우</p>
<ul>
<li>칼럼 가공 : <code>SUBSTR(DNAME, 1, 2) = &#39;영업&#39;</code></li>
<li>부정 비교 : <code>DNAME &lt;&gt; &#39;영업부&#39;</code></li>
<li>NOT NULL 조건 : <code>COMM IS NOT NULL</code> (당연히 INDEX에는 NULL이 없으므로, 그냥 Index Full Scan과 같다.)</li>
</ul>
</li>
<li><p>Index 컬럼 가공에 대한 Tuning</p>
<ul>
<li><code>SUBSTR(DNAME, 1, 2) = &#39;영업&#39;</code> -&gt; <code>DNAME LIKE &#39;영업%&#39;</code></li>
<li><code>SAL * 12 &gt; 3000</code> -&gt; <code>SAL &gt; 3000 / 12</code></li>
<li><code>TO_CHAR(일시,&#39;yyyymmdd&#39;) = :dt</code> -&gt; <code>일시 &gt;= TO_DATE(:dt,&#39;yyyymmdd&#39;) AND 일시 &lt; TO_DATE(:dt,&#39;yyyymmdd&#39;) + 1</code></li>
<li><code>연령 || 직업 = &#39;30공무원&#39;</code> -&gt; <code>연령 = 30 AND 직업 = &#39;공무원&#39;</code></li>
<li><code>회원번호 || 지점번호 = :str</code> -&gt; <code>회원번호 = SUBSTR(:str,1,2) AND 지점번호 = SUBSTR(:str,3,4)</code></li>
</ul>
</li>
<li><p>Implicit Conversion (묵시적 형변환)</p>
<ul>
<li>컬럼 타입과 비교값 타입이 다를 경우 묵시적 형변환이 발생</li>
<li>문자형과 숫자형 : 문자형을 숫자형으로 변환</li>
<li>문자형과 날짜형 : 문자형을 날짜형으로 변환</li>
<li>변환되는게 컬럼쪽이라면 Index를 사용하지 못하고 Table Full Scan 발생</li>
<li>이런 변환의 우선순위를 외우기 보다는 그냥 비교값을 컬럼 타입으로 변환해주는게 좋음</li>
</ul>
</li>
</ul>
<h4 id="Table-Random-액세스-최소화"><a href="#Table-Random-액세스-최소화" class="headerlink" title="Table Random 액세스 최소화"></a>Table Random 액세스 최소화</h4><ul>
<li>Index rowid에 의한 Table 액세스<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TABLE ACCESS (BY INDEX ROWID) OF &apos;컬럼&apos; (TABLE)</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>rowid는 disk 상의 위치정보이다.</li>
<li>DB Buffer Cache에서의 해당 Block의 위치는 rowid의 hash값을 이용하여 bucket list로 찾아간다.</li>
<li>bucket list 상에서 값을 찾는 과정에서도 Latch, 버퍼 Lock등을 이용해서 찾는다.</li>
<li>Clustering Factor<ul>
<li>Index상 같은 Block에 있는 record들라도 Table상에서는 다른 Block들에 있을 수 있다.</li>
<li>Index와 Table의 Record정렬 순서가 비교적 같은 경우에는 Clustering Factor가 좋아서 Index Scan 효율이 좋다.</li>
</ul>
</li>
</ul>
<ul>
<li><p>Index 손익분기점</p>
<ul>
<li>Index Range Scan에 의한 비용이 Table Full Scan보다 느려지는 지점</li>
<li>일반적으로 5 ~ 20% 정도지만 Clustering Factor가 나쁘면 5% 미만이 될수도 있고, 아주 좋을 땐 90%까지 올라가기도 한다.</li>
<li>Index rowid에 의한 Table 액세스 : Random 액세스, Single Block Read</li>
<li>Full Table Scan : Sequential 액세스, Multiblock Read</li>
</ul>
</li>
<li><p>손익분기점 극복하기</p>
<ol>
<li>Clustering Index, IOT : Table을 Index구조로 생성함으로써 항상 정렬된 상태를 유지</li>
<li>Index Key 이외의 미리 지정된 칼럼을 Leaf Level에 모두 저장 (MS-SQL의 Include index)</li>
<li>Oracle의 Clusterd Table : Key값이 같은 record를 같은 Block에 저장함으로 Random 액세스는 Key값당 1번</li>
<li>Partitioning : 자주 사용하는 컬럼 기준으로 파티셔닝을 하면 Full Table Scan이더라도 일부 파티션만 읽고 멈출 수 있음</li>
</ol>
</li>
</ul>
<h4 id="Table-Random-액세스-최소화-Tuning"><a href="#Table-Random-액세스-최소화-Tuning" class="headerlink" title="Table Random 액세스 최소화 Tuning"></a>Table Random 액세스 최소화 Tuning</h4><h5 id="1-Index-컬럼-추가"><a href="#1-Index-컬럼-추가" class="headerlink" title="1. Index 컬럼 추가"></a>1. Index 컬럼 추가</h5><ul>
<li>기존 Index의 구성이나 신규 추가는 실 운영 환경에서는 함부로 바꾸기가 쉽지 않다.</li>
<li>기존 Index에 조건절의 비교조건을 보고 뒤에 컬럼을 추가해줘서 최대한 조건비교를 Index 내에서 끝내고 Table 액세스를 최소화 한다.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> I_EMP_01 <span class="keyword">ON</span> EMP(DEPTNO, JOB);</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX(I_EMP_01) */</span> ENAME, JOB, SAL</div><div class="line">  <span class="keyword">FROM</span> EMP</div><div class="line"> <span class="keyword">WHERE</span> DEPTNO = <span class="number">30</span></div><div class="line">   <span class="keyword">AND</span> SAL &gt;= <span class="number">2000</span>;</div></pre></td></tr></table></figure>
<p>위의 상황에서는 DEPTNO = 30인 조건에 맞는 record들에 대해서 Table에서 record들을 가져와야 한다.<br>아래와 같이 기존 Index를 그대로 두고 컬럼만 추가해 줄 경우 Index의 액세스는 줄일 수 없지만, Table 액세스는 줄일 수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> I_EMP_01 <span class="keyword">ON</span> EMP(DEPTNO, JOB, SAL);</div></pre></td></tr></table></figure>
<ul>
<li>만약 Index의 칼럼만으로도 조회가 가능하다면 Table 액세스 자체를 안해도 될 수 있다.<ul>
<li>MS-SQL에서는 이 경우를 Covered Index, Covered Query 라 부른다.</li>
<li>Include Index : MS-SQL에서는 Index에 Key가 아닌 일반 컬럼 추가가 가능하다.<ul>
<li><code>CREATE INDEX EMP_01 ON EMP (DEPTNO) INCLUDE (SAL);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-IOT-Cluster-활용"><a href="#2-IOT-Cluster-활용" class="headerlink" title="2. IOT, Cluster 활용"></a>2. IOT, Cluster 활용</h5><ul>
<li>Index Key를 이용해서 한번만에 찾아가서 Sequential로 찾음</li>
<li>Index Key의 Hash값으로 찾아가므로 <code>=</code> 조건으로만 검색되는 칼럼을 Key로 해야한다.</li>
</ul>
<h5 id="3-수동으로-Clustering-Factor-높이기"><a href="#3-수동으로-Clustering-Factor-높이기" class="headerlink" title="3. 수동으로 Clustering Factor 높이기"></a>3. 수동으로 Clustering Factor 높이기</h5><ul>
<li>자주 이용되는 Index를 기준으로 Table을 재생성</li>
<li>한 Table에 Index가 여러 개인 경우 그 중 1개에 대해서만 Clustering Factor가 좋게 할 수 있다.</li>
</ul>
<h4 id="Index-Scan-범위-최소화"><a href="#Index-Scan-범위-최소화" class="headerlink" title="Index Scan 범위 최소화"></a>Index Scan 범위 최소화</h4><ul>
<li>일반적으로 Random 액세스 발생량을 줄이고, Sequential 액세스에 의한 선택 배중을 높이면 성능이 좋아진다.</li>
</ul>
<h5 id="1-Index-선행-칼럼이-범위조건일-경우"><a href="#1-Index-선행-칼럼이-범위조건일-경우" class="headerlink" title="1. Index 선행 칼럼이 범위조건일 경우"></a>1. Index 선행 칼럼이 범위조건일 경우</h5><ul>
<li>범위 조건 이후의 칼럼들에 대해서는 Range Scan을 해야 하므로 읽어야 할 범위가 넓어진다.</li>
<li>이럴 경우에는 Index 컬럼 순서를 바꿔주는게 효과적이다.</li>
</ul>
<h5 id="2-범위조건을-In-List로-전환"><a href="#2-범위조건을-In-List로-전환" class="headerlink" title="2. 범위조건을 In-List로 전환"></a>2. 범위조건을 In-List로 전환</h5><ul>
<li>범위조건으로 검색하는 컬럼의 순서를 바꾸기가 힘든 경우에는 BETWEEN 조건을 IN-List로 바꿔주면 효과적이다.<ul>
<li>실행계획상에 <code>INLIST ITERATOR</code>로 처리되므로 Scan 범위를 줄일 수 있다.</li>
<li>IN-List는 <code>UNION ALL</code>로 따로 실행되는 거랑 같다.</li>
<li>IN-List의 개수가 적을 경우 효과적이다. 많다면 범위조건일 경우보다 비효율적일 수 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DEPTNO BETWEEN 10 AND 20 -&gt; DEPTNO IN (10, 20)</div></pre></td></tr></table></figure>
<h5 id="3-범위조건이-2개-이상일-경우"><a href="#3-범위조건이-2개-이상일-경우" class="headerlink" title="3. 범위조건이 2개 이상일 경우"></a>3. 범위조건이 2개 이상일 경우</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> I_PROD <span class="keyword">ON</span> PRODUCT(COMPANY, PTYPE, PNAME);</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PRODUCT</div><div class="line"> <span class="keyword">WHERE</span> COMPANY = :com</div><div class="line">   <span class="keyword">AND</span> PTYPE <span class="keyword">LIKE</span> :ptype || <span class="string">'%'</span></div><div class="line">   <span class="keyword">AND</span> PNAME <span class="keyword">LIKE</span> :pname || <span class="string">'%'</span>;</div></pre></td></tr></table></figure>
<ul>
<li>첫번째 범위조건에 의해서 스캔 범위가 거의 결정나고, 두번째는 필터 조건 역할만 한다.</li>
<li>만약 이 경우 첫번째 범위조건이 입력되지 않을 수 있다면 SQL을 2개로 나누는게 효과적이다.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PRODUCT</div><div class="line"> <span class="keyword">WHERE</span> :ptype <span class="keyword">IS</span> <span class="literal">NULL</span></div><div class="line">   <span class="keyword">AND</span> COMPANY = :com</div><div class="line">   <span class="keyword">AND</span> PNAME <span class="keyword">LIKE</span> :pname || <span class="string">'%'</span>;</div><div class="line">   </div><div class="line"> UNION ALL</div><div class="line"> </div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PRODUCT</div><div class="line"> <span class="keyword">WHERE</span> :ptype <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">   <span class="keyword">AND</span> COMPANY = :com</div><div class="line">   <span class="keyword">AND</span> PTYPE = :ptype</div><div class="line">   <span class="keyword">AND</span> PNAME <span class="keyword">LIKE</span> :pname || <span class="string">'%'</span>;</div></pre></td></tr></table></figure>
<h4 id="Index-설계"><a href="#Index-설계" class="headerlink" title="Index 설계"></a>Index 설계</h4><ul>
<li>기본 공식<ol>
<li>조건절에 항상 사용되거나, 자주 사용되는 컬럼을 선정</li>
<li><code>=</code> 조건으로 자주 조회되는 칼럼을 앞으로</li>
<li>조건절에 사용되지 않더라도 Sort 연산 (ORDER BY, GROUP BY)를 대체할 목적으로 구성이 가능</li>
<li>선택도(Selectivy)가 충분히 낮지 않다면 Full Table Scan보다 느려지기 때문에 의미가 없음</li>
<li>추가 고려사항<ul>
<li>Query 수행 빈도</li>
<li>업무상 중요도</li>
<li>Clustering Factor</li>
<li>데이터량</li>
<li>DML 부하</li>
<li>저장 공간</li>
<li>Index 관리 비용</li>
</ul>
</li>
</ol>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/02/05/03.05.index/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/04/03.04.optimizer/">
                            SQLP 3-3 Optimizer
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-02-04T00:00:00+09:00">
	
		    Feb 04, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="3과목-SQL-고급-활용-및-Tuning"><a href="#3과목-SQL-고급-활용-및-Tuning" class="headerlink" title="3과목 SQL 고급 활용 및 Tuning"></a>3과목 SQL 고급 활용 및 Tuning</h1><h2 id="3장-Optimizer-원리"><a href="#3장-Optimizer-원리" class="headerlink" title="3장 Optimizer 원리"></a>3장 Optimizer 원리</h2><h3 id="3-1-Optimizer"><a href="#3-1-Optimizer" class="headerlink" title="3.1 Optimizer"></a>3.1 Optimizer</h3><p>SQL을 가장 빠르고 효율적으로 수행할 최적(최저비용)의 처리경로를 생성해주는 DBMS 핵심엔진</p>
<h4 id="Optimizer-종류"><a href="#Optimizer-종류" class="headerlink" title="Optimizer 종류"></a>Optimizer 종류</h4><ul>
<li>RBO (Rule-based Optimizer) : 규칙(우선 순위)를 가지고 실행계획 생성</li>
<li>CBO (Cost-based Optimizer) : 통계정보를 기반으로 여러가지 실행계획을 생성하여 그중 최저비용의 실행계획을 선택</li>
</ul>
<h4 id="최적화-과정"><a href="#최적화-과정" class="headerlink" title="최적화 과정"></a>최적화 과정</h4><ol>
<li>Parser : SQL Parsing. SQL의 문법(Syntax) , 의미 (Semantic)을 확인</li>
<li>Optimizer<ul>
<li>Query Transformer : Parsing된 SQL을 표준 형태로 변환</li>
<li>Estimator : 통계정보를 이용하여 선택도, 카디널리티 등으로 Execution Plan의 총 비용을 계산</li>
<li>Plan Generator : 후보군이 될만한 Execution Plan을 생성</li>
</ul>
</li>
<li>Row-Source Generator : 최종 선택된 Execution Plan을 SQL 엔진이 실행할 수 있는 코드 생성</li>
<li>SQL Engine : SQL을 실행</li>
</ol>
<ul>
<li>최적화 목표<ol>
<li>전체 처리속도 최적화 (all_rows) : 결과집합을 끝까지 읽는 것을 전제. 대부분 DBMS의 기본옵션</li>
<li>최초 응답속도 최적화 (first_rows) : 결과중 일부만 읽다가 멈추는 것을 전제.<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ALL_ROWS */</span> ... ; <span class="comment">-- 전체 처리속도 최적화</span></div><div class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ FIRST_ROWS(10) */</span> ... ; <span class="comment">-- 처음 10개의 row만 읽고 멈추는 것을 전제로 최적화</span></div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h4 id="Optimizer-통계유형"><a href="#Optimizer-통계유형" class="headerlink" title="Optimizer 통계유형"></a>Optimizer 통계유형</h4><ul>
<li>Table : 전체 레코드 수, 총 블록 수, 빈 블록 수, 한 행당 평균 크기 등</li>
<li>Index : 높이, 리프 블록 수, 클러스터링 팩터, 인덱스 레코드 수 등</li>
<li>Column : 값의 수, MIN, MAX, 밀도, NULL값 개수, 히스토그램 등</li>
<li>System : CPU 속도, 평균 I/O 속도, 초당 I/O 처리량 등</li>
</ul>
<h4 id="통계정보를-이용한-비용계산-원리"><a href="#통계정보를-이용한-비용계산-원리" class="headerlink" title="통계정보를 이용한 비용계산 원리"></a>통계정보를 이용한 비용계산 원리</h4><ul>
<li>선택도 (Selectivity) : 1 / Distinct Value 수</li>
<li>카디널리티 (Cardinality) : 총 Row 수 X 선택도</li>
<li>히스토그램 (Histogram) : Column의 분포도<ul>
<li>도수분포 히스토그램 : 값별로 빈도수(Frequency Number)를 저장</li>
<li>높이균형 히스토그램 : 각 버킷의 높이를 같게 하고 빈도 수가 많은 값(popular value)는 여러 버킷에 할당. 컬럼이 가진 값의 수가 아주 많을 경우 효과적</li>
</ul>
</li>
<li>비용 (Cost)<ul>
<li>I/O 비용 모델 : 예상되는 I/O 요청(Call) 횟수로 평가</li>
<li>CPU 비용 모델 : I/O비용 모델 + 시간 개념을 더해 비용 산정</li>
</ul>
</li>
</ul>
<h4 id="Optimizer-Hint"><a href="#Optimizer-Hint" class="headerlink" title="Optimizer Hint"></a>Optimizer Hint</h4><ul>
<li>Optimizer도 잘못된 판단을 할 수 있으므로, 개발자가 직접 실행방식을 원하는대로 유도하는 방법</li>
<li>Hint가 무시되는 경우<ol>
<li>문법적으로 틀린 경우</li>
<li>의미적으로 틀린 경우 : RBO에서 CBO Hint (ex. first_rows_10), unnest 와 push_subq를 같이 쓴 경우</li>
<li>잘못된 참조 사용 : 없는 Table, Index, Alias 지정</li>
<li>논리적으로 불가능 : JOIN에 등치(=)조건 없이 Hash Join으로 유도, Nullable 칼럼에 대해 Index를 활용해 COUNT(*) 계산시도</li>
</ol>
</li>
</ul>
<ul>
<li>Hint 종류는 별도로 정리할 예정</li>
</ul>
<h3 id="3-2-Query-Transformation-쿼리-변환"><a href="#3-2-Query-Transformation-쿼리-변환" class="headerlink" title="3.2 Query Transformation (쿼리 변환)"></a>3.2 Query Transformation (쿼리 변환)</h3><ul>
<li>Optimizer가 SQL을 분석하여 동일하지만 더 나은 성능의 SQL로 재작성</li>
<li>Query Transformer가 담당</li>
</ul>
<h4 id="Query-변환-방식"><a href="#Query-변환-방식" class="headerlink" title="Query 변환 방식"></a>Query 변환 방식</h4><ul>
<li>Heuristic Query 변환 : 결과만 보장된다면 무조건 수행. Rule-based 최적화 기법</li>
<li>Cost-based Query 변환 :  변환된 Query의 비용이 더 낮을 때만 그것을 사용</li>
</ul>
<h4 id="Subquery-Unnesting"><a href="#Subquery-Unnesting" class="headerlink" title="Subquery Unnesting"></a>Subquery Unnesting</h4><ul>
<li>Nested Subquery를 풀어서 Main-query와의 JOIN된 형태로 변환<ul>
<li>Optimizer는 JOIN방식에 대해서 여러가지 최적화 기법을 시도 할 수 있다.</li>
<li>만약 Nested Subquery를 그대로 두고 최적화를 해야 한다면 각각의 Subquery, Main-query별로 최적화를 해야하는데, 이렇게 부분의 최적화가 전체 수행 성능의 최적화를 보장하진 못한다.</li>
<li>관련 Hint<ul>
<li>UNNEST : Unnesting 하여 JOIN방식으로 유도</li>
<li>NO_UNNEST : 그래도 둔 상태에서 Filter 방식으로 최적화 유도</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO <span class="keyword">IN</span> (<span class="keyword">SELECT</span> DEPTNO <span class="keyword">FROM</span> DEPT); <span class="comment">-- Main (M) : Sub (1) 관계에서는 Unnesting이 대부분 유리</span></div><div class="line"><span class="comment">-- 변환</span></div><div class="line"><span class="keyword">SELECT</span> EMP.* <span class="keyword">FROM</span> DEPT, EMP <span class="keyword">WHERE</span> EMP.DEPT = DEPT.DEPTNO;</div></pre></td></tr></table></figure>
<ul>
<li>Subquery가 M쪽 집합이거나 Non-unique Index일 경우<ul>
<li>예를 들어 <code>SELECT * FROM DEPT WHERE DEPTNO IN (SELECT DEPTNO FROM EMP)</code>와 같은 경우</li>
<li>위 방법과 같이 Unnesting하면 결과가 달라지게 된다. (EMP에는 같은 DEPTNO가 많다.)</li>
<li>이럴 경우 Optimizer는 2 가지 방법 중 하나를 선택한다.<ul>
<li>Sort Unique : Subquery쪽 Table이 1쪽임을 호가신할 수 없는 경우 먼저 Sort Unique를 수행한 후에 JOIN</li>
<li>Semi Join : Driving Table의 한 row가 Inner Table의 한 row와 JOIN에 성공하면 Outer Table의 다음 row를 진행.  Main-query 쪽 Table이 먼저 Driving될 경우</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="View-Merging"><a href="#View-Merging" class="headerlink" title="View Merging"></a>View Merging</h4><ul>
<li>일반 View, Inline View를 JOIN으로 풀어서 변환</li>
<li>사람 눈으로 볼땐 Query가 블록화 되어 보기 편하지만 Optimizer는 가급적 풀어서 JOIN형태로 변환한 뒤 최적화를 시도</li>
<li>단순한 View는 Merging하여도 성능이 나빠지지 않는다.</li>
<li>복잡한 연산을 포함하는 View는 Merging하면 성능이 나빠질 수 있다.</li>
</ul>
<ul>
<li><p>Inline View Merging 예제</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> A.* </div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> JOB = <span class="string">'SALESMAN'</span>) A,</div><div class="line">       (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> DEPT <span class="keyword">WHERE</span> LOC = <span class="string">'CHICAGO'</span>) B</div><div class="line"> <span class="keyword">WHERE</span> A.DEPTNO = B.DEPTNO;</div><div class="line"></div><div class="line"><span class="comment">-- 변환</span></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> *</div><div class="line">  <span class="keyword">FROM</span> EMP A, DEPT B</div><div class="line"> <span class="keyword">WHERE</span> A.DEPTNO = B.DEPTNO</div><div class="line">   <span class="keyword">AND</span> A.JOB = <span class="string">'SALESMAN'</span></div><div class="line">   <span class="keyword">AND</span> B.LOC = <span class="string">'CHICAGO'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>View Merging 예제</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">CREATE OR REPLACE VIEW EMP_SALESMAN</div><div class="line">AS</div><div class="line">SELECT * FROM EMP WHERE JOB = 'SALESMAN';</div><div class="line"></div><div class="line">SELECE E.*</div><div class="line">  FROM EMP_SALESMAN E, DEPT D</div><div class="line"> WHERE D.DEPTNO = E.DEPTNO</div><div class="line">   AND E.SAL &gt;= 1500;</div><div class="line"></div><div class="line">-- 변환</div><div class="line"></div><div class="line">SELECT E.*</div><div class="line">  FROM EMP E, DEPT D</div><div class="line"> WHERE D.DEPTNO = E.DEPTNO</div><div class="line">   AND E.JOB = 'SALESMAN'</div><div class="line">   AND E.SAL &gt;= 1500;</div></pre></td></tr></table></figure>
</li>
<li><p>View Merging시 성능이 나빠질 수 있는 연산</p>
<ul>
<li>GROUP BY 절</li>
<li>DISTINCT 연산</li>
</ul>
</li>
<li><p>View Merging이 불가능한 연산</p>
<ul>
<li>집합(SET) : UNION, UNION ALL, INTERSECT, MINUS</li>
<li>CONNECT BY 절</li>
<li>ROWNUM pseudo 칼럼</li>
<li>집계 함수 (AVG, CONUT, MAX, MIN, SUM, …)</li>
<li>분석 함수 (Analytic Function)</li>
</ul>
</li>
<li><p>관련 Hint : MERGE, NO_MERGE</p>
</li>
</ul>
<h4 id="Predicate-Pushing-조건절-푸싱"><a href="#Predicate-Pushing-조건절-푸싱" class="headerlink" title="Predicate Pushing (조건절 푸싱)"></a>Predicate Pushing (조건절 푸싱)</h4><ul>
<li>조건절을 가능한 빨리 처리되도록 View 안으로 밀어넣어서 처리량을 최소화 하는 방식</li>
</ul>
<ul>
<li><p>종류</p>
<ul>
<li>Predicate Pushdown : Query 블록 밖에 있는 조건절은 안으로 밀어 넣음</li>
<li>Predicate Pullup : Query 블록 안의 조건절을 밖으로 내오와서, 다른 Query 블록 안으로 Pushdown하는데 사용</li>
<li>Join Predicate Pushdown : NL Join 수행시 Driving Table에서 읽은 값을 Inner View Query 쪽으로 밀어 넣음</li>
</ul>
</li>
<li><p>Predicate Pushdown</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, AVG_SAL</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> DEPTNO, <span class="keyword">AVG</span>(SAL) AVG_SAL <span class="keyword">FROM</span> EMP <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO)</div><div class="line"> <span class="keyword">WHERE</span> DEPTNO = <span class="number">30</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Inline View 안에서 DEPTNO에 대해서만 GROUP BY 하여 데이터량을 줄일 수 있다.</p>
<ul>
<li>Predicate Pullup<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> DEPTNO, <span class="keyword">AVG</span>(SAL)           <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO = <span class="number">10</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO) E1,</div><div class="line">       (<span class="keyword">SELECT</span> DEPTNO, <span class="keyword">MIN</span>(SAL), <span class="keyword">MAX</span>(SAL) <span class="keyword">FROM</span> EMP                   <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO) E2</div><div class="line"> <span class="keyword">WHERE</span> E1.DEPTNO = E2.DEPTNO;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>E1의 조건을 Pullup하여 E2로 Pushdown하여 데이터량을 줄일 수 있다.</p>
<ul>
<li>Join Predicate Pushdown<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> D.DEPTNO, D.DNAME, E.AVG_SAL</div><div class="line">  <span class="keyword">FROM</span> DEPT D,</div><div class="line">       (<span class="keyword">SELECT</span> DEPTNO, <span class="keyword">AVG</span>(SAL) AVG_SAL <span class="keyword">FROM</span> EMP <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO) E</div><div class="line"> <span class="keyword">WHERE</span> E.DEPTNO(+) = D.DEPTNO;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>D에 존재하는 DEPTNO에 대해서만 E에서 수행하여 데이터량을 줄일 수 있다.</p>
<h3 id="조건절-이행-Transitive-Predicate-Generation-Transitive-Closure"><a href="#조건절-이행-Transitive-Predicate-Generation-Transitive-Closure" class="headerlink" title="조건절 이행(Transitive Predicate Generation, Transitive Closure)"></a>조건절 이행(Transitive Predicate Generation, Transitive Closure)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> DEPT D, EMP E</div><div class="line"> <span class="keyword">WHERE</span> E.JOB = <span class="string">'MANAGER'</span></div><div class="line">   <span class="keyword">AND</span> E.DEPTNO = <span class="number">10</span></div><div class="line">   <span class="keyword">AND</span> D.DEPTNO = E.DEPTNO</div></pre></td></tr></table></figure>
<p>E의 <code>DEPTNO = 10</code> 조건을 D에서도 수행</p>
<h3 id="불필요한-JOIN-제거-Join-Elimination"><a href="#불필요한-JOIN-제거-Join-Elimination" class="headerlink" title="불필요한 JOIN 제거 (Join Elimination)"></a>불필요한 JOIN 제거 (Join Elimination)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> E.* <span class="keyword">FROM</span> DEPT D, EMP E <span class="keyword">WHERE</span> D.DEPTNO = E.DEPTNO;</div></pre></td></tr></table></figure>
<ul>
<li>D의 참조가 전혀 없으므로 제거</li>
<li>단, PK, FK의 제약조건이 있어야만 가능.<ul>
<li>PK가 없는 경우 Join Cardinality를 파악할 수 없으므로 결과가 달라 질 수 있음</li>
<li>FK가 설정되어 있다하더라도 EMP의 DEPTNO가 Nullable이면 결과가 달라질 수 있음</li>
</ul>
</li>
</ul>
<h3 id="OR-조건을-UNION으로-변환"><a href="#OR-조건을-UNION으로-변환" class="headerlink" title="OR 조건을 UNION으로 변환"></a>OR 조건을 UNION으로 변환</h3><ul>
<li>OR 조건을 그대로 둘 경우 Full Table Scan으로 처리되거나 각각의 Column별 Index를 활용하여 Bitmap 연산을 하는 Index Combine으로 작동할 경우가 있다.</li>
<li>관련 Hint<ul>
<li>USE_CONCAT : UNION ALL 표현 (OR-Expansion)을 유도</li>
<li>NO_EXPAND : 나누지 말고 그대로 실행</li>
</ul>
</li>
</ul>
<h3 id="집합-연산을-JOIN-연산으로"><a href="#집합-연산을-JOIN-연산으로" class="headerlink" title="집합 연산을 JOIN 연산으로"></a>집합 연산을 JOIN 연산으로</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> JOB, MGR <span class="keyword">FROM</span> EMP</div><div class="line"><span class="keyword">MINUS</span></div><div class="line"><span class="keyword">SELECT</span> JOB, MGR <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p>위 문장을 실행하면 Table Full Scan 후 Sort Unique 하는 연산을 2번 수행 후에 결과집합을 구하게 된다.<br>이 경우 아래와 같은 형태로 Query 변환을 하여 실행을 한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> JOB, MGR <span class="keyword">FROM</span> EMP E</div><div class="line"> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="string">'X'</span> <span class="keyword">FROM</span> EMP</div><div class="line">                    <span class="keyword">WHERE</span> DEPTBO = <span class="number">10</span></div><div class="line">                      <span class="keyword">AND</span> SYS_OP_MAP_NONNULL(JOB) = SYS_OP_MAP_NONNULL(E.JOB)</div><div class="line">                      <span class="keyword">AND</span> SYS_OP_MAP_NONNULL(MGR) = SYS_OP_MAP_NONNULL(E.MGR)</div></pre></td></tr></table></figure>
<ul>
<li>SYS_OP_MAP_NONNULL() : null끼리 비교시 true값을 반환하도록 처리</li>
</ul>
<h3 id="JOIN-Column에-IS-NOT-NULL-조건-추가"><a href="#JOIN-Column에-IS-NOT-NULL-조건-추가" class="headerlink" title="JOIN Column에 IS NOT NULL 조건 추가"></a>JOIN Column에 IS NOT NULL 조건 추가</h3><ul>
<li>어차피 NULL인 Column은 JOIN에 실패한다. 그러기 때문에 미리 NULL인 Column에 대해서 Filtering 하면 불필요한 액세스를 줄일 수 있다. (Oracle의 경우 해당 Column의 NULL값 비중이 5% 이상이면 내부적으로 추가해준다.)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> EMPNO, DNAME</div><div class="line">  <span class="keyword">FROM</span> EMP E, DEPT D</div><div class="line"> <span class="keyword">WHERE</span> D.DEPTNO = E.DEPTNO</div><div class="line">   <span class="keyword">AND</span> SAL &lt;= <span class="number">2900</span></div><div class="line">   <span class="keyword">AND</span> E.DEPTNO <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>  <span class="comment">-- Optimizer가 추가</span></div><div class="line">   <span class="keyword">AND</span> D.DEPTNO <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>  <span class="comment">-- Optimizer가 추가</span></div></pre></td></tr></table></figure>
<h3 id="Filter-조건-추가"><a href="#Filter-조건-추가" class="headerlink" title="Filter 조건 추가"></a>Filter 조건 추가</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> SAL BETERRN :<span class="keyword">MIN</span> <span class="keyword">AND</span> :<span class="keyword">MAX</span></div></pre></td></tr></table></figure>
<p>위 Query에서 :MIN 이 :MAX보다 크면 당연히 결과는 공집합이다.<br>이 경우 :MIN 값이 :MAX보다 작거나 같다는 Filter조건을 임의로 추가해서 실행해준다.</p>
<h3 id="WHERE-비교-순서"><a href="#WHERE-비교-순서" class="headerlink" title="WHERE 비교 순서"></a>WHERE 비교 순서</h3><p>WHERE 절에 비교할 컬럼이 많은 경우 그 중 작업량을 많이 줄여줄거라 판단한 조건부터 먼저 비교한다.</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/02/04/03.04.optimizer/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/02/03.03.lock/">
                            SQLP 3-2 Lock과 Transaction 동시성 제어
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-02-02T00:00:00+09:00">
	
		    Feb 02, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="3과목-SQL-고급-활용-및-Tuning"><a href="#3과목-SQL-고급-활용-및-Tuning" class="headerlink" title="3과목 SQL 고급 활용 및 Tuning"></a>3과목 SQL 고급 활용 및 Tuning</h1><h2 id="2장-Lock과-Transaction-동시성-제어"><a href="#2장-Lock과-Transaction-동시성-제어" class="headerlink" title="2장 Lock과 Transaction 동시성 제어"></a>2장 Lock과 Transaction 동시성 제어</h2><h3 id="2-1-Lock"><a href="#2-1-Lock" class="headerlink" title="2.1 Lock"></a>2.1 Lock</h3><h4 id="Shared-Lock-vs-Exclusive-Lock"><a href="#Shared-Lock-vs-Exclusive-Lock" class="headerlink" title="Shared Lock vs. Exclusive Lock"></a>Shared Lock vs. Exclusive Lock</h4><ul>
<li>Shared Lock (공유 Lock)<ul>
<li>데이터를 읽을 때 사용</li>
<li>다른 Shared Lock과는 호환되지만, Exclusive Lock과는 호환이 안됨<ul>
<li>즉, Shared Lock이 걸려있는 상태에서 Exclusive Lock은 Blocking 됨</li>
</ul>
</li>
</ul>
</li>
<li>Exclusive Lock (베타적 Lock)<ul>
<li>데이터를 변경할 때 사용</li>
<li>모든 종류의 Lock과 호환이 안됨</li>
</ul>
</li>
</ul>
<h4 id="Blocking과-Deadlock"><a href="#Blocking과-Deadlock" class="headerlink" title="Blocking과 Deadlock"></a>Blocking과 Deadlock</h4><ul>
<li>Blocking<ul>
<li>Lock 경합이 발생하여 특정 세션이 작업을 진행하지 못하고 멈춘 상태</li>
<li>Blocking 상태를 해소하는 방법은 Commit or Rollback 뿐</li>
</ul>
</li>
<li><p>Lock에 의한 성능 최소화 방안</p>
<ul>
<li>Transaction의 원자성을 훼손하지 않는 선에서 최대한 짧게 정의</li>
<li>같은 데이터를 갱신하는 Transaction이 동시에 수행되지 않도록 설계</li>
<li>Transaction Isolation Level을 지나치게 상향 조정하지 않음</li>
<li>Transaction을 잘 설계하여 대기 현상을 피하도록 프로그래밍</li>
<li>주간의 대용량 갱신작업이 불가피하다면 timeout을 이용  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">NOWAIT</span> <span class="comment">-- 대기없이 Exception  </span></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WAIT</span> <span class="number">3</span> <span class="comment">-- 3초 대기 후 Exception</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Deadlock (교착상태)</p>
<ul>
<li>두 세션이 각각 Lock을 건 상태에서 서로의 Lock걸린 리소스를 액세스하려 할 경우 영원히 대기상태에 빠지는 것</li>
<li>유일한 해결 방법은 둘 중 한 세션에 에러를 발생시키는 것</li>
<li>테이블 접근 순서를 같게 처리하면 피할 수 있음</li>
</ul>
</li>
</ul>
<h4 id="Oracle-Lock"><a href="#Oracle-Lock" class="headerlink" title="Oracle Lock"></a>Oracle Lock</h4><ul>
<li>Oracle에서는 어떠한 읽기 작업도 Lock에 영향을 받지 않는다.<ul>
<li>Undo 데이터를 활용한 다중버전 동시성 제어 메커니즘을 활용한다.</li>
<li>단,  SELECT … FOR UPDATE 제외</li>
</ul>
</li>
<li>Row Lock<ul>
<li>항상 Exclusive Lock</li>
<li>INSERT, UPDATE, DELETE, SELECT … FOR UPDATE를 수행한 Transaction에 의해 설정되며 해당 Transaction이 Commit 이나 Rollback할때까지 다른 Transaction은 해당 Row를 변경할 수 없다.</li>
</ul>
</li>
<li>Table Lock<ul>
<li>Row Lock을 얻는 순간, 해당 Table에 대한 Table Lock도 얻는다.</li>
<li>현재 Transaction이 갱신 중인 Table에 대해 호환되지 않는 DDL 수행을 방지한다.</li>
<li>5종류의 Lock이 있음<ul>
<li>RS (Row Share) : X제외 모두 허용</li>
<li>RX (Row Exclusive) : RS, RX 허용</li>
<li>S (Share) : RS, S 허용</li>
<li>SRX (Share Row Exclusive) : RS 허용</li>
<li>X (Exclusive) : 모두 불허용</li>
</ul>
</li>
<li>명시적으로 <code>Lock Table</code> 명령어를 사용 할 수도 있음</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLE</span> emp <span class="keyword">IN</span> <span class="keyword">ROW</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</div><div class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLE</span> emp <span class="keyword">IN</span> <span class="keyword">ROW</span> EXCLUSIVE <span class="keyword">MODE</span>;</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="2-1-Transaction"><a href="#2-1-Transaction" class="headerlink" title="2.1 Transaction"></a>2.1 Transaction</h3><h4 id="Transaction-특징"><a href="#Transaction-특징" class="headerlink" title="Transaction 특징"></a>Transaction 특징</h4><ol>
<li>원자성 (Atomicity) : 업무상 최소단위</li>
<li>일관성 (Consistency) : 실행 전후 데이터베이스 상태가 모순되지 않아야 함</li>
<li>격리성 (Isolation) : 실행 중 다른 Transaction이 접근할 수 없음</li>
<li>영속성 (Durability) : 성공적으로 수행하면, 데이터베이스에 영속적으로 저장</li>
</ol>
<h4 id="낮은-Isolation-Level에서의-현상"><a href="#낮은-Isolation-Level에서의-현상" class="headerlink" title="낮은 Isolation Level에서의 현상"></a>낮은 Isolation Level에서의 현상</h4><ol>
<li>Dirty Read<ul>
<li>Commit하지 않은 데이터를 읽음. 이미 읽은 뒤 다시 Rollback 될 수 있음.</li>
</ul>
</li>
<li>Non-Repeatable Read<ul>
<li>한 Transaction 내의 같은 Query에 대해서 값이 바뀌는 현상</li>
<li>처음 값을 읽은 뒤 다른 Transaction이 해당 값을 변경한 경우</li>
</ul>
</li>
<li>Phantom Read<ul>
<li>한 Transaction 내에 같은 Query에 대해서 처음에 없었던 값이 읽히는 현상</li>
<li>처음 값을 읽은 뒤 다른 Transaction이 새로운 값을 입력한 경우</li>
</ul>
</li>
</ol>
<h4 id="Transaction-Isolation-Level"><a href="#Transaction-Isolation-Level" class="headerlink" title="Transaction Isolation Level"></a>Transaction Isolation Level</h4><ol>
<li>Read Uncommitted : 다른 Transaction이 처리 중인 값을 읽는 것을 허용 (이걸 허용하는 DB는 거의 없음)</li>
<li>Read Committed : Dirty Read 방지</li>
<li>Repeatable Read : Non-Repeatable Read 방지</li>
<li>Serializable Read : Phantom Read 방지<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> <span class="keyword">SERIALIZABLE</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>Transaction Isolation Level을 높일수록 Lock에 의존적이다보니 동시성이 저하된다.</li>
<li>Oracle에서는 다중버전 동시성 제어(Multiversion Concurrency Control)을 사용한다.</li>
</ul>
<h4 id="동시성-제어-Concurrency-Control"><a href="#동시성-제어-Concurrency-Control" class="headerlink" title="동시성 제어 (Concurrency Control)"></a>동시성 제어 (Concurrency Control)</h4><ul>
<li><p>비관적 동시성 제어 (Pessimistic Concurrency Control)</p>
<ul>
<li>같은 데이터를 동시에 수정할 것이라고 가정</li>
<li>먼저 Lock을 걸고 Transaction이 완료될때까지 유지<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div><div class="line"><span class="keyword">UPDATE</span> ...</div><div class="line"><span class="keyword">COMMIT</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>낙관적 동시성 제어 (Optimistic Concurrency Control)</p>
<ul>
<li>같은 데이터를 동시에 수정하지 않을 것이라고 가정</li>
<li>데이터 읽을 때 Lock을 걸지 않지만, 수정할때 변경되었는지 확인<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">INTO</span> :a, :b, :c, :d ... ;</div><div class="line"><span class="keyword">UPDATE</span> ... <span class="keyword">WHERE</span> col1 = :a <span class="keyword">AND</span> col2 = :b ...;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="다중버전-동시성-제어-Multiversion-Concurrency-Control"><a href="#다중버전-동시성-제어-Multiversion-Concurrency-Control" class="headerlink" title="다중버전 동시성 제어 (Multiversion Concurrency Control)"></a>다중버전 동시성 제어 (Multiversion Concurrency Control)</h4><ul>
<li>데이터를 변경할 때마다 Undo 영역에 저장</li>
<li>Query (또는 Transaction) 시작 시점 이후 변경된 값에 대해서는 Undo 영역에 저장된 정보를 이용해서 일관성 있는 버전(CR Copy)를 생성하여 읽음</li>
</ul>
<ul>
<li>문장수준 읽기 일관성 (Statement-Level Read Consistency)<ul>
<li>단일 SQL 내에서의 일관성 유지</li>
<li>Query 시작시점 이후 변경값에 대해서는 CR Copy 값을 읽음</li>
</ul>
</li>
<li>트랜잭션 수준 읽기 인관성 (Transaction-Level Read Consistency)<ul>
<li>Transaction 시작시점 이후 변경값에 대해서는 CR Copy 값을 읽음</li>
</ul>
</li>
<li>Snapshot too old<ul>
<li>Undo 영역의 정보가 다른 Transaction에 의해 재사용됨으로 CR Copy를 생성할 수 없을 경우 발생</li>
<li>줄일 수 있는 방법<ul>
<li>Undo 영역 크기 증가</li>
<li>Commit을 자주하지 않음</li>
<li>fetch across commit 형태의 프로그램 작성을 피함</li>
<li>Transation이 몰리는 시간대에 오래 걸리는 Query 수행을 피함</li>
<li>큰 Table을 일정 범위로 나우어 일고 단계적으로 실행하도록 코딩 (단 일관성 문제는 없어야 함)</li>
<li>오랜 시간에 걸쳐 같은 Block을 여러 번 방문하는 NL JOIN 또는 Index를 경유한 Table 액세스를 체크하고 회피할수 있는 방법 찾음 (JOIN 방법 변경, Full Table Scan)</li>
<li>ORDER BY를 강제로 삽입하여 Sort연산을 강제로 발생</li>
<li>대량 UPDATE후 바로 해당 Table 또는 Index를 Full Scan하도록 Query 수행</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="관련-내용-Slide"><a href="#관련-내용-Slide" class="headerlink" title="관련 내용 Slide"></a>관련 내용 Slide</h3><ul>
<li>Oracle Transaction Isolation Level : <a href="http://www.slideshare.net/seokjoonyun9/2015-0515-oracle-transaction-concurrency-control-read-consistency" target="_blank" rel="external">http://www.slideshare.net/seokjoonyun9/2015-0515-oracle-transaction-concurrency-control-read-consistency</a></li>
<li>Oracle Concurrency Control : <a href="http://www.slideshare.net/seokjoonyun9/20150522-oracle-ways-of-concurrency-control" target="_blank" rel="external">http://www.slideshare.net/seokjoonyun9/20150522-oracle-ways-of-concurrency-control</a></li>
<li>Oracle Snapshot too Old : <a href="http://www.slideshare.net/seokjoonyun9/oracle-architecture2015-0424-bblock-cleanout-and-snapshottooold" target="_blank" rel="external">http://www.slideshare.net/seokjoonyun9/oracle-architecture2015-0424-bblock-cleanout-and-snapshottooold</a></li>
<li>Oracle Consistency : <a href="http://www.slideshare.net/seokjoonyun9/2015-0409-consistency" target="_blank" rel="external">http://www.slideshare.net/seokjoonyun9/2015-0409-consistency</a></li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/02/02/03.03.lock/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/categories/Database/SQLP/page/2/">
                    <span>OLDER POSTS</span>
                <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
        </li>
        
        <li class="pagination-number">page 1 of 3</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 Yun Seok-joon. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/sjyun.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">Yun Seok-joon</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Seoul, South Korea
            </div>
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">no post found</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2015/11/10/Devops.Jenkins/">
                            <h3 class="media-heading">Install Jenkins</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Nov 10, 2015
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/20/01.01.modeling/">
                            <h3 class="media-heading">SQLP 1-1 데이터 모델링</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 20, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/20/01.02.modeling_performance/">
                            <h3 class="media-heading">SQLP 1-2 데이터 모델과 성능</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 20, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/21/02.01.sql.basic/">
                            <h3 class="media-heading">SQLP 2-1 SQL 기본</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 21, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/23/02.02.sql.adv/">
                            <h3 class="media-heading">SQLP 2-2-1 SET, Hierarchical Query, Sub-query</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 23, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/25/02.03.group/">
                            <h3 class="media-heading">SQLP 2-2-2 GROUP function</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 25, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/25/02.04.window/">
                            <h3 class="media-heading">SQLP 2-2-3 Window function</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 25, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/26/02.05.dcl/">
                            <h3 class="media-heading">SQLP 2-2-4 DCL</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 26, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/26/02.06.plsql/">
                            <h3 class="media-heading">SQLP 2-2-5 PL/SQL</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 26, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/27/02.07.optimizer/">
                            <h3 class="media-heading">SQLP 2-3 Optimizing SQL</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 27, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="no post found"
                data-message-one="1 post found"
                data-message-other="{n} posts found">
                59 posts found
            </p>
        </div>
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-kbuclmtqrwfmqogitsifpjr2mdxgukkqucv5th9u0chgrdjqgqfxwhpjxejt.min.js"></script>
<!--SCRIPTS END-->


    </body>
</html>
