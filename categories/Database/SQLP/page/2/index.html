
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Dev Star SJ">
    <title>Category: SQLP - Dev Star SJ</title>
    <meta name="author" content="Yun Seok-joon">
    
    
    
    <meta name="description" content="Sharing the common developer&apos;s try-on">
<meta property="og:type" content="blog">
<meta property="og:title" content="Dev Star SJ">
<meta property="og:url" content="http://DevStarSJ.github.io/categories/Database/SQLP/page/2/index.html">
<meta property="og:site_name" content="Dev Star SJ">
<meta property="og:description" content="Sharing the common developer&apos;s try-on">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dev Star SJ">
<meta name="twitter:description" content="Sharing the common developer&apos;s try-on">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/font-awesome.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox-thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Dev Star SJ</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://DevLunaSJ.github.com/" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.facebook.com/seokjoon.yun.9" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-facebook"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://plus.google.com/u/1/108379332089647292574" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-google-plus"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/in/sjyun/" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-linkedin"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:seokjoon.yun@gmail.com" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/01/03.02.sql.parsing/">
                            SQLP 3-1-2 SQL Parsing, DB Call, Block I/O
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-02-01T00:00:00+09:00">
	
		    Feb 01, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="3과목-SQL-고급-활용-및-Tuning"><a href="#3과목-SQL-고급-활용-및-Tuning" class="headerlink" title="3과목 SQL 고급 활용 및 Tuning"></a>3과목 SQL 고급 활용 및 Tuning</h1><h2 id="1장-Architecture-기반-Tuning"><a href="#1장-Architecture-기반-Tuning" class="headerlink" title="1장 Architecture 기반 Tuning"></a>1장 Architecture 기반 Tuning</h2><h3 id="1-2-SQL-Parsing"><a href="#1-2-SQL-Parsing" class="headerlink" title="1.2 SQL Parsing"></a>1.2 SQL Parsing</h3><h4 id="SQL-Parsing-과정"><a href="#SQL-Parsing-과정" class="headerlink" title="SQL Parsing 과정"></a>SQL Parsing 과정</h4><ol>
<li>사용자 입력 SQL</li>
<li>Semantic 검사 : 문법적 오류, 객체 존재 여부</li>
<li>Library Cache에서 검색 : Hash구조로 관리. SQL의 Hash값의 Bucket을 찾아봄<ul>
<li>Soft Parsing : Cache에서 찾아서 바로 실행단계로 넘어감</li>
<li>Hard Parsing : Cache에서 찾지 못해서 최적화 과정을 거치고 실행단계로 넘어감</li>
</ul>
</li>
<li>찾지 못했을 경우 최적화 수행  </li>
<li>최적화 결과를 Library Cache의 Hash Bucket chain에 연결  </li>
<li>해당 Execution Plan을 실행  </li>
</ol>
<ul>
<li>Optimizer : 사용자 SQL을 가장 빠르고 효율적인 처리경로를 선택해 주는 DBMS의 핵심엔진</li>
</ul>
<p>####C aching 된 SQL 공유</p>
<ul>
<li>공유조건 : 그냥 무조건 같은 SQL문이어야 한다.<ol>
<li>공백, 줄바꿈이 다른 경우 : X</li>
<li>대소문자가 다른 경우 : X</li>
<li>주석이 다른 경우 : X</li>
<li>OWNER명시 여부 (EMP 와 SCOTT.EMP) : X</li>
<li>Optimizer Hint 여부 : X</li>
<li>WHERE 절의 literal값이 다른 경우 : X</li>
</ol>
</li>
</ul>
<p>솔직히 1 ~ 5는 각 부서별 SQL표준을 정하면 되는데 6의 경우에는 Bind Variable을 사용할 수 밖에 없다.<br>Bind Variable을 사용하면 SQL 재사용율이 좋아진다.<br>하지만 Bind Variable을 사용하면 실행계획 생성시 통계정보를 활용하지 못한다.<br>(당연한 얘기다. 어떤 값이 들어올지 모르기 때문에 그냥 균등하다고 생각하고 실행계획을 작성한다.)  </p>
<ul>
<li><p>Bind Variable을 사용하지 않는게 좋은 경우</p>
<ol>
<li>DW, OLAP 환경에서의 Long Running Query : Parsing 소유시간에 비해 Execution 시간이 훨씬 길며, Parsing도 자주 일어나지 않는다.</li>
<li>WHERE절의 칼럼 Distinct 값이 적을 경우 : 그만큼 분포가 균일하지 않기 때문에 Histogram을 활용하는게 유리하다.</li>
</ol>
</li>
<li><p>Bind Variable Peeking (Sniffing)</p>
<ul>
<li>SQL이 처음 실행될때 Bind Variable 값을 살짝 훔쳐보고 Execution Plan을 작성</li>
<li>뒤에 어떻게 분포가 바뀔지 모르므로 상당히 위험한 기능</li>
<li>왠만해서는 해당 기능을 비활성화 하는게 좋음<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">SET</span> <span class="string">"_optim_peek_user_binds"</span> = <span class="literal">FALSE</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="Static-SQL-Dynamic-SQL"><a href="#Static-SQL-Dynamic-SQL" class="headerlink" title="Static SQL, Dynamic SQL"></a>Static SQL, Dynamic SQL</h4><ul>
<li>Static SQL : code 사이에 SQL문을 직접 기술 (Pro*C, Power Builder, SQLJ 등… ). Compile 단계에서 SQL 구문체크가 가능</li>
<li><p>Dynamic SQL : String 타입 변수에 SQL문을 저장 (현재 대부분의 경우)</p>
</li>
<li><p>Application Cursor Caching</p>
<ul>
<li>SQL문을 한번 Parsing한 후 Bind Variable 값만 바꿔가면서 반복적으로 수행</li>
<li>Java에서 <code>.setImplicitCachingEnabled(true)</code>로 한다던지 Statement를 닫지 않고 재사용하는 방법</li>
<li>Parse Call 한번에 Execute Call이 여러번 일어남 (일반적인 경우는 Parse, Execute Call의 수가 같음)</li>
</ul>
</li>
</ul>
<h3 id="1-3-Database-Call과-네트워크-부하"><a href="#1-3-Database-Call과-네트워크-부하" class="headerlink" title="1.3 Database Call과 네트워크 부하"></a>1.3 Database Call과 네트워크 부하</h3><h4 id="Call의-종류"><a href="#Call의-종류" class="headerlink" title="Call의 종류"></a>Call의 종류</h4><ul>
<li>SQL Cursor 작업 요청에 따른 구분<ul>
<li>Parse Call : SQL Parsing을 요청</li>
<li>Execute Call : SQL 실행을 요청</li>
<li>Fetch Call : SELECT문의 결과 데이터 전송을 요청</li>
</ul>
</li>
<li>Call 발생 위치에 따른 구분<ul>
<li>User Call : DBMS외부로부터 요청</li>
<li>Recursive Call : DBMS내부에서 발생하는 Call<ul>
<li>SQL Parsing 과정에서 발생하는 데이터 딕셔너리 조회</li>
<li>사용자 정의 함수/프로시저 내에서의 SQL수행</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="User-Call과-성능"><a href="#User-Call과-성능" class="headerlink" title="User Call과 성능"></a>User Call과 성능</h4><p>User Call은 시스템 확장성을 떨어뜨리는 가장 큰 요인 중 하나이므로 최소화 하려는 노력이 중요하다.</p>
<h5 id="1-One-SQL-구현-Loop-Query를-해소"><a href="#1-One-SQL-구현-Loop-Query를-해소" class="headerlink" title="1. One SQL 구현 : Loop Query를 해소"></a>1. One SQL 구현 : Loop Query를 해소</h5><ul>
<li>1번의 Call로 해결되는 Query는 5번의 Call로 해결되는 Query에 비해 5배의 확장성을 갖는 것이다.</li>
</ul>
<h5 id="2-Array-Processing-Array-단위-Fetch-Bulk-Insert-Update-Delete"><a href="#2-Array-Processing-Array-단위-Fetch-Bulk-Insert-Update-Delete" class="headerlink" title="2. Array Processing : Array 단위 Fetch, Bulk Insert/Update/Delete"></a>2. Array Processing : Array 단위 Fetch, Bulk Insert/Update/Delete</h5><ul>
<li>INSERT 할때 Array에 계속 담다가 1,000건이 쌓일 때마다 <code>executeBatch()</code> 실행 (Java)</li>
<li>SELECT 할때 <code>.setFetchSize(1000)</code>으로 1,000건 단위로 Fetch (Java)</li>
</ul>
<h5 id="3-부분범위처리-원리-활용"><a href="#3-부분범위처리-원리-활용" class="headerlink" title="3. 부분범위처리 원리 활용"></a>3. 부분범위처리 원리 활용</h5><ul>
<li>SQL*Plus에서 <code>set arraysize 100</code>으로 할 경우 301번의 Fetch Call로 30,000 rows를 읽는 것을 Trace에서 확인이 가능하다.</li>
<li>만약 10개의 record를 담는 block이 3개 있는 경우 ArraySize를 3으로 할 경우 총 10번의 Fetch Call이 발생하지만, Block I/O는 12번이 된다. (왜냐면 4번째 Call의 경우 Block 1에서 1 record만 읽고, Block 2에서 2 record만 읽는다. 즉 2번의 Block I/O가 발생한 것이다.)</li>
<li>즉, ArraySize를 무작정 키운다고 좋은게 아니다.</li>
</ul>
<h5 id="4-효과적인-화면-페이지-처리"><a href="#4-효과적인-화면-페이지-처리" class="headerlink" title="4. 효과적인 화면 페이지 처리"></a>4. 효과적인 화면 페이지 처리</h5><ul>
<li>Web에서 Page 단위로 게시물을 보여줄 경우 처음부터 다 읽어서 Fetch하면서 필요한 것만 보여주게 된다면 성능에 치명적이다.</li>
<li>필요한 Page부분만 읽도록 수정해야 한다. (뒤에서 자세히 다루겠다.)</li>
</ul>
<h5 id="5-분산-Query"><a href="#5-분산-Query" class="headerlink" title="5. 분산 Query"></a>5. 분산 Query</h5><p>원격에 있는 DB 간의 Table을 JOIN할 경우 성능을 높일 수 있는 방안은 ?</p>
<ol>
<li>실행계획을 보고 다음의 <code>Rows</code>수를 확인한다.<ul>
<li>실제 결과 데이터</li>
<li>각 Table 별로 필터 조건으로 걸러지는 데이터</li>
<li><code>REMOTE</code>로 원격으로 전송된 데이터</li>
</ul>
</li>
<li><code>/*+ driving_site(테이블명) */</code> Hint를 활용하여 어느 Server에서 JOIN을 수행하고 나머지 Server에서 원격으로 데이터를 전송하도록 조절한다.</li>
<li>결론적으로 네트워크를 통해 데이터 전송량을 줄이는게 핵심이다.</li>
</ol>
<h5 id="6-User-defined-Function-Procedure"><a href="#6-User-defined-Function-Procedure" class="headerlink" title="6. User-defined Function/Procedure"></a>6. User-defined Function/Procedure</h5><ul>
<li>Built-In Function/Procedure : Native code로 완전 compile된 형태이므로 엄청 빠르다.</li>
<li>User-defined Function/Procedure : 실행할때마다 Virtual Machine에서 별도 실행 엔진을 통해 호출되므로 느리다.</li>
</ul>
<ul>
<li>특히나 내부적으로 또다른 Query가 있을 경우에는 Execute Call, Fetch Call이 재귀적으로 일어난다.</li>
<li>그러므로 다음의 경우에만 제한으로 사용할 것을 권장한다.<ul>
<li>소량의 데이터를 조회할 경우</li>
<li>부분범위처리가 가능한 상황</li>
</ul>
</li>
<li>가급적으로 One SQL로 구현하고자 노력하는게 좋다. (JOIN, Scalar-Subquery)<ul>
<li>그 과정에서 별도의 Logic이 필요한 것을 따로 Table로 구현하는 방법도 있다.<ul>
<li>ex. 휴무일을 검사하는 Function 대신 업무일 Table을 생성해두고 <code>EXISTS</code>로 비교</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-4-DB-I-O-원리"><a href="#1-4-DB-I-O-원리" class="headerlink" title="1.4 DB I/O 원리"></a>1.4 DB I/O 원리</h3><h4 id="Block-I-O"><a href="#Block-I-O" class="headerlink" title="Block I/O"></a>Block I/O</h4><ul>
<li>모든 DBMS는 Block단위 I/O를 한다</li>
<li>1개의 record를 읽더라도 해당 Block 전체를 읽는다.</li>
<li>Buffer Cache, Disk상의 Datafile 모두 Block 단위 I/O로 읽는다.<ul>
<li>Datafile -&gt; DB Buffer Cache로 Block을 적재할 때</li>
<li>Datafile에서 Block을 직접 읽고 쓸때</li>
<li>DB Buffer Cache에서 Block을 읽고 쓸때</li>
<li>DB Buffer Cache -&gt; Datafile로 다시 데이터를 쓸때</li>
</ul>
</li>
</ul>
<h4 id="Buffer-Cache-Hit-Ratio"><a href="#Buffer-Cache-Hit-Ratio" class="headerlink" title="Buffer Cache Hit Ratio"></a>Buffer Cache Hit Ratio</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BCHR = (버퍼 캐시에서 바로 찾은 Block수 / 총 읽은 Block수) X 100</div></pre></td></tr></table></figure>
<blockquote>
<p>Fetch Call 에서 disk : 18 , query : 822 일 경우 총 읽은 Block수는 822, 버퍼 캐시에서 읽은 수는 822 - 18 = 804 이므로 BCHR = 97.8%가 된다.</p>
</blockquote>
<h4 id="Sequential-I-O-vs-Random-I-O"><a href="#Sequential-I-O-vs-Random-I-O" class="headerlink" title="Sequential I/O vs. Random I/O"></a>Sequential I/O vs. Random I/O</h4><ul>
<li>Sequential I/O : Index에서 Leaf Node를 따라 Scan하는 것과 Full Table Scan</li>
<li>Random I/O : Index에서 한 건을 읽기 위해 한 Block씩 접근하는 방식</li>
<li>Sequential 액세스의 비중을 높이고 Random 액세스의 발생량을 줄이는게 I/O 튜닝의 핵심이다.</li>
<li>Sequential 액세스의 효율을 높일려면 총 읽은 건수 중 결과집합으로 선택되는 비중을 높여야 한다. 즉 같은 결과를 얻기 위해 얼마나 적은 record를 읽느냐로 판단한다.</li>
<li>Index의 컬럼 및 그 순서를 조정하는게 가장 좋은 방법이다.</li>
</ul>
<h4 id="Single-Block-I-O-vs-MultiBlock-I-O"><a href="#Single-Block-I-O-vs-MultiBlock-I-O" class="headerlink" title="Single Block I/O vs. MultiBlock I/O"></a>Single Block I/O vs. MultiBlock I/O</h4><ul>
<li>Index : Single Block I/O (10g이후 Index Range Scan, Index Full Scan에서는 MultiBlock I/O로도 가능)</li>
<li>Table : MultiBlock I/O</li>
<li>대량의 데이터를 읽을 땐 MultiBlock I/O가 I/O Call을 줄일 수 있기 때문에 유리하다.</li>
</ul>
<h4 id="I-O-효율화-원리"><a href="#I-O-효율화-원리" class="headerlink" title="I/O 효율화 원리"></a>I/O 효율화 원리</h4><ul>
<li>필요한 최소 Block만 읽도록 SQL 작성</li>
<li>최적의 Optimizer 팩터 제공<ul>
<li>전략적 Index 구성</li>
<li>DBMS가 제공하는 기능 활용 : Index, Partition, Cluster, Window 함수</li>
</ul>
</li>
<li>필요하다면 Optimizer Hint를 활용하여 최적의 액세스 경로로 유도<ul>
<li>전체처리 최적화, 최초 응답속도 최적화 및 그밖에 파라메터들</li>
</ul>
</li>
<li>통계정보 제공</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/02/01/03.02.sql.parsing/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/02/01/03.02.sql.parsing/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/29/03.01.architecture/">
                            SQLP 3-1-1 Oracle Architecture
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-29T00:00:00+09:00">
	
		    Jan 29, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="3과목-SQL-고급-활용-및-Tuning"><a href="#3과목-SQL-고급-활용-및-Tuning" class="headerlink" title="3과목 SQL 고급 활용 및 Tuning"></a>3과목 SQL 고급 활용 및 Tuning</h1><h2 id="1장-Architecture-기반-Tuning"><a href="#1장-Architecture-기반-Tuning" class="headerlink" title="1장 Architecture 기반 Tuning"></a>1장 Architecture 기반 Tuning</h2><h3 id="1-1-Oracle-Architecture"><a href="#1-1-Oracle-Architecture" class="headerlink" title="1.1 Oracle Architecture"></a>1.1 Oracle Architecture</h3><p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/03.01.architecture.01.png?raw=true"></p>
<ol>
<li>Database : Disk에 저장된 data 집합<ul>
<li>Datafile</li>
<li>Redo Log File</li>
<li>Control File</li>
</ul>
</li>
<li>Instance : SGA(Shared Global Memory)와 이를 엑세스하는 process 집합<ul>
<li>Memory<ul>
<li>PGA (Process Global Area)<ul>
<li>Process 혹은 Thread 의 개별적인 메모리 공간</li>
<li>사용자마다 개별적으로 사용하는 공간</li>
<li>Data Sort, Session, Cursor 정보 저장</li>
</ul>
</li>
<li>SGA (System Global Area)<ul>
<li>Oracle Process 들이 접근하는 큰 공유 메모리</li>
<li>Serve Process와 Backgroung Process가 공용으로 사용</li>
<li>DB Buffer Cache, Shared Pool(Library Cache + Dictionay Cache), Log Buffer, Large Pool, Java Pool</li>
<li>직렬화 매커니즘 활용 (여러 Process가 동시에 사용) : Latch, Buffer Lock, Library  Cache Lock/Pin</li>
</ul>
</li>
</ul>
</li>
<li>Processes<ul>
<li>Server Process : 사용자의 명령어 처리<ul>
<li>SQL Parsing 및 최적화</li>
<li>Cursor를 열어서 block을 read</li>
<li>읽은 data를 정렬해서 client가 요청한 결과집합을 생성하여 network로 전송</li>
</ul>
</li>
<li>Background Process : User의 연결 유무와 상관없이 Background로 실행<ul>
<li>SMON (System Monitor) : DBMS의 CEO (모든 작업 총관리), 임시 segment,extent 정리, dictionary 관리, 재시작시 Instance 복구 담당</li>
<li>PMON (Process Monitor) : Server Process 관리, 잘못된 Process 파괴 및 자원복구, 잘못된 Trasaction 문제 해결</li>
<li>DBWn (Databaser Writers) : Buffer Cache의 Dirty Block을 Datafile(disk)에 저장</li>
<li>LGWR (Log Writer) : Log Buffer Entry(승인된 transaction)를 Redo Logfile에 기록</li>
<li>ARCn (Archiver) : 꽉 찬 Redo Log가 덮어 쓰여지기 전에 Archive Log Directory로 Backup</li>
<li>CKPT (Check Point)<ul>
<li>이전 CP 이후 변경사항을 datafile에 기록하고록 트리거링</li>
<li>그 정보들을 control file/datafile의 header에 기록 (저장된 data를 일치시키는 작업)</li>
<li>장애 복구시 CP 이후 Log 데이터만 disk에 기록함</li>
</ul>
</li>
<li>RECO (Recoverer Process) : 분산 시스템간의 Transaction을 맞춰주는 역할<ul>
<li>예를 들어서 서울에 있는 은행과 부산에 있는 은행간에 이체 작업을 물리적으로 다른 DB Server 간의 <em>two-phase commit</em><br>(양쪽 모두 prepare-phase 한 뒤, 둘 다 commit 한 것이 확인되지 않으면 RECO가 rollback 시킴.)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>1개의 Instance는 1개의 Database만 액세스</li>
<li>단, RAC(Real Application Cluster)에서는 여러 Instance가 하나의 Database 액세스 가능</li>
<li>1개의 Instance가 여러 Database를 액세스 할 수는 없음</li>
</ul>
<h3 id="1-2-DMBS-연결방식"><a href="#1-2-DMBS-연결방식" class="headerlink" title="1.2 DMBS 연결방식"></a>1.2 DMBS 연결방식</h3><ol>
<li>전용 서버(Dedicated Server) 방식<ul>
<li>Listener가 연결요청을 받으면 Server Process를 생성하여 사용자에게 제공</li>
<li>DBMS에 큰 부담을 주기 때문에 통상 Connectin Pooling 기법을 이용하여 반복 재사용함</li>
</ul>
</li>
<li>공유 서버(Shared Server) 방식<ul>
<li>Connection Pooling을 DBMS 내부에 구현</li>
<li>사용자는 Server Process에 직접 연결하는게 아니라 Dispatcher에 연결을 함</li>
<li>Dispatcher가 Request Queue에 등록하고, Response Queue에서 답변을 가져와서 사용자에게 전달</li>
</ul>
</li>
</ol>
<h3 id="1-3-File-구조"><a href="#1-3-File-구조" class="headerlink" title="1.3 File 구조"></a>1.3 File 구조</h3><h4 id="1-Datafile"><a href="#1-Datafile" class="headerlink" title="1. Datafile"></a>1. Datafile</h4><blockquote>
<p>Block &gt; Extent &gt; Segment &gt; Tablespace  &lt;-(1 : N)-&gt; Datafile</p>
</blockquote>
<ol>
<li>Block<ul>
<li>Record의 집합</li>
<li>data I/O 단위 (Oracle은 2KB ~ 64KB, MS-SQL은 8KB)</li>
<li>하나의 record만 필요하더라도 disk에서 buffer로 block 단위로 읽음</li>
<li>Optimizer 가 Index/Table Scan을 결정하는 기준은 record수가 아닌 block수</li>
</ul>
</li>
<li>Extent<ul>
<li>Block의 집합</li>
<li>Tablespace로부터 공간을 할당받는 단위 (Oracle 다양한 크기, MS-SQL 64KB)</li>
<li>Uniform Extent : Oracle은 Extent내의 Block은 하나의 Object가 독점</li>
<li>Mixed Extent : MS-SQL은 여러 Object가 나누어 사용</li>
</ul>
</li>
<li>Segemt<ul>
<li>Extent의 집합</li>
<li>Table, Index, Undo 등의 Object가 저장되는 공간</li>
<li>Object와 Segment는 1:1관계 이지만, Partition의 경우에는 1 : M 관계</li>
<li>1개의 Segment는 여러 datafile에 걸쳐 저장이 가능 (disk I/O 경합을 분산)</li>
</ul>
</li>
<li>Tablespace<ul>
<li>Segment를 담는 컨테이너, 여러 datafile로 구성</li>
</ul>
</li>
</ol>
<h4 id="2-Temporary-Tablespace-임시-데이터-파일"><a href="#2-Temporary-Tablespace-임시-데이터-파일" class="headerlink" title="2. Temporary Tablespace (임시 데이터 파일)"></a>2. Temporary Tablespace (임시 데이터 파일)</h4><ul>
<li>대량의 <code>Sort</code>(ORDER BY, Sort Merge JOIN), <code>Hash</code>(Hash JOIN) 작업 중 메모리가 부족한 경우 중간 결과집합 저장</li>
<li>임시 데이터이므로 Redo 정보를 생성하지 않음. 복구가 안되고 백업도 필요없음.</li>
<li>Oracle은 여러개 생성하여 사용자별로 할당이 가능 (MS-SQL은 1개의 tempdb를 전역으로 사용)<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLESPACE</span> big_temp;</div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> scott <span class="keyword">TEMPORARY</span> <span class="keyword">TABLESPACE</span> big_temp;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-Logfile"><a href="#3-Logfile" class="headerlink" title="3. Logfile"></a>3. Logfile</h4><ul>
<li><p><code>Fast Commit</code> 매커니즘</p>
<ul>
<li>갱신작업 내용을 메모리상 Buffer Block에만 기록한체 disk에 기록되지 않았더라도 Redo Log를 믿고 빠르게 Commit</li>
<li>장애발생시 Logfile을 이용해서 언제든 복구가 가능</li>
</ul>
</li>
<li><p>Online Redo Log (MS-SQL에서는 Transaction Log)</p>
<ul>
<li>데이터 유실  대비용으로 수행했던 Transaction을 기록</li>
<li>사고 발생시 마지막 CP이후 작업 내용을 재현 (캐시 복구)</li>
<li>최소 2개 이상의 파일로 구성. 하나의 파일이 꽉 차면 다른 파일로 Log Switching. 모든 파일 꽉차면 첫번째 파일 재사용 (Round-robin)</li>
</ul>
</li>
<li><p>Archived(=Offline) Redo Log (MS-SQL에는 없음)</p>
<ul>
<li>Online Redo Log가 재사용되기 전 다른 위치로 백업해 둔 파일</li>
</ul>
</li>
</ul>
<h4 id="4-Memory"><a href="#4-Memory" class="headerlink" title="4. Memory"></a>4. Memory</h4><h5 id="4-1-SGA-System-Global-Area"><a href="#4-1-SGA-System-Global-Area" class="headerlink" title="4.1 SGA (System Global Area)"></a>4.1 SGA (System Global Area)</h5><ul>
<li>DB Buffer Cache<ul>
<li>Datafile에서 읽은 Block의 Cache Area</li>
<li>Buffer Lock을 이용한 직렬화</li>
<li>Buffer 상태<ul>
<li>Free Buffer : Clean 상태이거나 disk와 내용이 같아서 언제든지 덮어써도 무방</li>
<li>Dirty Buffer : 변경이 발생했지만 disk에 기록되기 전인 상태. 재사용하려면 disk에 기록하여 Free Buffer로 만들어야 함</li>
<li>Pinned Buffer : 현재 I/O가 진행중</li>
</ul>
</li>
<li>Buffer 재사용 알고리즘<ul>
<li>LRT (Least Recently Used) 알고리즘 사용</li>
<li>LRU 체인을 이용하여 사용빈도 순으로 위치를 옮김</li>
<li>Free Buffer가 필요할 때 LRU End 쪽 (가장 액세스 빈도가 낮음) 부터 사용</li>
</ul>
</li>
</ul>
</li>
<li>Shared Pool<ul>
<li>Library Cache<ul>
<li>SQL문, Execution Plan, Stored Procedure를 저장</li>
<li>Soft Parsing: 해당 SQL문에 대한 Execution Plan이 Shared Pool에 있어서 바로 재사용</li>
<li>Hard Parsing : Shared Pool에 내용이 없어서 Optimizer를 이용해서 Execution Plan을 다시 생성</li>
</ul>
</li>
<li>Dictionary Cache<ul>
<li>말그대로 딕셔너리 정보를 캐시 (여러 Object의 메타정보)</li>
</ul>
</li>
</ul>
</li>
<li>Log Buffer<ul>
<li>DB Buffer Cache의 모든 변경사항을 저장</li>
<li>DB Block Buffer에 기록하기 전에 Redo Log Buffer에 먼저 기록. LGWR이 주기적으로 Redo Logfile에 기록. 늦어도 commit 시점에는 기록 (Log Force at commit)</li>
<li>Dirty Buffer를 datafile에 기록하기 전에 항상 Log Buffer를 먼저 Logfile에 기록 (Write Ahead Logging)</li>
<li>왜냐면 인스턴스 장애 발생시 commit하지 않은 transaction을 rollback하기 위함. 만약 datafile을 먼저 기록해 보리면 최종 commit 되지 않은 transaction이 반영되어짐.</li>
</ul>
</li>
</ul>
<h5 id="4-1-PGA-Process-Global-Area"><a href="#4-1-PGA-Process-Global-Area" class="headerlink" title="4.1 PGA (Process Global Area)"></a>4.1 PGA (Process Global Area)</h5><ul>
<li><p>UGA (User Global Area)</p>
<ul>
<li>Session별로 할당<ul>
<li>Dedicated Server (전용 서버) 방식에서는 PGA에 할당 (1:1)</li>
<li>Shared Server (공유 서버) 방식에서는 SGA에 할당 : Large Pool (설정되었을 경우). 그렇지 않을땐 Shared Pool</li>
</ul>
</li>
</ul>
</li>
<li><p>CGA (Call Global Area)</p>
<ul>
<li>DB Call (Parse, Execute, Fetch)이 진행되는 동안만 필요한 데이터</li>
<li>Recursive Call이 발생하면 그 안의 (Parse, Execute, Fetch)에 대해서도 추가로 할당</li>
<li>Call이 끝나면 바로 해제되어 PGA로 반환</li>
</ul>
</li>
<li><p>Sort Area</p>
<ul>
<li>Sort 작업이 진행되는 동안 조금씩 Chunk 단위로 할당</li>
<li>DML은 하나의 Execute4 Call에서 처리가 완료되므로 CGA에 할당</li>
<li>SELECT의 경우 중단 단계에서는 CGA에 할당되고, 최종 결과집합 출력하기 전에는 UGA에 할당</li>
</ul>
</li>
</ul>
<h4 id="5-Wait-Event"><a href="#5-Wait-Event" class="headerlink" title="5. Wait Event"></a>5. Wait Event</h4><p>DBMS 내부 Process들이 기다려야 할 상황에서 sleep상태로 대기하게 되는데, 그 정보가 공유 메모리 영역에 저장됨.  </p>
<ul>
<li>Respone Time Analysis</li>
</ul>
<p>Session 또는 시스템 전체에 발생하는 병목 현상과 그 원인을 찾아 해결</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Response Time = Service Time + Wait Time</div><div class="line">              = CPU Time     + Queue Time</div></pre></td></tr></table></figure>
<ul>
<li>CPU Time : Parsing에 소비한 시간인지 Query 자체 수행시간인지 분석</li>
<li>Wait Time : 각각 발생한 Wait Event를 분석해 가장 많은 시간을 소비한 이벤트 중심으로 해결방안 모색</li>
</ul>
<ul>
<li>Wait Event<ul>
<li>라이브러리 캐시 부하<ul>
<li>라이브러리 캐시에서 SQL 커서를 찾고 최적화하는 과정에서 발생한 경합<ul>
<li>latch: shared pool</li>
<li>latch: library cache</li>
</ul>
</li>
<li>수행중인 SQL이 참조하는 오브젝트에 다른 사용자가 DDL을 수행할 경우<ul>
<li>library cache lock</li>
<li>library cache pin</li>
</ul>
</li>
</ul>
</li>
<li>DB Call과 네트워크 부하 : application, network 간의 소모시간<ul>
<li>SQL*Net message from client : DB 경합과 상관없음. client로부터 다음 명령이 올때까지 Idle 상태로 대기</li>
<li>SQL*Net message to client</li>
<li>SQL*Net more data from client</li>
<li>SQL*Net more data to client</li>
</ul>
</li>
<li>Disk I/O 부하<ul>
<li>db file sequential read : Single Block I/O 수행시 발생</li>
<li>db file scattered read : Multi Block I/O 수행시 발생</li>
<li>direct patch read</li>
<li>direct patch write</li>
<li>direct patch write temp</li>
<li>direct path read temp</li>
<li>db file parallel read</li>
</ul>
</li>
<li>Buffer Cache 경합<ul>
<li>latch: cache buffers chains</li>
<li>latch: cache buffers lru chaine</li>
<li>buffer busy waits</li>
<li>free buffer waits</li>
</ul>
</li>
<li>Lock 관련 Wait Event<ul>
<li>enq: TM - contention</li>
<li>enq: TX - row lock contention</li>
<li>enq: TX - index contention</li>
<li>enq: TX - index contention</li>
<li>enq: TX - allocate ITL entry</li>
<li>enq: TX contention</li>
<li>latch free : latch를 여러번(2000번 가량) 요청했지만 계속 사용 중인 경우 잠시 Wait 상태로 빠짐</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="더-자세한-내용을-알고-싶으면-아래-slide를-참고하세요"><a href="#더-자세한-내용을-알고-싶으면-아래-slide를-참고하세요" class="headerlink" title="더 자세한 내용을 알고 싶으면 아래 slide를 참고하세요."></a>더 자세한 내용을 알고 싶으면 아래 slide를 참고하세요.</h5><p>더 자세한 내용은 <code>Oracle 성능 고도화 원리와 해법</code> 책을 참고해야 합니다.</p>
<ul>
<li>Oracle Architecture : <a href="http://www.slideshare.net/seokjoonyun9/warevalley-orange-db-study2015-0320-oracle-architecture" target="_blank" rel="external">http://www.slideshare.net/seokjoonyun9/warevalley-orange-db-study2015-0320-oracle-architecture</a></li>
<li>DB Buffer Cache : <a href="http://www.slideshare.net/seokjoonyun9/2015-0327-db-buffer-cache" target="_blank" rel="external">http://www.slideshare.net/seokjoonyun9/2015-0327-db-buffer-cache</a></li>
<li>Redo Log : <a href="http://www.slideshare.net/seokjoonyun9/2015-0403-redo-undo" target="_blank" rel="external">http://www.slideshare.net/seokjoonyun9/2015-0403-redo-undo</a></li>
<li>Transaction Isolation Level : <a href="http://www.slideshare.net/seokjoonyun9/2015-0409-consistency" target="_blank" rel="external">http://www.slideshare.net/seokjoonyun9/2015-0409-consistency</a></li>
<li>Wait Event : <a href="http://www.slideshare.net/seokjoonyun9/oracle-architecture2015-0429-wait-event-and-sharedpool" target="_blank" rel="external">http://www.slideshare.net/seokjoonyun9/oracle-architecture2015-0429-wait-event-and-sharedpool</a></li>
<li>Oracle Lock : <a href="http://www.slideshare.net/seokjoonyun9/2015-0529-oracle-lock" target="_blank" rel="external">http://www.slideshare.net/seokjoonyun9/2015-0529-oracle-lock</a></li>
<li>TX Lock : <a href="http://www.slideshare.net/seokjoonyun9/20150605-oracle-tx-lock" target="_blank" rel="external">http://www.slideshare.net/seokjoonyun9/20150605-oracle-tx-lock</a></li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/29/03.01.architecture/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/01/29/03.01.architecture/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/27/02.07.optimizer/">
                            SQLP 2-3 Optimizing SQL
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-27T00:00:00+09:00">
	
		    Jan 27, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="2과목-SQL-기본-및-활용"><a href="#2과목-SQL-기본-및-활용" class="headerlink" title="2과목 SQL 기본 및 활용"></a>2과목 SQL 기본 및 활용</h2><ul>
<li>20문제</li>
<li>각 상황별로 SQL문 작성이 가능할 정도로 연습해야 합니다.</li>
<li>기본적인 SQL문법 및 함수는 생략하고 Tuning에 활용될수 있는 것 위주로 정리하고자 합니다.</li>
</ul>
<h3 id="3장-SQL-최적화-기본-원리"><a href="#3장-SQL-최적화-기본-원리" class="headerlink" title="3장 SQL 최적화 기본 원리"></a>3장 SQL 최적화 기본 원리</h3><p>여기서는 간단히 다루고 3과목에서 자세히 다룰 예정이므로 그냥 넘어가도 됩니다.<br>(아마 SQPD의 경우 2과목까지가 범위이므로 SQLD용 문제를 내기위한 용도인듯 합니다.)</p>
<h4 id="Optimizer"><a href="#Optimizer" class="headerlink" title="Optimizer"></a>Optimizer</h4><ul>
<li>Optimizer : SQL문에 대한 최적의 실행 방법을 결정하는 역할</li>
<li>Execution Plan (실행계획) : Optimizer가 생성한 최적의 실행 계획</li>
</ul>
<ul>
<li><p>Optimizer 종류</p>
<ul>
<li>RBO (Rule-based Optimizer) : 규칙(우선 순위)를 가지고 실행계획 생성</li>
<li>CBO (Cost-based Optimizer) : 통계정보를 기반으로 여러가지 실행계획을 생성하여 그중 최저비용의 실행계획을 선택</li>
</ul>
</li>
<li><p>Rule-based Optimizer 규칙</p>
<ol>
<li>Single row by rowid</li>
<li>Sigle row by cluster join</li>
<li>Single row by hash cluster key with unique or primary key</li>
<li>Single row by unique or primary key</li>
<li>Cluster join</li>
<li>Hash cluster key</li>
<li>Indexed cluster key</li>
<li>Composite index</li>
<li>Single column sindex</li>
<li>Bounded range search on indexed columns</li>
<li>Unbounded range search on indexed columns</li>
<li>Sort merge join</li>
<li>MAX or MIN of indexed column</li>
<li>ORDER BY on indexed column</li>
<li>Full table scan</li>
</ol>
</li>
</ul>
<p>요약하자면</p>
<blockquote>
<p>Single row (rowid &lt; unique or primary key) &lt;&lt; Index ( Equal (composite &lt; single) &lt;&lt; Range (bounded &lt; unbounded) ) &lt;&lt; Full table scan</p>
</blockquote>
<h4 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h4><h5 id="1-B-Tree-Index"><a href="#1-B-Tree-Index" class="headerlink" title="1. B-Tree Index"></a>1. B-Tree Index</h5><ul>
<li>구성<ul>
<li>Root Block : Branch Block 중 가장 상위 Block</li>
<li>Branch Block : 다음 단계를 가리키는 Pointer를 가지고 있음</li>
<li>Leaf Block : Index를 구성하는 칼럼의 데이터와 rowid, 인접한 Leaf Block의 Pointer를 가지고 있음</li>
</ul>
</li>
</ul>
<h5 id="2-Cluster-Index-MS-SQL-IOT-Oracle"><a href="#2-Cluster-Index-MS-SQL-IOT-Oracle" class="headerlink" title="2. Cluster Index (MS-SQL) , IOT (Oracle)"></a>2. Cluster Index (MS-SQL) , IOT (Oracle)</h5><p>PK순으로 저장. Index의 Leaf Block에 Table 의 모든 데이터 저장</p>
<h5 id="3-Bitmap-Index"><a href="#3-Bitmap-Index" class="headerlink" title="3. Bitmap Index"></a>3. Bitmap Index</h5><p>일종의 Hash + Linked List 형태</p>
<h5 id="4-FBI-Function-Based-Index"><a href="#4-FBI-Function-Based-Index" class="headerlink" title="4. FBI (Function-Based Index)"></a>4. FBI (Function-Based Index)</h5><p>함수값 순으로 Index에 저장</p>
<h4 id="Full-Table-Scan-vs-Index-Scan"><a href="#Full-Table-Scan-vs-Index-Scan" class="headerlink" title="Full Table Scan vs Index Scan"></a>Full Table Scan vs Index Scan</h4><ul>
<li><p>Optimizer 가 Full Table Scan을 하는 경우</p>
<ul>
<li>SQL에 조건(WHERE)이 없을 경우</li>
<li>조건은 있는데 사용 가능한 INDEX가 없는 경우</li>
<li>Optimizer가 판단하여 Full Table Scan이 더 유리할때 : Index는 Single Block I/O, Table은 Multi Block I/O</li>
<li>기타 : 병렬처리, Hint 등…</li>
</ul>
</li>
<li><p>Index Scan 종류</p>
<ul>
<li>Index Unique Scan : Unique Index에서 = 조건으로 검색</li>
<li>Index Range Scan : 조건이 = 가 아니거나 Non-unique Index를 이용</li>
<li>Index Range Scan Descending : MIN, MAX 값등을 쉽게 찾기 위해서 사용</li>
<li>Index Fast Scan : 검색하는 모든 컬럼이 Index에 포함된 경우 Table을 찾지않고 Index만으로 검색</li>
<li>Index Skip Scan : Index의 선두 컬럼이 검색 조건에 없을 경우 사용하는 방법</li>
</ul>
</li>
</ul>
<h4 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h4><ul>
<li><p>NL Join (Nested-loop)</p>
<ul>
<li>Driving Table을 먼저 읽은 다음에 Outer Table과 JOIN</li>
<li>Driving Table에서 조건에 맞는 모든 row 만큼 JOIN이 이루어지므로 선행 테이블에서 작업량을 줄이는 것이 중요</li>
<li>양쪽 중 한쪽만 Index가 있는 경우 Outer Table쪽의 Index를 사용하는 것이 유리 (Driving은 Full Scan)</li>
<li>JOIN 과정은 random access</li>
</ul>
</li>
<li><p>Sort Merge Join</p>
<ul>
<li>Join 칼럼을 기준으로 데이터를 정렬한 뒤에 JOIN을 수행</li>
<li>대량의 JOIN일 경우 NL Join의 random access보다 유리</li>
</ul>
</li>
<li><p>Hash Join</p>
<ul>
<li>선행 테이블(Build Input)에서 JOIN하는 컬럼의 Hash값을 메모리에 생성</li>
<li>후행 테이블(Prove Input)에 Hash값을 메모리에서 찾아서 JOIN</li>
<li>범위 검색은 불가능 하고 = 조건으로만 가능</li>
</ul>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/27/02.07.optimizer/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/01/27/02.07.optimizer/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/26/02.06.plsql/">
                            SQLP 2-2-5 PL/SQL
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-26T01:00:00+09:00">
	
		    Jan 26, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="2과목-SQL-기본-및-활용"><a href="#2과목-SQL-기본-및-활용" class="headerlink" title="2과목 SQL 기본 및 활용"></a>2과목 SQL 기본 및 활용</h2><ul>
<li>20문제</li>
<li>각 상황별로 SQL문 작성이 가능할 정도로 연습해야 합니다.</li>
<li>기본적인 SQL문법 및 함수는 생략하고 Tuning에 활용될수 있는 것 위주로 정리하고자 합니다.</li>
</ul>
<h3 id="2장-SQL-활용-5"><a href="#2장-SQL-활용-5" class="headerlink" title="2장 SQL 활용 (#5)"></a>2장 SQL 활용 (#5)</h3><h4 id="PL-SQL-Procedural-Language-SQL"><a href="#PL-SQL-Procedural-Language-SQL" class="headerlink" title="PL/SQL (Procedural Language/SQL)"></a>PL/SQL (Procedural Language/SQL)</h4><h5 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h5><ul>
<li>Block 구조로 되어 있어 각 기능별로 모듈화가 가능</li>
<li>변수, 상수 등을 선언하여 SQL 문장 간 값을 교환</li>
<li>IF, LOOP 등의 절차형 언어를 사용하여 프로그램이 가능</li>
<li>DBMS 정의 에러/사용자 정의 에러를 사용</li>
<li>Oracle에 내장되어 있으므로 다른 Oracle Server로 옮길수 있음</li>
<li>여러 SQL문장을 Block으로 묶어서 한번에 서버로 보내기 때문에 통신량을 줄일수 있음</li>
<li>Server에서 수행되므로 Application의 성능을 향상</li>
</ul>
<h5 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h5><ul>
<li>DECLARE : BEGIN ~ END 사이에 변수, 인수에 대한 정의 및 데이터 타입 선언</li>
<li>BEGIN : PL/SQL 시작<ul>
<li>EXCEPTION : BEGIN ~ END 에서 실행되는 SQL문에서 발생한 에러를 처리 (선택항목)</li>
</ul>
</li>
<li>END : PL/SQL 종료</li>
</ul>
<h5 id="문법-Syntax"><a href="#문법-Syntax" class="headerlink" title="문법 (Syntax)"></a>문법 (Syntax)</h5><ul>
<li>생성<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">PROCEDURE</span> 명칭</div><div class="line">&#123;</div><div class="line">  argument1 [<span class="keyword">mode</span>] data_type1,</div><div class="line">  argument2 [<span class="keyword">mode</span>] data_type2,</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">IS</span> [<span class="keyword">AS</span>]</div><div class="line">...</div><div class="line"><span class="keyword">BEGIN</span></div><div class="line">...</div><div class="line"><span class="keyword">EXCEPTION</span></div><div class="line">...</div><div class="line"><span class="keyword">END</span>;</div><div class="line">/</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>mode : IN (입력) , OUT (출력) , INOUT(입출력)</li>
</ul>
<ul>
<li>삭제<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> 명칭;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h5><p>DEPT table에 새로운 부서를 입력하는데,부서번호가 이미 존재하지 않을때만 입력하고 존재할 경우에는 그냥 종료되는 PROCEDURE를 작성해보자.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">CREATE OR REPLACE PROCEDURE INPUT_DEPT</div><div class="line">(</div><div class="line">  v_deptno      in    NUMBER,</div><div class="line">  v_dname       in    VARCHAR2,</div><div class="line">  v_loc         in    VARCHAR2,</div><div class="line">  v_result      out   VARCHAR2</div><div class="line">)</div><div class="line">IS</div><div class="line">is_exist    NUMBER := 0;</div><div class="line">BEGIN</div><div class="line">    SELECT COUNT(*) INTO is_exist FROM DEPT WHERE DEPTNO = v_deptno AND ROWNUM = 1;</div><div class="line">    IF is_exist &gt; 0 THEN</div><div class="line">        v_result := '이미 등록된 부서번호';</div><div class="line">    ELSE</div><div class="line">        INSERT INTO DEPT (DEPTNO, DNAME, LOC) VALUES (v_deptno, v_dname, v_loc);</div><div class="line">        COMMIT;</div><div class="line">        v_result := '입력 완료';</div><div class="line">    END IF;</div><div class="line">EXCEPTION</div><div class="line">    WHEN OTHERS THEN</div><div class="line">        ROLLBACK;</div><div class="line">    v_result := '에러 발생';</div><div class="line">END;</div><div class="line">/</div></pre></td></tr></table></figure>
<p>실행을 시켜 보겠다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EXECUTE INPUT_DEPT(10,&apos;DEV&apos;,&apos;SEOUL&apos;,:result)</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.06.plsql.01.png?raw=true"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EXECUTE INPUT_DEPT(60,&apos;NEW_DEV&apos;,&apos;SANGAM&apos;,:result)</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.06.plsql.02.png?raw=true"></p>
<h4 id="User-Defined-Function"><a href="#User-Defined-Function" class="headerlink" title="User Defined Function"></a>User Defined Function</h4><ul>
<li>Function는 Procedure와는 다르게 반드시 1개의 값을 RETURN해야 한다. (SUM, NVL 같은 내장 함수를 생각하면 이해가 쉽다.)</li>
</ul>
<ul>
<li>ABS 함수 구현 : 절대값을 RETURN<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">CREATE OR REPLACE FUNCTION ABS_NUM</div><div class="line">(v_input IN NUMBER)</div><div class="line">    RETURN NUMBER</div><div class="line">IS</div><div class="line">    v_return NUMBER := 0;</div><div class="line">BEGIN</div><div class="line">    if v_input &gt;= 0 THEN</div><div class="line">        v_return := v_input;</div><div class="line">    ELSE</div><div class="line">        v_return := v_input * -1;</div><div class="line">    END IF;</div><div class="line">    RETURN v_return;</div><div class="line">END;</div><div class="line">/</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ABS_NUM(<span class="number">-20</span>), ABS_NUM(<span class="number">3</span>) <span class="keyword">FROM</span> DUAL;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.06.plsql.03.png?raw=true"></p>
<h4 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h4><ul>
<li>특정 Table에 DML (INSERT, UPDATE, DELETE)문이 수행했을 때 자동으로 동작 (사용자 실행이 아닌 DBMS가 실행)</li>
<li>DBMS에서 실행을 하는 것이므로 DB에 바로 적용됨. (COMMIT, ROLLBACK이 불가)</li>
</ul>
<ul>
<li>Syntax (문법)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">TRIGGER</span> trigger_name  <span class="comment">-- TRIGGER 명칭</span></div><div class="line"><span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span>                            <span class="comment">-- 아래 작업이 일어나기 전(BEFORE) 또는 후(AFTER)에 실행</span></div><div class="line"><span class="keyword">INSERT</span> | <span class="keyword">UPDATE</span> | <span class="keyword">DELETE</span> <span class="keyword">ON</span> table_name    <span class="comment">-- 해당 table에 해당 작업이 일어났을 경우</span></div><div class="line">[ <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> ]                          <span class="comment">-- 행 트리거 (행 데이터 제어가능), 없으면 문장 트리거 (각 행 데이터 제어 불가)</span></div><div class="line">[ <span class="keyword">WHEN</span> (condition) ]                      <span class="comment">-- 해당 조건에 맞을때에만 실행</span></div><div class="line">PL/<span class="keyword">SQL</span> block...</div></pre></td></tr></table></figure>
<ul>
<li>행의 데이터는 <code>:NEW.column_name</code> , <code>:OLD.column_name</code> 으로 제어가 가능하다.<ul>
<li>INSERT : <code>:NEW</code> (입력되는 ROW)</li>
<li>UPDATE : <code>:NEW</code> (변경된 새로운 값), <code>:OLD</code> (변경 전의 값)</li>
<li>DELTE : <code>:OLD</code> (삭제된 값)</li>
</ul>
</li>
</ul>
<ul>
<li>예</li>
</ul>
<p>쇼핑몰의 경우</p>
<ul>
<li>하루 수만건의 주문이 들어옴</li>
<li>직원들은 일자별, 상품별 총 판매수량 및 주문실적으로 온라인으로 조회함</li>
</ul>
<p>이럴 경우 매번 수만건의 데이터로 집계를 낼려면 서버 부하가 크다.<br>Trigger를 이용하여 주문이 들어올 때마다 집계를 계산하여 별도 Table에 보관하면 된다.</p>
<ul>
<li><p>Table 생성</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ORDER_LIST</div><div class="line">(</div><div class="line">    ORDER_DATE  <span class="built_in">CHAR</span>(<span class="number">8</span>)         <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    PRODUCT     VARCHAR2(<span class="number">10</span>)    <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    QTY         <span class="built_in">NUMBER</span>          <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    AMOUNT      <span class="built_in">NUMBER</span>          <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SALES_PER_DATE</div><div class="line">(</div><div class="line">    SALE_DATE   <span class="built_in">CHAR</span>(<span class="number">8</span>)         <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    PRODUCT     VARCHAR2(<span class="number">10</span>)    <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    QTY         <span class="built_in">NUMBER</span>          <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    AMOUNT      <span class="built_in">NUMBER</span>          <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">);</div></pre></td></tr></table></figure>
</li>
<li><p>Trigger 생성</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">TRIGGER</span> SUM_SALES</div><div class="line">    <span class="keyword">AFTER</span>   <span class="keyword">INSERT</span>                  </div><div class="line">    <span class="keyword">ON</span>      ORDER_LIST              <span class="comment">-- ORDER_LIST table에 INSERT 작업 후에</span></div><div class="line">    <span class="keyword">FOR</span>     <span class="keyword">EACH</span> <span class="keyword">ROW</span>                <span class="comment">-- 행 트리거로 실행</span></div><div class="line"><span class="keyword">DECLARE</span></div><div class="line">    o_date  ORDER_LIST.ORDER_DATE%<span class="keyword">TYPE</span>;</div><div class="line">    o_prod  ORDER_LIST.PRODUCT%TYPE;</div><div class="line"><span class="keyword">BEGIN</span></div><div class="line">    o_date := :NEW.ORDER_DATE;</div><div class="line">    o_prod := :NEW.PRODUCT;</div><div class="line"></div><div class="line">    <span class="keyword">UPDATE</span> SALES_PER_DATE</div><div class="line">       <span class="keyword">SET</span> QTY    = QTY    + :NEW.QTY,</div><div class="line">           AMOUNT = AMOUNT + :NEW.AMOUNT</div><div class="line">     <span class="keyword">WHERE</span> SALE_DATE = o_date</div><div class="line">       <span class="keyword">AND</span> PRODUCT    = o_prod;</div><div class="line"></div><div class="line">    IF SQL%NOTFOUND THEN</div><div class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> SALES_PER_DATE</div><div class="line">        <span class="keyword">VALUES</span> (o_date, o_prod, :NEW.QTY, :NEW.AMOUNT);</div><div class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</div><div class="line"><span class="keyword">END</span>;</div><div class="line">/</div></pre></td></tr></table></figure>
</li>
<li><p>데이터 입력 및 결과 확인</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ORDER_LIST <span class="keyword">VALUES</span> (<span class="string">'20160127'</span>,<span class="string">'Orange'</span>, <span class="number">2</span>, <span class="number">10000</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ORDER_LIST <span class="keyword">VALUES</span> (<span class="string">'20160127'</span>,<span class="string">'Orange'</span>, <span class="number">5</span>, <span class="number">20000</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ORDER_LIST <span class="keyword">VALUES</span> (<span class="string">'20160127'</span>,<span class="string">'PetaSQL'</span>, <span class="number">1</span>, <span class="number">100</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ORDER_LIST <span class="keyword">VALUES</span> (<span class="string">'20160127'</span>,<span class="string">'ChakraMAX'</span>, <span class="number">1</span>, <span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ORDER_LIST;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SALES_PER_DATE;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.06.plsql.04.png?raw=true"></p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/26/02.06.plsql/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/01/26/02.06.plsql/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/26/02.05.dcl/">
                            SQLP 2-2-4 DCL
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-26T00:00:00+09:00">
	
		    Jan 26, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="2과목-SQL-기본-및-활용"><a href="#2과목-SQL-기본-및-활용" class="headerlink" title="2과목 SQL 기본 및 활용"></a>2과목 SQL 기본 및 활용</h2><ul>
<li>20문제</li>
<li>각 상황별로 SQL문 작성이 가능할 정도로 연습해야 합니다.</li>
<li>기본적인 SQL문법 및 함수는 생략하고 Tuning에 활용될수 있는 것 위주로 정리하고자 합니다.</li>
</ul>
<h3 id="2장-SQL-활용-4"><a href="#2장-SQL-활용-4" class="headerlink" title="2장 SQL 활용 (#4)"></a>2장 SQL 활용 (#4)</h3><h4 id="DCL-Data-Control-Langeage"><a href="#DCL-Data-Control-Langeage" class="headerlink" title="DCL (Data Control Langeage)"></a>DCL (Data Control Langeage)</h4><ul>
<li>USER 생성 및 권한 관리에 관한 내용</li>
<li>DBMS별로 구조 및 내용이 많이 다름 (여기서는 Oracle 위주로 진행)</li>
</ul>
<h5 id="USER-생성"><a href="#USER-생성" class="headerlink" title="USER 생성"></a>USER 생성</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 사용자명 <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> 비밀번호;</div></pre></td></tr></table></figure>
<h5 id="권한부여"><a href="#권한부여" class="headerlink" title="권한부여"></a>권한부여</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> 권한 <span class="keyword">TO</span> 사용자;     <span class="comment">-- 권한 부여</span></div><div class="line"><span class="keyword">REVOKE</span> 권한 <span class="keyword">FROM</span> 사용자;  <span class="comment">-- 권한 회수</span></div></pre></td></tr></table></figure>
<p>앞서 본 사용자 생성 작업을 하기 위해서는 <code>CREATE USER</code> 권한이 필요함<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="keyword">TO</span> 사용자명;</div></pre></td></tr></table></figure></p>
<p>하지만 생성된 USER는 session 연결도 못한다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> <span class="keyword">SESSION</span> <span class="keyword">TO</span> 사용자명;</div></pre></td></tr></table></figure></p>
<p>session 연결을 하였다 하더라도 table 생성 권한이 없다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">TO</span> 사용자명;</div></pre></td></tr></table></figure></p>
<h5 id="OBJECT-권한-관리"><a href="#OBJECT-권한-관리" class="headerlink" title="OBJECT 권한 관리"></a>OBJECT 권한 관리</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> 권한 <span class="keyword">ON</span> 오브젝트 <span class="keyword">TO</span> 사용자;</div></pre></td></tr></table></figure>
<ul>
<li>OBJECT 별 권한목록<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- Table     : DELETE, INSERT, SELECT, UPDATE, ALTER, INDEX, REFERENCES</div><div class="line">- View      : DELETE, INSERT, SELECT, UPDATE</div><div class="line">- SEQUENCE  :                 SELECT,         ALTER</div><div class="line">- PROCEDURE : EXECUTE</div></pre></td></tr></table></figure>
</li>
</ul>
<p>기본적으로 자신이 생성하지 않은 object에는 접근이 불가능하다.<br>object 생성자가 그것을 활용할 사람에게 권한을 부여해야만 사용이 가능하다.  </p>
<h5 id="Role"><a href="#Role" class="headerlink" title="Role"></a>Role</h5><p>사용자를 새로 생성할때마다 권한을 다 부여하는 것은 번거로운 작업이다.<br>Role을 생성하여 Role에다가 여러가지 역할을 부여하고, 사용자에게 해당 Role에 대한 권한을 주면 한방에 해결된다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="keyword">ROLE</span>명칭          <span class="comment">-- ROLE 생성</span></div><div class="line"><span class="keyword">GRANT</span> 권한[, ...] <span class="keyword">TO</span> <span class="keyword">ROLE</span>명칭 <span class="comment">-- ROLE에 권한 부여</span></div><div class="line"><span class="keyword">GRANT</span> <span class="keyword">ROLE</span>명칭 <span class="keyword">TO</span> 사용자      <span class="comment">-- 사용자에게 ROLE 부여</span></div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/26/02.05.dcl/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/01/26/02.05.dcl/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/25/02.04.window/">
                            SQLP 2-2-3 Window function
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-25T01:00:00+09:00">
	
		    Jan 25, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="2과목-SQL-기본-및-활용"><a href="#2과목-SQL-기본-및-활용" class="headerlink" title="2과목 SQL 기본 및 활용"></a>2과목 SQL 기본 및 활용</h2><ul>
<li>20문제</li>
<li>각 상황별로 SQL문 작성이 가능할 정도로 연습해야 합니다.</li>
<li>기본적인 SQL문법 및 함수는 생략하고 Tuning에 활용될수 있는 것 위주로 정리하고자 합니다.</li>
</ul>
<h3 id="2장-SQL-활용-3"><a href="#2장-SQL-활용-3" class="headerlink" title="2장 SQL 활용 (#3)"></a>2장 SQL 활용 (#3)</h3><h4 id="WINDOW-FUNCTION-윈도우-함수"><a href="#WINDOW-FUNCTION-윈도우-함수" class="headerlink" title="WINDOW FUNCTION (윈도우 함수)"></a>WINDOW FUNCTION (윈도우 함수)</h4><ul>
<li>행과 행간을 비교, 연산하는 함수</li>
</ul>
<h5 id="종류"><a href="#종류" class="headerlink" title="종류"></a>종류</h5><ol>
<li>순위 관련 : RANK, DENSE_RANK, ROW_NUMBER</li>
<li>집계 관련 : SUM, MAX, MIN, AVG, COUNT</li>
<li>순서 관련 : FIRST_VALUE, LAST_VALUE, LAG, LEAD</li>
<li>비율 관련 : CUME_DIST, PERCENT_RANK, NTILE, RATIO_TO_REPORT</li>
<li>통계 분석 (순형 분석 포함) : CORP, COVAR_POP, STDDEV 등… (여기서는 다루지 않음)</li>
</ol>
<h5 id="문법-syntax"><a href="#문법-syntax" class="headerlink" title="문법 (syntax)"></a>문법 (syntax)</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> 함수명 (인자) <span class="keyword">OVER</span></div><div class="line">        ([<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 칼럼] [<span class="keyword">ORDER</span> <span class="keyword">BY</span> 절] [WINDOWING 절])</div><div class="line">  <span class="keyword">FROM</span> 테이블;</div></pre></td></tr></table></figure>
<ul>
<li>PARTITION BY 절 : 전체 집합을 기준에 의해 소그룹으로 분리</li>
<li>ORDER BY 절 : 순위 지정시 그 순서</li>
<li>WINDOWING 절 : 함수의 대상을 지정<ul>
<li>ROWS : 물리적인 행수를 지정</li>
<li>RANGE : 논리적인 값에 의한 범위 지정<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- BETWEEN 사용 타입</span></div><div class="line">ROWS | RANGE BETWEEN</div><div class="line">  UNBOUNDED PRECEDING | CURRENT ROW | VALUE_EXPR PRECEDING/FOLLOWING</div><div class="line">AND</div><div class="line">  UNBOUNDED FOLLOWING | CURRENT ROW | VALUE_EXPR PRECEDING/FOLLOWING</div><div class="line"></div><div class="line"><span class="comment">-- BETWEEN 미사용 타입</span></div><div class="line">ROWS | RANGE</div><div class="line">  UNBOUNDED PRECEDING | CURRENT ROW | VALUE_EXPR PRECEDING</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="1-순위-함수"><a href="#1-순위-함수" class="headerlink" title="1. 순위 함수"></a>1. 순위 함수</h5><ul>
<li>RANK : 특정 칼럼에 대한 순위를 구함<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> JOB, ENAME, SAL,</div><div class="line">       <span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>) ALL_RANK,                  <span class="comment">-- SAL의 DESC 순서로 RANK</span></div><div class="line">       <span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> JOB <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>) JOB_RANK  <span class="comment">-- JOB별로 SAL의 DESC 순서로 RANK</span></div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.01.png?raw=true"></p>
<p>한문장에 RANK가 2개 이상일 경우 먼저 나온것을 기준으로 ORDER BY된 결과가 나온다.<br><code>JOB_RANK</code>를 먼저 썼을 경우에는 <code>ORDER BY JOB, SAL DESC</code> 와 같은 순서로 결과가 나온다.</p>
<ul>
<li><p>DENSE_RANK : 동일한 순위를 하나의 건수로 계산한다.</p>
</li>
<li><p>ROW_NUMBER : 동일한 순위에 대해서도 등수를 따로 매긴다. (Oracle의 경우 rowid가 낮은게 먼저 나옴)</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> JOB, ENAME, SAL,</div><div class="line">       <span class="keyword">RANK</span>()       <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>) <span class="keyword">RANK</span>,</div><div class="line">       <span class="keyword">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>) <span class="keyword">DENSE_RANK</span>,</div><div class="line">       ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>) ROW_NUMBER</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.02.png?raw=true"></p>
<p>앞의 결과를 보면</p>
<ul>
<li>RANK의 경우 2위가 2개이고 다음이 4위인데,</li>
<li>DENSE_RANK는 2위가 2개이고 다음이 3위이다.</li>
<li>ROW_NUMBER는 1 ~ 14로 모든 row의 순위가 다르다.</li>
</ul>
<h5 id="2-집계-함수"><a href="#2-집계-함수" class="headerlink" title="2. 집계 함수"></a>2. 집계 함수</h5><ul>
<li>SUM : 파티션별 윈도우의 합<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, ENAME, SAL,</div><div class="line">       <span class="keyword">SUM</span>(SAL) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO) <span class="string">"부서별 연봉합계"</span></div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.03.png?raw=true"></p>
<p>위 예제는 별로 어렵지 않다.<br>이제 부서별로 SAL 순서로 ORDER BY한 다음에 <code>부서별 연봉합계</code> 대신 <code>부서별 연봉누계</code>로 출력해보겠다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, ENAME, SAL,</div><div class="line">       <span class="keyword">SUM</span>(SAL)  <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">RANGE</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">PRECEDING</span>) <span class="string">"부서별 연봉누계"</span>,</div><div class="line">       <span class="keyword">RANK</span>()    <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL) IDX</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure></p>
<ul>
<li>RANGE UNBOUNDED PRECEDING : 자신(ROW)을 기준으로 앞쪽(PRECEDING)으로 현재 PARTITION 내의 모든값(UNBOUNDED)</li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.04.png?raw=true"></p>
<p>동일한 RANK에 대해서는 누계값도 동일하게 취급하여 두 값을 모두 더하게 된다.</p>
<ul>
<li>MIN, MAX : 파티션별 윈도우의 최소, 최대값<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, ENAME, SAL,</div><div class="line">       <span class="keyword">MIN</span>(SAL) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL) MIN_DEPT,</div><div class="line">       <span class="keyword">MAX</span>(SAL) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO) MAX_DEPT</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.05.png?raw=true"></p>
<ul>
<li><p>AVG : 파티션별 윈도우의 평균값</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, ENAME, SAL, HIREDATE,</div><div class="line">       <span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(SAL) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> HIREDATE <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="number">1</span> <span class="keyword">FOLLOWING</span>)) <span class="keyword">AVG</span></div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
</li>
<li><p>ROW BETWEEN 1 PRECEDING AND 1 FOLLOWING : 자신(ROW)을 기준으로 앞쪽(PRECEDING) 1개와 뒤쪽(FOLLOWING) 1개의 ROW만을 대상으로 함. 만약 PARTITION 내에 앞에 값이 없으면 뒤에 값과 자신의 2개에 대한 평균만 계산.</p>
</li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.06.png?raw=true"></p>
<ul>
<li><p>COUNT : 파티션별 개수를 구함</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, ENAME, SAL,</div><div class="line">       <span class="keyword">COUNT</span>(*) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">RANGE</span> <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="number">100</span> <span class="keyword">FOLLOWING</span>) <span class="keyword">COUNT</span></div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
</li>
<li><p>RANGE BETWEEN 100 PRECEDING AND 100 FOLLOWING : 값으로 앞뒤 100 사이에 있는 것만을 대상으로 함. 즉 자신의 연봉보다 +- 100 사이의 사원수를 측정</p>
</li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.07.png?raw=true"></p>
<h5 id="3-순서-함수"><a href="#3-순서-함수" class="headerlink" title="3. 순서 함수"></a>3. 순서 함수</h5><ul>
<li>FIRST_VALUE : 파티션내에서 가장 먼저 나온 값 (MIN으로 비슷하게 사용이 가능)</li>
<li>LAST_VALUE : 파티션내에서 가장 나중에 나온 값 (MAX 로 비슷하게 사용이 가능)</li>
</ul>
<p>각 부서별 가장 연봉이 많은 사람(RICH)와 가장 연봉이 적은 사람(POOR)를 구해보자.<br>참고로 다음 SQL은 결과가 이상하게 나온다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, ENAME, SAL,</div><div class="line">       <span class="keyword">FIRST_VALUE</span>(ENAME) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL) POOR,</div><div class="line">       <span class="keyword">LAST_VALUE</span> (ENAME) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL) RICH</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.08.png?raw=true"></p>
<p>FIRST_VALUE의 경우에는 제대로 나왔는데, LAST_VALUE에 대해서는 뭔가 좀 이상하다.<br>파티션 내에서 현재(ROW)를 기준으로만 계산이 되었다.<br>LAST_VALUE의 경우에는 범위를 명시적으로 지정해주면 정상적으로 출력된다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, ENAME, SAL,</div><div class="line">       <span class="keyword">FIRST_VALUE</span>(ENAME) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL) POOR,</div><div class="line">       <span class="keyword">LAST_VALUE</span> (ENAME) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL</div><div class="line">                                <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">FOLLOWING</span>) RICH</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
<ul>
<li>이 경우에는 SAL 순으로 정렬되었기 때문에 의미적으로 <code>UNBOUNDED PRECEDING</code> 대신에 <code>CURRENT ROW</code>를 적어도 결과는 같다.</li>
</ul>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.09.png?raw=true"></p>
<ul>
<li>LAG : 이전 몇 번째 행의 값을 가져온다.</li>
<li>LEAD : 이후 몇 번째 행의 값을 가져온다.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, ENAME, SAL,</div><div class="line">       LAG (SAL) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL) LAG,</div><div class="line">       <span class="keyword">LEAD</span>(SAL) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL) <span class="keyword">LEAD</span></div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.10.png?raw=true"></p>
<p>LAG, LEAD 함수는 인자를 3개까지 가질수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LAG(컬럼, 몇칸 = 1, ISNULL = NULL)</div></pre></td></tr></table></figure>
<ul>
<li>첫번째 인자 : 어느 컬럼 값을 출력할지 지정</li>
<li>두번째 인자 : 몇칸 앞 (또는 뒤)의 값을 가져올지 지정 (default = 1)</li>
<li>세번째 인자 : NULL일 경우 어떻게 출력할지 지정 (default = NULL)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, ENAME, SAL,</div><div class="line">       LAG (SAL,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL) LAG_1,</div><div class="line">       LAG (SAL,<span class="number">2</span>,<span class="number">0</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL) LAG_2,</div><div class="line">       <span class="keyword">LEAD</span>(SAL,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL) LEAD_1,</div><div class="line">       <span class="keyword">LEAD</span>(SAL,<span class="number">2</span>,<span class="number">0</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL) LEAD_2</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.11.png?raw=true"></p>
<h5 id="4-비율-함수"><a href="#4-비율-함수" class="headerlink" title="4. 비율 함수"></a>4. 비율 함수</h5><ul>
<li>RATIO_TO_REPORT : 파티션내 전체 SUM값 대비 백분율 비율 (0 ~ 1)</li>
</ul>
<p>전 직원들의 연봉을 전체연봉 대비 얼마나 차지하는지를 구해보자.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, SAL, JOB,</div><div class="line">       <span class="keyword">ROUND</span>(RATIO_TO_REPORT(SAL) <span class="keyword">OVER</span>(),<span class="number">3</span>) <span class="keyword">AS</span> RATIO</div><div class="line">  <span class="keyword">FROM</span> EMP</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.12.png?raw=true"></p>
<ul>
<li>PERCENT_RANK : 파티션내의 순서별 백분율. (처음값 = 0, 마지막값 = 1)</li>
<li>CUME_DIST : 파티션내의 전체건수에서 자신보다 작거나 같은 건수에 대한 누적백분율</li>
</ul>
<p>두 함수가 비슷한데 값이 약간 차이가 난다.<br>PERCENT_RANK는 0 부터 시작하므로 파티션내의 개수 - 1 등분하고,<br>CUME_DIST는 개수만큼 등분한다.</p>
<p>각 부서별 연봉 순위를 비율로 구해본다면<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, ENAME, SAL,</div><div class="line">       <span class="keyword">PERCENT_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>)    <span class="keyword">AS</span> <span class="keyword">PERCENT_RANK</span>,</div><div class="line">    <span class="keyword">ROUND</span>(<span class="keyword">CUME_DIST</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>),<span class="number">2</span>) <span class="keyword">AS</span> <span class="keyword">CUME_DIST</span></div><div class="line">  <span class="keyword">FROM</span> EMP</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.13.png?raw=true"></p>
<ul>
<li>NTILE : 파티션내의 전체 건수를 N 등분</li>
</ul>
<p>전체 사원을 연봉 기준으로 4 LEVEL로 급수를 매길경우<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, SAL,</div><div class="line">       NTILE(<span class="number">4</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>) <span class="keyword">AS</span> GRADE</div><div class="line">  <span class="keyword">FROM</span> EMP;</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.04.window.14.png?raw=true"></p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/25/02.04.window/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/01/25/02.04.window/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/25/02.03.group/">
                            SQLP 2-2-2 GROUP function
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-25T00:00:00+09:00">
	
		    Jan 25, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="2과목-SQL-기본-및-활용"><a href="#2과목-SQL-기본-및-활용" class="headerlink" title="2과목 SQL 기본 및 활용"></a>2과목 SQL 기본 및 활용</h2><ul>
<li>20문제</li>
<li>각 상황별로 SQL문 작성이 가능할 정도로 연습해야 합니다.</li>
<li>기본적인 SQL문법 및 함수는 생략하고 Tuning에 활용될수 있는 것 위주로 정리하고자 합니다.</li>
</ul>
<h3 id="2장-SQL-활용-2"><a href="#2장-SQL-활용-2" class="headerlink" title="2장 SQL 활용 (#2)"></a>2장 SQL 활용 (#2)</h3><ul>
<li>표준에서 정한 데이터 분석 3가지 함수군</li>
</ul>
<ul>
<li>Aggregate function : 앞에서 본 GROUP BY 에서 사용한 집계함수 (SUM, AVG, MIN, MAX, …)</li>
<li>Group function : 단계별 소계를 계산. SQL을 한번만 읽어 빠르게 보고서 작성이 가능하도록 도와주는 함수들 (ROLLUP, CUBE, GROUPING SET)</li>
<li>Window function : 행간의 비교, 관계를 지원. DW에서 발전한 기능 (RANK로 대표됨. 함수명은 앞의 것들과 같지만 사용법이 다름)</li>
</ul>
<h4 id="GROUP-FUNCTION-그룹함수"><a href="#GROUP-FUNCTION-그룹함수" class="headerlink" title="GROUP FUNCTION (그룹함수)"></a>GROUP FUNCTION (그룹함수)</h4><p>솔직히 SQL 작성시 사용할 만한 함수는 ROLLUP 하나뿐이다.<br>나머지는 시험에 나올 수 있으므로 그냥 어떤 역할을 한다는 정도만 알아두면 될듯하다.</p>
<h5 id="1-ROLLUP"><a href="#1-ROLLUP" class="headerlink" title="1. ROLLUP"></a>1. ROLLUP</h5><p>소그룹간의 소계(subtotal)를 계산</p>
<p>부서별 업무별 인원수와 연봉의 소계를 일반적은 query로 다음과 같이 작성이 가능하다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DNAME, JOB, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> TOTAL_EMP, <span class="keyword">SUM</span>(SAL) <span class="keyword">AS</span> SUM_SAL</div><div class="line">  <span class="keyword">FROM</span> DEPT A, EMP B</div><div class="line"> <span class="keyword">WHERE</span> A.DEPTNO = B.DEPTNO</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> DNAME, JOB</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> DNAME, JOB;</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.03.group.01.png?raw=true"></p>
<p>위 예제의 경우 부서별, 업무별의 대한 소계를 구했다.<br>여기다가 부서별 소계 와 전체 합계까지 같이 출력하려면 어떻게 해야할까 ?<br>부서별 소계를 구하는 SQL과 전체 합계를 구하는 SQL을 각각 호출해서 전체를 UNION ALL 하는 방법이 가장 손쉬운 방법이다.  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DNAME, JOB, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> TOTAL_EMP, <span class="keyword">SUM</span>(SAL) <span class="keyword">AS</span> SUM_SAL, <span class="number">1</span> <span class="keyword">AS</span> <span class="keyword">DEPTH</span></div><div class="line">  <span class="keyword">FROM</span> DEPT A, EMP B</div><div class="line"> <span class="keyword">WHERE</span> A.DEPTNO = B.DEPTNO</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> DNAME, JOB</div><div class="line"> <span class="keyword">UNION</span> ALL</div><div class="line"><span class="keyword">SELECT</span> DNAME, <span class="string">'TOTAL'</span> <span class="keyword">AS</span> JOB, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> TOTAL_EMP, <span class="keyword">SUM</span>(SAL) <span class="keyword">AS</span> SUM_SAL, <span class="number">2</span> <span class="keyword">AS</span> <span class="keyword">DEPTH</span></div><div class="line">  <span class="keyword">FROM</span> DEPT A, EMP B</div><div class="line"> <span class="keyword">WHERE</span> A.DEPTNO = B.DEPTNO</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> DNAME</div><div class="line"> <span class="keyword">UNION</span> ALL</div><div class="line"><span class="keyword">SELECT</span> <span class="string">'TOTAL'</span> <span class="keyword">AS</span> DNAME, <span class="string">''</span> <span class="keyword">AS</span> JOB, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> TOTAL_EMP, <span class="keyword">SUM</span>(SAL) <span class="keyword">AS</span> SUM_SAL, <span class="number">3</span> <span class="keyword">AS</span> <span class="keyword">DEPTH</span></div><div class="line">  <span class="keyword">FROM</span> EMP</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.03.group.02.png?raw=true"></p>
<p>그 결과들을 다시 순서대로 할려면 UNION ALL로 묶은 것을 subquery로 해서 SELECT문을 한번 더 써야 한다.<br>위 SQL을 그냥 A라고 하겠다.  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DNAME, JOB, TOTAL_EMP, SUM_SAL</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> ... ) A</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> DNAME, <span class="keyword">DEPTH</span>, JOB;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.03.group.03.png?raw=true"></p>
<p>상당히 복잡한 과정을 거쳐서 소계를 구했는데,<br>그냥 ROLLUP을 이용하면 쉽게 작성이 가능하다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DNAME, JOB, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> TOTAL_EMP, <span class="keyword">SUM</span>(SAL) <span class="keyword">AS</span> SUM_SAL</div><div class="line">  <span class="keyword">FROM</span> EMP A, DEPT B</div><div class="line"> <span class="keyword">WHERE</span> A.DEPTNO = B.DEPTNO</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (DNAME, JOB)</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> DNAME, JOB;</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.03.group.04.png?raw=true"></p>
<ul>
<li>GROUPING 함수 : 해당 컬럼을 기준으로 소계를 한 결과에 대해서는 GROUPING(컬럼) = 1을 출력한다.  </li>
</ul>
<p>위 결과에서 각 부서별 합계를 출력하는 row에 대해서는 GROUPING(JOB) = 1 이 되며,<br>총 계에 대해서는 GROUPING(DNAME) = 1, GROUPING(JOB) = 1 이 출력된다.<br>이 함수를 이용해서 그룹별 소계, 총 합계를 출력하는 row에 별도 label을 주고자 할 경우 작성법은 다음과 같다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DECODE</span> (<span class="keyword">GROUPING</span>(DNAME), <span class="number">1</span>, <span class="string">'Total DEPT'</span>, DNAME) <span class="keyword">AS</span> DNAME,</div><div class="line">       <span class="keyword">DECODE</span> (<span class="keyword">GROUPING</span>(JOB), <span class="number">1</span>, <span class="string">'Total JOB'</span> , JOB) <span class="keyword">AS</span> JOB,</div><div class="line">       <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> TOTAL_EMP,</div><div class="line">       <span class="keyword">SUM</span>(SAL) <span class="keyword">AS</span> SUM_SAL</div><div class="line">  <span class="keyword">FROM</span> EMP A, DEPT B</div><div class="line"> <span class="keyword">WHERE</span> A.DEPTNO = B.DEPTNO</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (DNAME, JOB);</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.03.group.05.png?raw=true"></p>
<ul>
<li>ROLLUP을 부분적으로 적용</li>
</ul>
<ol>
<li>소계에서 제외<ul>
<li>항상 모든 GROUP BY에 사용된 컬럼에 대해서 ROLLUP을 해야하는 것은 아니다.  </li>
<li>만약 DNAME, JOB 별로 GROUP BY를 하되 부서별 소계를 필요하지만, 전체 합계는 필요없을 경우  </li>
<li><code>GROUP BY DNAME, ROLLUP(JOB)</code> 라고 쓰면 위 결과에서 마지막줄인 <code>Total DEPT</code>가 출력되지 않는다.  </li>
</ul>
</li>
<li>2개 이상의 컬럼으로 구분<ul>
<li>위의 경우 DNAME, JOB가 종속관계이다. DNAME 안에서 JOB별로 구분하였다.</li>
<li>만약 DNAME 아래에 JOB, MGR이 같은 것끼리 묶어서 소계를 구하고자 할때에는 두 컬럼 이상을 괄호로 묶으면 된다.  </li>
<li><code>GROUP BY ROLLUP( DNAME, (JOB, MGR))</code> 이라고 쓰면 JOB, MGR을 계층짓지않고, JOB, MGR이 모두 같은 것을 하나의 그룹으로 묶어서 소계를 구한다.</li>
</ul>
</li>
</ol>
<h5 id="2-CUBE"><a href="#2-CUBE" class="headerlink" title="2. CUBE"></a>2. CUBE</h5><p>결합 가능한 모든 값에 대하여 다차원 집계를 생성한다.<br>위 ROLLUP에서 사용한 예제에서 ROLLUP대신 CUBE를 쓸 경우 : <code>GROUP BY CUBE(DNAME, JOB)</code></p>
<ul>
<li>DNAME 별 JOB의 소계</li>
<li>JOB 별 DNAME의 소계</li>
<li>전체 합계<br>를 모두 출력한다.</li>
</ul>
<p>즉, CUBE 내의 컬럼들의 순서를 바꿔가면서 ROLLUP을 수행한 뒤에 UNION 한것과 같은 결과이다.<br>그만큼 연산량이 많다.  </p>
<p>또 다른 차이점은 GROUPING 함수의 경우<br>ROLLUP에서는 계층이 있으므로 GROUPING(DNAME) = 1 이면서 GROUPING(JOB) = 0 인 값이 없었다.<br>CUBE에서는 GROUPING(DNAME) = 1 이면서 GROUPING(JOB) = 0이 가능하다. JOB별 all DNAME에 대한 소계의 경우이다.</p>
<h5 id="3-GROUPING-SETS"><a href="#3-GROUPING-SETS" class="headerlink" title="3. GROUPING SETS"></a>3. GROUPING SETS</h5><p>다양한 소계들을 한번의 SQL로 구하는데 사용된다.<br>나열한 컬럼들을 평등한 관계이므로 순서를 바꿔도 상관없다.  </p>
<p>위 예제에서 GROUPING SETS를 쓸 경우  : <code>GROUP BY GROUPING SETS(DNAME, JOB)</code></p>
<ul>
<li>DNAME별 소계</li>
<li>JOB별 소계<br>를 UNION ALL 해준 결과를 출력해준다.</li>
</ul>
<p>GROUPING SET도 2개 이상의 컬럼으로 구분이 가능하다. ROLLUP에서 본것 같이 괄호로 컬럼들을 묶어주면 된다.<br><code>GROUP BY GROUPING SETS ( (DNAME, JOB, MGR) , (DNAME, JOB) , DNAME )</code> 이라고 할 경우</p>
<ul>
<li>DNAME-JOB-MGR 별 소계</li>
<li>DNAME-JOB 별 소계</li>
<li>DNAME 별 소계<br>의 결과들을 UNION ALL 한 것과 같은 결과를 출력해준다.</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/25/02.03.group/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/01/25/02.03.group/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/23/02.02.sql.adv/">
                            SQLP 2-2-1 SET, Hierarchical Query, Sub-query
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-23T00:00:00+09:00">
	
		    Jan 23, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="2과목-SQL-기본-및-활용"><a href="#2과목-SQL-기본-및-활용" class="headerlink" title="2과목 SQL 기본 및 활용"></a>2과목 SQL 기본 및 활용</h2><ul>
<li>20문제</li>
<li>각 상황별로 SQL문 작성이 가능할 정도로 연습해야 합니다.</li>
<li>기본적인 SQL문법 및 함수는 생략하고 Tuning에 활용될수 있는 것 위주로 정리하고자 합니다.</li>
</ul>
<h3 id="2장-SQL-활용-1"><a href="#2장-SQL-활용-1" class="headerlink" title="2장 SQL 활용 (#1)"></a>2장 SQL 활용 (#1)</h3><h4 id="1-집합-연산자-SET"><a href="#1-집합-연산자-SET" class="headerlink" title="1. 집합 연산자 (SET)"></a>1. 집합 연산자 (SET)</h4><ul>
<li>UNON : 합집합, 중복된 행은 제거</li>
<li>UNION ALL : 합집합, 중복된 행을 그대로 표시하는 대신에 성능이 빠름</li>
<li>INTERSECT : 교집합, 중복된 행 제거</li>
<li>MINUS : 차집합, 앞의 SQL 결과에서 뒤의 결과를 제거한다. (오라클 이외의 대부분은 EXCEPT로 사용함)</li>
</ul>
<p>솔직히 UNION과 UNION ALL의 차이만 이해하고 있으면 된다.<br>UNION 과 UNION ALL의 결과가 같다는것이 보장되면 무조건 UNION ALL을 사용하는 것이 성능이 뛰어나다.<br>INTERSECT 는 EXISTS 나 IN 서브쿼리로 변경이 가능하다. (그러므로 쓸일이 거의 없다.)<br>MINUS 는 그냥 WHERE의 조건에서 논리적으로 제외시키는 것이 가능하다. (심지어 출력하지 않아도 될 ROW와 거기서 빼야할 ROW들을 읽어야 하므로 성능을 생각해서는 절대로 사용하면 안된다.)  </p>
<h4 id="2-계층형-질의-Hierarchical-Query"><a href="#2-계층형-질의-Hierarchical-Query" class="headerlink" title="2. 계층형 질의 (Hierarchical Query)"></a>2. 계층형 질의 (Hierarchical Query)</h4><p>계층형 데이터를 조회할때 사용한다.  </p>
<blockquote>
<p>계층형 데이터 : 동일 테이블에 계층적으로 상위, 하위 데이터가 포함된 데이터<br>ex. EMP Table에  EMPNO, MANAGER 가 있으며 EMPNO는 해당 사원의 사원번호, MANAGER는 해당 사원의 부서장 사원번호인 경우</p>
</blockquote>
<p>계층형 질의는 다음과 같은 모양이다. (Oracle 기준)</p>
<ul>
<li>질의 구문</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ...</div><div class="line">  <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">name</span></div><div class="line"> <span class="keyword">WHERE</span> (filter condition)</div><div class="line"> <span class="keyword">START</span> <span class="keyword">WITH</span> (root condition)                   <span class="comment">-- START WITH MANAGER IS NULL</span></div><div class="line"> <span class="keyword">CONNECT</span> <span class="keyword">BY</span> [<span class="keyword">NOCYCLE</span>] (hierarchical condition) <span class="comment">-- CONNECT BY NOCYCLE PRIOR EMPNO = MANAGER</span></div><div class="line"> [<span class="keyword">ORDER</span> <span class="keyword">SIBLINGS</span> <span class="keyword">BY</span> columns...]</div></pre></td></tr></table></figure>
<ul>
<li>START WITH : 시작조건. root data가 되는 조건을 적는다.</li>
<li>CONNECT BY : 부모와 자식의 관계를 적는다. PRIOR 키워드는 전개방향 상 이전 레코드를 가리킨다.</li>
<li>ORDER SIBLINGS BY :(같은 부모를 가진) 형재 node 의 ORDER BY이다.</li>
</ul>
<p>SELECT, FROM, WHERE 등은 일반 SQL문법과 동일하다.</p>
<ul>
<li>가상 칼럼</li>
</ul>
<ul>
<li>LEVEL : ROOT = 1, LEAF방향으로 1씩 증가</li>
<li>CONNECT_BY_ISLEAF : LEAF이면 1, 자식이 있으면 0</li>
<li>CONNECT_BY_ISCYCLE : 자식을 가지면서, 자신이 자기 조상에도 있으면 1, 아니면 0 (CYCLE 옵션에서만 허용)</li>
</ul>
<ul>
<li>전용 함수</li>
</ul>
<ul>
<li>SYS_CONNECT_BY_PATH(column, separator) : Root부터 현재까지의 경로를 표시한다.</li>
<li>CONNECT_BY_ROOT column : root 데이터의 칼럼을 표시한다.</li>
</ul>
<p>START WITH 조건과 CONNECT BY 조건을 어떻게 하냐에 따라서 부모 -&gt; 자식 방향 또는 자식 -&gt; 부모 방향으로의 전개가 가능하다.</p>
<ul>
<li>부모 -&gt; 자식 방향전개<ul>
<li>START WITH : ROOT 조건</li>
<li>CONNECT BY : PRIOR 자식ID = 부모ID<ul>
<li>이 부분 해석이 좀 해깔릴수 있는데, EMPNO, MANAGER의 경우 PRIOR EMPNO = MANAGER 로 써야한다.</li>
<li>그냥 START WITH 조건의 row와 전개방향 바로 다음 row의 비교조건을 적는다고 생각하면 됨.</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">LPAD</span>(<span class="string">' '</span>, <span class="number">4</span> * (<span class="keyword">LEVEL</span><span class="number">-1</span>)) || <span class="keyword">LEVEL</span> <span class="keyword">AS</span> <span class="string">"LEVEL"</span>, EMPNO, MGR, <span class="keyword">CONNECT_BY_ISLEAF</span> <span class="keyword">AS</span> LEAF</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP</div><div class="line"> <span class="keyword">START</span> <span class="keyword">WITH</span> MGR <span class="keyword">IS</span> <span class="literal">NULL</span></div><div class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">PRIOR</span> EMPNO = MGR</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">SIBLINGS</span> <span class="keyword">BY</span> EMPNO;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.01.png?raw=true"></p>
<ul>
<li>자식 -&gt; 부모 방향전개<ul>
<li>START WITH : LEAF 조건</li>
<li>CONNECT BY : PRIOR 부모ID = 자식ID</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">LEVEL</span>, EMPNO, MGR</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP</div><div class="line"> <span class="keyword">START</span> <span class="keyword">WITH</span> EMPNO = <span class="number">7369</span></div><div class="line"> <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">PRIOR</span> MGR = EMPNO;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.02.png?raw=true"></p>
<h4 id="3-SELF-JOIN"><a href="#3-SELF-JOIN" class="headerlink" title="3. SELF JOIN"></a>3. SELF JOIN</h4><p>이것도 설명해야 할까 ?<br>그냥 같은 테이블 2개를 JOIN, alias 필수(그래야 서로 다른 view인듯 제어가 가능하니깐)</p>
<h4 id="4-Subquery"><a href="#4-Subquery" class="headerlink" title="4. Subquery"></a>4. Subquery</h4><ul>
<li>SQL문 안에 포함되는 SQL문을 의미한다.</li>
<li>반드시 (괄호)로 감싸야한다.</li>
<li>ORDER BY를 사용하지 못한다. (메인 쿼리의 마지막에 한번만 가능하다.)</li>
</ul>
<h5 id="분류"><a href="#분류" class="headerlink" title="분류"></a>분류</h5><ul>
<li><p>동작 방식</p>
<ul>
<li>비연관 (Un-Correlated) : 메인쿼리의 컬럼을 가지고 있지 않음. 메인쿼리에 결과를 제공하기 위한 목적</li>
<li>연관 (Correlated) : 메인쿼리의 칼럼을 가지고 있음. 메인쿼리가 먼저 수행되면서 서브쿼리에서 조건 체크할 목적</li>
</ul>
</li>
<li><p>반환되는 데이터 형태</p>
<ul>
<li>Single row : 결과가 1건 이하 (단일행 비교연산자)</li>
<li>Multi row : 결과가 여러 건 (IN, ALL, ANY, SOME, EXISTS 연산자)</li>
<li>Multi column : 결과가 여러 컬럼 (메인쿼리와 비교하자고 하는 컬럼의 위치와 개수가 같아야함)</li>
<li>Scalar Subquery : 1개의 data (1 row 1 column)만 반환. SQL문 중 column이 위치할 수 있는 대부분의 곳에 사용 가능</li>
</ul>
</li>
</ul>
<p>일단 이 2가지 분류방식에 대해서 먼저 이해를 하고, 이제 위치에 따라 올 수 있는 형태를 살펴보겠다.</p>
<h5 id="1-WHERE에-위치"><a href="#1-WHERE에-위치" class="headerlink" title="1. WHERE에 위치"></a>1. WHERE에 위치</h5><ul>
<li>Single row</li>
</ul>
<p>SCOTT이 속한 부서의 직원목록을 보기 위해서는<br>먼저 SCOTT의 DEPTNO를 가져와서 해당 값과 같은 직원들을 조회해야 한다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP</div><div class="line"> <span class="keyword">WHERE</span> DEPTNO = (<span class="keyword">SELECT</span> DEPTNO <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> ENAME = <span class="string">'SCOTT'</span>) <span class="comment">-- 먼저 수행</span></div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.03.png?raw=true"></p>
<ul>
<li>Multi row</li>
</ul>
<p>SALEMAN job이 있는 부서와 해당 부서에 있는 CLERK job의 목록을 보기 위해서는<br>먼저 SALEMAN 이 속한 부서의 DEPTNO를 구한 뒤, 해당 값과 같은 부서인원중 CLERK를 찾아야 한다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP</div><div class="line"> <span class="keyword">WHERE</span> JOB = <span class="string">'CLERK'</span></div><div class="line">   <span class="keyword">AND</span> DEPTNO <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DEPTNO <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> JOB = <span class="string">'SALESMAN'</span>) <span class="comment">-- 먼저 수행</span></div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.04.png?raw=true"></p>
<ul>
<li>Multi column</li>
</ul>
<p>각 팀별 최고연봉자를 출력하기 위해서는<br>먼저 각 팀별 최고연봉자에 대해서 GROUP BY로 구한 뒤 해당 칼럼정보와 같은 직원정보를 출력하면 된다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP</div><div class="line"> <span class="keyword">WHERE</span> (DEPTNO, SAL) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> DEPTNO, <span class="keyword">MAX</span>(SAL) <span class="keyword">AS</span> SAL <span class="keyword">FROM</span> EMP <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO) <span class="comment">-- 먼저 수행</span></div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.05.png?raw=true"></p>
<ul>
<li>연관 서브쿼리 (Correlated subuery)</li>
</ul>
<p>메인쿼리 칼럼이 서브쿼리 내에서 사용된다.<br>메인쿼리가 먼저 수행되면서 row마다 서브쿼리를 한번씩 수행하므로 성능상에는 좋지않다.</p>
<p>각 부서별 평균영봉 이상을 받는 직원정보를 출력하고자 하기 위해서는<br>매 직원정보마다 해당 직원의 연봉이 해당 부서의 평균이상인지를 비교(check)해야 한다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP A               <span class="comment">-- 메인쿼리가 먼저 수행되면서 매 ROW마다 아래 서브쿼리 수행</span></div><div class="line"> <span class="keyword">WHERE</span> SAL &gt;= (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(SAL) <span class="keyword">AS</span> SAL <span class="keyword">FROM</span> EMP B <span class="keyword">WHERE</span> B.DEPTNO = A.DEPTNO <span class="keyword">GROUP</span> <span class="keyword">BY</span> B.DEPTNO)</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.06.png?raw=true"></p>
<h5 id="2-SELECT에-위치-Scalar-Subquery"><a href="#2-SELECT에-위치-Scalar-Subquery" class="headerlink" title="2. SELECT에 위치 (Scalar Subquery)"></a>2. SELECT에 위치 (Scalar Subquery)</h5><p>대부분 연관(correlated) 관계로 호출한다.<br>비연관으로 가능하다면 그냥 Inline View로 하는게 더 효과적이다.  </p>
<p>직원정보를 호출하면서 소속부서의 평균연봉도 같이 출력할 경우 다음과 같다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO, ENAME, SAL,</div><div class="line">       <span class="keyword">ROUND</span>((<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(SAL) <span class="keyword">FROM</span> EMP B <span class="keyword">WHERE</span> B.DEPTNO = A.DEPTNO <span class="keyword">GROUP</span> <span class="keyword">BY</span> B.DEPTNO)) <span class="keyword">AS</span> AVG_SAL</div><div class="line">  <span class="keyword">FROM</span> EMP A</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> DEPTNO, SAL;</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.07.png?raw=true"></p>
<h5 id="3-FROM에-위치-Inline-View"><a href="#3-FROM에-위치-Inline-View" class="headerlink" title="3. FROM에 위치 (Inline View)"></a>3. FROM에 위치 (Inline View)</h5><p>View나 Table이 올수 있는 위치에는 사용이 가능하다.<br>해당 query내에서는 마치 dynamic view처럼 사용된다.<br>사용상 아무런 제약을 받지않고 SELECT문을 자유롭게 쓸 수 있다. (ORDER BY도 사용이 가능하다.)</p>
<p>바로 위에 연관관계로 호출된 Scalar subquery는 성능이 좋지 않으므로 inline view로 고쳐보자.<br>각 부서별 평균연봉을 dynamic view로 구한 다음 JOIN을 하면 된다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> A.DEPTNO, A.ENAME, A.SAL, B.AVG_SAL</div><div class="line">  <span class="keyword">FROM</span> EMP A,</div><div class="line">       (<span class="keyword">SELECT</span> DEPTNO, <span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(SAL)) <span class="keyword">AS</span> AVG_SAL <span class="keyword">FROM</span> EMP <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO) B</div><div class="line"> <span class="keyword">WHERE</span> A.DEPTNO = B.DEPTNO</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> DEPTNO, SAL;</div></pre></td></tr></table></figure></p>
<ul>
<li>TOP-N 쿼리</li>
</ul>
<p>data를 정렬하고 그 중 일부만 추출하고자 할때는 inline view로 ORDER BY를 한 뒤 ROWNUM으로 추출하면 된다.  </p>
<p>MANAGER 중 연봉 BEST 2를 순서대로 출력하고자 할 경우 (MANAGER는 총 3명)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP <span class="keyword">WHERE</span> JOB = <span class="string">'MANAGER'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>)</div><div class="line"> <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt;= <span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.08.png?raw=true"></p>
<h5 id="4-HAVING에-위치"><a href="#4-HAVING에-위치" class="headerlink" title="4. HAVING에 위치"></a>4. HAVING에 위치</h5><p>WHERE에 위치와 크게 다르지않다.<br>하지만 집계함수 사용시 그 결과를 filtering 하는 것이므로 의미상 필요할 경우 사용하면 된다.</p>
<p>부서별 평균연봉이 전체평균연봉보다 큰 부서명을 출력하고자 할 경우<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> C.DNAME, B.AVG_SAL</div><div class="line">  <span class="keyword">FROM</span> DEPT C,</div><div class="line">       (<span class="keyword">SELECT</span> A.DEPTNO, <span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(A.SAL)) <span class="keyword">AS</span> AVG_SAL</div><div class="line">          <span class="keyword">FROM</span> EMP A</div><div class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO</div><div class="line">        <span class="keyword">HAVING</span> <span class="keyword">AVG</span>(A.SAL) &gt;= (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(SAL) <span class="keyword">FROM</span> EMP)) B</div><div class="line"> <span class="keyword">WHERE</span> C.DEPTNO = B.DEPTNO;</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.02.sql.adv.09.png?raw=true"></p>
<h5 id="5-UPDATE의-SET에-위치"><a href="#5-UPDATE의-SET에-위치" class="headerlink" title="5. UPDATE의 SET에 위치"></a>5. UPDATE의 SET에 위치</h5><p>UPDATE 할 TABLE과 JOIN하여 여러 row에 대한 UPDATE를 한번에 수행이 가능하다.<br>DEPT table에 AVG_SAL(평균연봉) 컬럼을 추가한 뒤 해당 값을 한번에 넣고자 하는 경우<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> DEPT A</div><div class="line">   <span class="keyword">SET</span> AVG_SAL = (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(SAL) <span class="keyword">AS</span> AVG_SAL <span class="keyword">FROM</span> EMP B <span class="keyword">WHERE</span> B.DEPTNO = A.DEPTNO <span class="keyword">GROUP</span> <span class="keyword">BY</span> B.DEPTNO);</div></pre></td></tr></table></figure></p>
<h5 id="6-INSERT의-VALUES에-위치"><a href="#6-INSERT의-VALUES에-위치" class="headerlink" title="6. INSERT의 VALUES에 위치"></a>6. INSERT의 VALUES에 위치</h5><p>주로 새로운 값을 추가할 때 기존에 저장된 마지막 일련번호(s/n)의 다음 번호로 저장하고자 할때 사용하며 편하다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> EMP (EMPNO, ENAME)</div><div class="line"><span class="keyword">VALUES</span> ((<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(EMPNO) + <span class="number">1</span> <span class="keyword">FROM</span> EMP), <span class="string">'LUNA'</span>);</div></pre></td></tr></table></figure></p>
<h4 id="5-View"><a href="#5-View" class="headerlink" title="5. View"></a>5. View</h4><p>SELECT 질의문을 이용하여 가상의 table을 선언하는 것이다.<br>실제로 물리적으로 해당 table이 생성되는 것이 아니라 수행할때마다 DBMS 내부적으로 View의 정의를 참조하여 쿼리를 재정의한다.  </p>
<ul>
<li><p>View의 장점</p>
<ul>
<li>독립성 : Table의 구조가 변경되어도, View를 사용하는 application은 변경하지 않아도 된다. (물론 View를 변경해줘야 하지만)</li>
<li>편리성 : 자주 이용되는 복잡한 query를 미리 view로 정의해두면 편리하게 재사용이 가능하다.</li>
<li>보안성 : 보안상 숨기고 싶은 데이터에 대해서는 view 생성시 해당 정보를 제외하고 view를 배포하면 된다.</li>
</ul>
</li>
<li><p>View 생성방법</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 뷰명칭</div><div class="line"><span class="keyword">AS</span></div><div class="line"><span class="keyword">SELECT</span> ...</div></pre></td></tr></table></figure>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/23/02.02.sql.adv/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/01/23/02.02.sql.adv/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/21/02.01.sql.basic/">
                            SQLP 2-1 SQL 기본
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-21T00:00:00+09:00">
	
		    Jan 21, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="2과목-SQL-기본-및-활용"><a href="#2과목-SQL-기본-및-활용" class="headerlink" title="2과목 SQL 기본 및 활용"></a>2과목 SQL 기본 및 활용</h2><ul>
<li>20문제</li>
<li>각 상황별로 SQL문 작성이 가능할 정도로 연습해야 합니다.</li>
<li>기본적인 SQL문법 및 함수는 생략하고 Tuning에 활용될수 있는 것 위주로 정리하고자 합니다.</li>
</ul>
<h3 id="1장-SQL-기본"><a href="#1장-SQL-기본" class="headerlink" title="1장 SQL 기본"></a>1장 SQL 기본</h3><h4 id="1-1-SQL-종류"><a href="#1-1-SQL-종류" class="headerlink" title="1.1 SQL 종류"></a>1.1 SQL 종류</h4><ol>
<li>DML (Data Manipulation Language) : 데이터 조작어<ul>
<li>SELECT : 조회</li>
<li>INSERT, UPDATE, DELETE : 데이터에 변형을 가하는 명령어</li>
</ul>
</li>
<li>DDL (Data Definition Language) : 데이터 정의어<ul>
<li>CREATE, ALTER, DROP, RENAME :  테이블 등의 데이터 구조를 생성, 변경, 삭제하는 명령어</li>
</ul>
</li>
<li>DCL (Data Control Language) : 데이터 제어어<ul>
<li>GRANT, REVOKE : DB 및 객체의 접근, 사용 권한을 주고 회수하는 명령어</li>
</ul>
</li>
<li>TCL (Transaction Control Language) : 트랜잭션 제어어<ul>
<li>COMMIT, ROLLBACK : 트랜잭션을 제어하는 명령어</li>
</ul>
</li>
</ol>
<h4 id="1-2-CREATE-TABLE"><a href="#1-2-CREATE-TABLE" class="headerlink" title="1.2 CREATE TABLE"></a>1.2 CREATE TABLE</h4><h5 id="1-기본적인-생성법"><a href="#1-기본적인-생성법" class="headerlink" title="1. 기본적인 생성법"></a>1. 기본적인 생성법</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 테이블명 (</div><div class="line">    컬럼명    DATATYPE    [<span class="keyword">DEFAULT</span> 형식],</div><div class="line">    ...</div><div class="line">    <span class="keyword">CONSTRAINT</span> 테이블명_PK PRIMARY <span class="keyword">KEY</span> (컬럼, ...),</div><div class="line">    <span class="keyword">CONSTRAINT</span> 테이블명_FK FOREIGN <span class="keyword">KEY</span> (컬럼, ...) <span class="keyword">REFERENCES</span> 테이블<span class="number">2</span>(컬럼, ...)</div><div class="line">);</div></pre></td></tr></table></figure>
<h5 id="2-CTAS-Create-Table-as-Select"><a href="#2-CTAS-Create-Table-as-Select" class="headerlink" title="2. CTAS (Create Table as Select)"></a>2. CTAS (Create Table as Select)</h5><ul>
<li><p>Oracle</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> EMP_COPY</div><div class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
</li>
<li><p>MS-SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">INTO</span> EMP_COPY <span class="keyword">FROM</span> SCOTT.EMP;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>NOT NULL</code> 제약조건을 제외하고는 모두 삭제</li>
</ul>
<h4 id="1-3-TRUNCATE-TABLE-vs-DROP-TABLE-DELETE-TABLE"><a href="#1-3-TRUNCATE-TABLE-vs-DROP-TABLE-DELETE-TABLE" class="headerlink" title="1.3 TRUNCATE TABLE vs DROP TABLE, DELETE TABLE"></a>1.3 TRUNCATE TABLE vs DROP TABLE, DELETE TABLE</h4><ul>
<li>TRUNCATE TABLE<ul>
<li>DROP TABLE과의 차이점 : Table을 삭제하지 않고 모든 row들을 제거한다.</li>
<li>DELETE TABLE과의 차이점 : 시스템 부하가 훨씬 적인 대신에 복구가 불가능하다. (rollback 불가)</li>
</ul>
</li>
</ul>
<h4 id="1-4-TRANSACTION"><a href="#1-4-TRANSACTION" class="headerlink" title="1.4 TRANSACTION"></a>1.4 TRANSACTION</h4><h5 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h5><ul>
<li>원자성 (atomicity) : 모두 정상적으로 실행되거나, 실행되지 않은 상태로 되거나 (all or nothing )</li>
<li>일관성 (consistency) : 실행전에 잘못된 상태가 아니었다면, 실행후에도 잘못이 있으면 안됨</li>
<li>고립성 (isolation) : 도중에 다른 트랜잭션의 영향을 받지 않음</li>
<li>지속성 (durability) : 수행후 갱신한 내용은 영구적으로 저장</li>
</ul>
<h5 id="명령어"><a href="#명령어" class="headerlink" title="명령어"></a>명령어</h5><ul>
<li>COMMIT : 변경된 상태를 DB에 반영</li>
<li>ROLLBACK : 트랜잭션 수행 이전 상태로 되돌림</li>
<li>SAVEPOINT [저장명칭] : 현시점까지만 ROLLBACK이 가능하도록 SAVEPOINT 지정 (MS-SQL에서는 SAVE TRANSACTION [저장명칭])</li>
<li>ROLLBACK TO [저장명칭] : 해당 SAVEPOINT 까지 ROLLBACK (MS-SQL에서는 ROLLBACK TRANSACTION [저장명칭])</li>
</ul>
<h4 id="1-5-ROWNUM-Oracle-TOP-MS-SQL"><a href="#1-5-ROWNUM-Oracle-TOP-MS-SQL" class="headerlink" title="1.5 ROWNUM (Oracle), TOP (MS-SQL)"></a>1.5 ROWNUM (Oracle), TOP (MS-SQL)</h4><ul>
<li>ROWNUM : SQL 처리결과 각 행의 임시 일련번호</li>
<li><p>1개의 행만 출력할 경우  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> = <span class="number">1</span>;</div><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt;= <span class="number">1</span>;</div><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt; <span class="number">2</span>;</div></pre></td></tr></table></figure>
<ul>
<li>n개의 행을 출력할 경우  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt;= n;</div><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt; n+<span class="number">1</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>TOP : 출력결과의 행 수를 제한  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TOP( n [<span class="keyword">PERCENT</span>] [<span class="keyword">WITH</span> <span class="keyword">TIES</span>] ) ... <span class="keyword">FROM</span> ...;</div></pre></td></tr></table></figure>
<ul>
<li>n : n의 갯수 만큼 행을 출력</li>
<li>PERCENT : n % 만큼 출력</li>
<li>WITH TIES : 마지막 행과 동일한 값과 동일한 값은 추가로 같이 출력</li>
</ul>
</li>
</ul>
<h4 id="1-6-CASE"><a href="#1-6-CASE" class="headerlink" title="1.6 CASE"></a>1.6 CASE</h4><ul>
<li>프로그래밍의 IF-THEN-ELSE와 비슷한 표현식입니다.</li>
</ul>
<h5 id="1-단순비교-해당-값에-따라-분류"><a href="#1-단순비교-해당-값에-따라-분류" class="headerlink" title="1. 단순비교 : 해당 값에 따라 분류"></a>1. 단순비교 : 해당 값에 따라 분류</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CASE value WHEN 1 THEN 'one'</div><div class="line">           WHEN 2 THEN 'two'</div><div class="line">           ELSE NULL</div><div class="line"><span class="keyword">END</span></div></pre></td></tr></table></figure>
<h5 id="2-조건비교-해당-조건에-따라-분류"><a href="#2-조건비교-해당-조건에-따라-분류" class="headerlink" title="2. 조건비교 : 해당 조건에 따라 분류"></a>2. 조건비교 : 해당 조건에 따라 분류</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CASE WHEN value = 1 THEN 'one'</div><div class="line">     WHEN value = 2 THEN 'two'</div><div class="line">     ELSE NULL</div><div class="line"><span class="keyword">END</span></div></pre></td></tr></table></figure>
<h5 id="3-DECODE-단순비교를-보다-짧게-표한하는-Oracle-함수"><a href="#3-DECODE-단순비교를-보다-짧게-표한하는-Oracle-함수" class="headerlink" title="3. DECODE : 단순비교를 보다 짧게 표한하는 Oracle 함수"></a>3. DECODE : 단순비교를 보다 짧게 표한하는 Oracle 함수</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DECODE(value, 1,'one', 2,'two', NULL)</div></pre></td></tr></table></figure>
<h4 id="1-7-NULL"><a href="#1-7-NULL" class="headerlink" title="1.7 NULL"></a>1.7 NULL</h4><ul>
<li>NULL 관련 문제는 반드시 출제된다.</li>
</ul>
<h5 id="NVL-Oracle-ISNULL-MS-SQL"><a href="#NVL-Oracle-ISNULL-MS-SQL" class="headerlink" title="NVL (Oracle), ISNULL (MS-SQL)"></a>NVL (Oracle), ISNULL (MS-SQL)</h5><p>해당 값이 NULL일 경우 2번째 인자의 값을 출력한다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> NVL(SAL,<span class="number">0</span>) <span class="keyword">FROM</span> EMP; <span class="comment">-- Oracle</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">ISNULL</span>(SAL,<span class="number">0</span>) <span class="keyword">FROM</span> EMP; <span class="comment">-- MS-SQL</span></div></pre></td></tr></table></figure></p>
<h5 id="COALESCE"><a href="#COALESCE" class="headerlink" title="COALESCE"></a>COALESCE</h5><p>인수 중 최초로 NULL이 아닌 값을 출력한다. 모두 NULL인 경우 NULL이 출력된다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, COMM, SAL, <span class="keyword">COALESCE</span>(COMM, SAL) COAL <span class="keyword">FROM</span> EMP;</div></pre></td></tr></table></figure></p>
<p>위 문장은 아래의 CASE문으로 표현한 것과 같다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, COMM, SAL,</div><div class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> COMM <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> COMM</div><div class="line">            <span class="keyword">WHEN</span> SAL <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> SAL</div><div class="line">            <span class="keyword">ELSE</span> <span class="literal">NULL</span></div><div class="line">       <span class="keyword">END</span> COAL</div><div class="line">  <span class="keyword">FROM</span> EMP;</div></pre></td></tr></table></figure></p>
<h4 id="1-8-집계함수-Aggregate-function"><a href="#1-8-집계함수-Aggregate-function" class="headerlink" title="1.8 집계함수 (Aggregate function)"></a>1.8 집계함수 (Aggregate function)</h4><ul>
<li>GROUP 당 단 1개의 값만 출력하는 함수</li>
<li>SELECT , HAVING, ORDER BY 절에서 사용할 수 있다.</li>
<li>집계함수에 들어온 NULL값은 계산에 포함시키지 않는다. (참고로 산술연산에 NULL 값이 포함되어 있으면 결과는 무조건 NULL이다.)</li>
</ul>
<h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5><p>GROUP BY에 명시된 컬럼, 집계함수의 결과값 만 가능하다.</p>
<h5 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h5><p>여기에 명시한 컬럼, 표현식 단위로 집계함수를 이용하여 계산한다.</p>
<h5 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h5><p>여기에 적은 조건에 부합하는 row만 집계함수 계산에 참여한다. (GROUP BY 이전 필터링 역할)</p>
<h5 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h5><p>집계된 결과 중 HAVING 절의 조건에 만족하는 것만 출력한다. (GROUP BY 이후 필터링 역할)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> D.DEPTNO, <span class="keyword">MAX</span>(DNAME) <span class="keyword">AS</span> DNAME, <span class="keyword">SUM</span>(SAL) <span class="keyword">AS</span> <span class="keyword">SUM</span>, <span class="keyword">AVG</span>(SAL) <span class="keyword">AS</span> <span class="keyword">AVG</span></div><div class="line">  <span class="keyword">FROM</span> DEPT D, EMP E</div><div class="line"> <span class="keyword">WHERE</span> D.DEPTNO = E.DEPTNO</div><div class="line">   <span class="keyword">AND</span> D.DEPTNO <span class="keyword">IN</span> (<span class="number">10</span>, <span class="number">30</span>)     <span class="comment">-- DEPTNO가 10, 30 인것만 집계로 계산</span></div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> D.DNAME</div><div class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(SAL) &gt;= <span class="number">10000</span>        <span class="comment">-- 계산된 결과중 10000이 넘는 것만 출력</span></div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">SUM</span>(SAL);</div></pre></td></tr></table></figure>
<h5 id="SELECT-문장-실행순서"><a href="#SELECT-문장-실행순서" class="headerlink" title="SELECT 문장 실행순서"></a>SELECT 문장 실행순서</h5><ol>
<li>FROM : 대상 Table 검색</li>
<li>WHERE : 검색 대상이 아닌 데이터 제거</li>
<li>GROUP BY : 집계할 단위로 그룹화</li>
<li>HAVING : 집계한 것중 조건에 맞는 것만 선택</li>
<li>SELECT : 출력할 값들을 계산 및 함수적용</li>
<li>ORDER BY : 데이터를 정렬하여서 출력</li>
</ol>
<h5 id="CASE-GROUP-BY"><a href="#CASE-GROUP-BY" class="headerlink" title="CASE - GROUP BY"></a>CASE - GROUP BY</h5><p>1정규화로 모델링된 테이블들에서 보고서를 만들때 많이 사용되는 기법이다.</p>
<p>예를 들어서 각 부서별로 입사월별 급여합계가 필요한 경우가 있다고 가정했을 때</p>
<p>먼저 부서, 사원명, 입사월, 급여를 출력해보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, DEPTNO, <span class="keyword">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> HIREDATE) M, SAL</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.01.decode.01.png?raw=true"></p>
<p>위 문장을 이용하여 각 월별로 컬럼을 생성하여 해당 월에 급여를 출력해보자.<br>(CASE랑 기능이 같은 DECODE를 사용하겠다.)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ENAME, DEPTNO,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">1</span>,SAL) <span class="keyword">AS</span> M01,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">2</span>,SAL) <span class="keyword">AS</span> M02,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">3</span>,SAL) <span class="keyword">AS</span> M03,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">4</span>,SAL) <span class="keyword">AS</span> M04,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">5</span>,SAL) <span class="keyword">AS</span> M05,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">6</span>,SAL) <span class="keyword">AS</span> M06,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">7</span>,SAL) <span class="keyword">AS</span> M07,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">8</span>,SAL) <span class="keyword">AS</span> M08,</div><div class="line">       <span class="keyword">DECODE</span>(M, <span class="number">9</span>,SAL) <span class="keyword">AS</span> M09,</div><div class="line">       <span class="keyword">DECODE</span>(M,<span class="number">10</span>,SAL) <span class="keyword">AS</span> M10,</div><div class="line">       <span class="keyword">DECODE</span>(M,<span class="number">11</span>,SAL) <span class="keyword">AS</span> M11,</div><div class="line">       <span class="keyword">DECODE</span>(M,<span class="number">12</span>,SAL) <span class="keyword">AS</span> M12</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> ENAME, DEPTNO, <span class="keyword">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> HIREDATE) M, SAL</div><div class="line">          <span class="keyword">FROM</span> SCOTT.EMP )</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> DEPTNO, ENAME;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.01.decode.02.png?raw=true"></p>
<p>이제 위 문장을 부서별로 GROUP BY 하는건 어렵지 않을 것이다.<br>참고로 NULL인 경우 0으로 표시하도록 NVL을 이용하였다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> DEPTNO,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">1</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M01,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">2</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M02,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">3</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M03,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">4</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M04,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">5</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M05,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">6</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M06,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">7</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M07,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">8</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M08,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M, <span class="number">9</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M09,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M,<span class="number">10</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M10,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M,<span class="number">11</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M11,</div><div class="line">       NVL(<span class="keyword">SUM</span>(<span class="keyword">DECODE</span>(M,<span class="number">12</span>,SAL)),<span class="number">0</span>) <span class="keyword">AS</span> M12</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> ENAME, DEPTNO, <span class="keyword">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> HIREDATE) M, SAL</div><div class="line">          <span class="keyword">FROM</span> SCOTT.EMP )</div><div class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPTNO;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.01.decode.03.png?raw=true"></p>
<h4 id="1-9-JOIN"><a href="#1-9-JOIN" class="headerlink" title="1.9 JOIN"></a>1.9 JOIN</h4><p>JOIN은 한번에 2개의 집합간에만 가능하다.<br>FROM A, B, C, D 가 있더라도 이 중 2개를 먼저 JOIN하고 그 결과를 다음과 JOIN하는 식으로 처리된다.</p>
<p>JOIN에 대해서는 2장에서 자세히 다루려했으나…<br>거기에 시간을 빼았겨서는 안될듯하여 그냥 여기서 간단히 다루겠습니다.</p>
<h5 id="JOIN-연산"><a href="#JOIN-연산" class="headerlink" title="JOIN 연산"></a>JOIN 연산</h5><ul>
<li>EQUI JOIN</li>
</ul>
<p>일반적으로 PK - FK 의 관계에서 많이 이루어진다.<br>WHERE 절이나 ON 절에서 <code>=</code> 연산으로 JOIN 한다.  </p>
<ul>
<li>Non EQUI JOIN</li>
</ul>
<p><code>=</code>연산이 아닌 연산으로 JOIN을 수행한다. ( BETWEEN, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;, != )</p>
<p>예를 들어 SALGRADE Table에 각 급여구간별 GRADE가 저장된 경우, EMP의 각 사원별로 급여등급을 구하고자할때 다음과 같이 작성하면 된다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> E.ENAME, E.DEPTNO, E.SAL, G.GRADE</div><div class="line">  <span class="keyword">FROM</span> SCOTT.EMP E, SCOTT.SALGRADE G</div><div class="line"> <span class="keyword">WHERE</span> E.SAL <span class="keyword">BETWEEN</span> G.LOSAL <span class="keyword">AND</span> G.HISAL</div><div class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SAL <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/DevStarSJ/Study/raw/master/Blog/Database/Oracle/sqlp/image/02.01.nonEQ.png?raw=true"></p>
<h5 id="JOIN-종류"><a href="#JOIN-종류" class="headerlink" title="JOIN 종류"></a>JOIN 종류</h5><ul>
<li><p>INNER JOIN</p>
<ul>
<li>양쪽 Table 모두 조건에 해당되는 데이터만 출력 (교집합)</li>
<li>Natural JOIN : INNER JOIN 에서 중복된 컬럼은 한번만 출력됨<ul>
<li>모든 일치된 칼럼에 대해서 JOIN 되지만, USING으로 원하는 컬럼만 선택이 가능 (실제로 해보니 USING 안쓰면 ERROR)<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP E, DEPT D <span class="keyword">WHERE</span> E.DEPTNO = D.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * EMP E <span class="keyword">INNER</span> <span class="keyword">JOIN</span> DEPT D <span class="keyword">ON</span> E.DEPTNO = D.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP NATUAL <span class="keyword">JOIN</span> DEPT <span class="keyword">USING</span> (DEPTNO);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>OUTER JOIN</p>
<ul>
<li>LEFT OUTER JOIN : 왼쪽 Table의 모든 row 출력, 오른쪽 Table에는 조건에 맞으면 출력하고 아니면 NULL</li>
<li>RIGHT OUTER JOIN : 오른쪽 Table의 모든 row 출력, 왼쪽 Table에는 조건에 맞으면 출력하고 아니면 NULL</li>
<li>FULL OUTER JOIN : 좌,우측을 모두 읽어서 서로 상대에게 있으면 출력 없으면 NULL (LEFT OUTER와 RIGHT OUTER를 UNION 한거랑 결과가 같음)</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP E <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> SCOTT.DEPT D <span class="keyword">ON</span> E.DEPTNO = D.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP E <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> SCOTT.DEPT D <span class="keyword">ON</span> E.DEPTNO = D.DEPTNO;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP E <span class="keyword">FULL</span> <span class="keyword">JOIN</span> SCOTT.DEPT D <span class="keyword">ON</span> E.DEPTNO = D.DEPTNO;</div></pre></td></tr></table></figure>
<ul>
<li>CROSS JOIN (CARTESIAN PRODUCT)<ul>
<li>양쪽 Table의 모든 row 들을 모두 관계짓는다. (A에 10개 row, B에 5개 row가 있을 경우 결과는 10 x 5 = 50개가 된다.)</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> SCOTT.DEPT;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SCOTT.EMP, SCOTT.DEPT;</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/21/02.01.sql.basic/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/01/21/02.01.sql.basic/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/20/01.02.modeling_performance/">
                            SQLP 1-2 데이터 모델과 성능
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-01-20T01:00:00+09:00">
	
		    Jan 20, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Database/">Database</a>, <a class="category-link" href="/categories/Database/SQLP/">SQLP</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="1과목-데이터-모델링의-이해"><a href="#1과목-데이터-모델링의-이해" class="headerlink" title="1과목 데이터 모델링의 이해"></a>1과목 데이터 모델링의 이해</h1><ul>
<li>10문제</li>
<li>외우기 보다는 반복적으로 읽어서 전반적인 내용을 이해하는 수준에서 마무리 하는것을 목표로 잡아야 겠습니다.</li>
</ul>
<h2 id="제-2장-데이터-모델과-성능"><a href="#제-2장-데이터-모델과-성능" class="headerlink" title="제 2장 데이터 모델과 성능"></a>제 2장 데이터 모델과 성능</h2><h3 id="1절-성능-데이터-모델링의-개요"><a href="#1절-성능-데이터-모델링의-개요" class="headerlink" title="1절 성능 데이터 모델링의 개요"></a>1절 성능 데이터 모델링의 개요</h3><ul>
<li>성능 데이터 모델링이란 ? 성능향상을 목적으로 모델링 하는 것</li>
<li>수행시점은 ? 빠르면 빠를수록 좋다. 분석/설계 단계에서는 운영때보다 더 적은 비용으로 가능하다.</li>
</ul>
<h4 id="성능-모델링-고려사항"><a href="#성능-모델링-고려사항" class="headerlink" title="성능 모델링 고려사항"></a>성능 모델링 고려사항</h4><ol>
<li>기본적으로 정규화를 수행해놓고 시작한다.</li>
<li>데이터베이스 용량산정</li>
<li>데이터베이스 트랜잭션 유형 파악</li>
<li>용량과 트랜잭션 유형에 따라 반정규화 수행</li>
<li>이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정</li>
<li>성능관점의 데이터 모델 검증</li>
</ol>
<p>일단 정규화를 완벽하게 해놓고 시작해야 한다.<br>그 상태에서 어느 엔터티에 트랜잭션이 들어오는지 알아봐야 하는데,<br>가장 간단한 방법이 용량이 집중적으로 늘어나는 엔터티를 찾는 것이다.<br>트랜잭션 유형도 파악할 필요가 있는데, CRUD, 시퀀스 다이어그램 등을 참조하면 된다.<br>파악된 트랜잭션 유형으로 SQL문장의 조인관계 테이블의 칼럼들을 파악할 수 있으며,<br>이렇게 모은 자료를 근거로 반정규화를 적용한다.<br>그 다음에 성능을 고려하야 PK/FK를 성능이 우수한 순서대로 칼럼 순서를 조정한다.<br>데이터 모델 규칙보다는 성능적인 측면을 충분히 고려해야 한다.</p>
<h3 id="2절-정규화와-성능"><a href="#2절-정규화와-성능" class="headerlink" title="2절 정규화와 성능"></a>2절 정규화와 성능</h3><p>일반적으로 정규화를 하면 조회시 JOIN이 늘어나기 때문에 성능이 저하되고,<br>DML (INSERT, UPDATE, DELETE) 연산의 성능이 향상된다.<br>하지만 모든 조회에서 성능이 저하되는 것은 아니고, 정규화를 해야만 성능이 향상되는 경우도 아주 많다.  </p>
<h5 id="정규화가-더-빠른-사례-1-컬럼이-많을-경우-버퍼-낭비"><a href="#정규화가-더-빠른-사례-1-컬럼이-많을-경우-버퍼-낭비" class="headerlink" title="정규화가 더 빠른 사례 1 : 컬럼이 많을 경우 (버퍼 낭비)"></a>정규화가 더 빠른 사례 1 : 컬럼이 많을 경우 (버퍼 낭비)</h5><p>원래 (반정규화된) 테이블에는 컬럼이 10개가 있었다.<br>조회시 해당 테이블에서 PK를 제외하고 2개의 컬럼만 자주 읽힌다.<br>오랜기간 동안의 이력중 PK 포함 그 3개의 컬럼만 자주 읽을 경우라면,<br>나머지 컬럼들을 PK값에 종속적인 테이블로 따로 분리를 하는 것이 유리하다.</p>
<h5 id="정규화가-더-빠른-사례-2-DISTINCT를-써야-할-경우"><a href="#정규화가-더-빠른-사례-2-DISTINCT를-써야-할-경우" class="headerlink" title="정규화가 더 빠른 사례 2 : DISTINCT를 써야 할 경우"></a>정규화가 더 빠른 사례 2 : DISTINCT를 써야 할 경우</h5><ul>
<li>일자별 거래물건 (100만건) : 물건번호(PK), 일자, 시간, 장소, …</li>
<li>일자별 거래내역 (2만건) : (일자, 장소) (PK) 금액, 건수, …</li>
</ul>
<p>광화문에서 거래된 금액을 구하는 SQL문은 다음과 같다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> B.금액</div><div class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 일자, 장소 <span class="keyword">FROM</span> 일자별거래물건 <span class="keyword">WHERE</span> 장소 = <span class="string">'광화문`) A, -- 100만건을 DISTINCT</span></div><div class="line">       일자별거래내역 B</div><div class="line"> WHERE A.일자 = B.일자</div><div class="line">   AND A.장소 = B.장소</div></pre></td></tr></table></figure>
<p>만약 위에서 DISTICT 한 결과가 5천건이라면, (일자, 장소) 를 별도의 테이블로 생성하는 것이 유리하다.</p>
<ul>
<li>일자별 거래물건 (100만건) : 물건번호(PK), 일자(FK), …</li>
<li>거래 (5천건) : 일자(PK), 시간, 장소</li>
<li>일자별 거래내역 (2만건) : (일자(FK), 장소) (PK) , 금액, 건수, …</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> B.금액</div><div class="line">  <span class="keyword">FROM</span> 거래 A, 일자별거래내역 B</div><div class="line"> <span class="keyword">WHERE</span> A.장소 = <span class="string">'광화문'</span> <span class="comment">-- 5천건</span></div><div class="line">   <span class="keyword">AND</span> A.일자 = B.일자</div><div class="line">   <span class="keyword">AND</span> A.장소 = B.장소</div></pre></td></tr></table></figure>
<h5 id="정규화가-더-빠른-사례-3-동일한-속성-형식이-여러개-나열된-경우"><a href="#정규화가-더-빠른-사례-3-동일한-속성-형식이-여러개-나열된-경우" class="headerlink" title="정규화가 더 빠른 사례 3 : 동일한 속성 형식이 여러개 나열된 경우"></a>정규화가 더 빠른 사례 3 : 동일한 속성 형식이 여러개 나열된 경우</h5><p>한 테이블에 속성1, 속성2, 속성3, … 이 여러개 있고, 각각에 INDEX가 걸려 있는 경우를 말한다.<br>이런 경우 DML 작업에서의 성능저하 때문에 INDEX를 두지 않거나, 1개 정도만 만드는 경우가 많다.<br>각 속성에 부합하는 데이터를 찾는 SQL문은 다음과 같다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ...</div><div class="line">  <span class="keyword">FROM</span> 장비</div><div class="line"> <span class="keyword">WHERE</span> 속성<span class="number">1</span> = <span class="string">'1'</span></div><div class="line">    <span class="keyword">OR</span> 속성<span class="number">2</span> = <span class="string">'2'</span></div><div class="line">    <span class="keyword">OR</span> 속성<span class="number">3</span> = <span class="string">'3'</span></div><div class="line">   ...</div></pre></td></tr></table></figure>
<p>각각의 속성에 모두 INDEX를 걸어둔 경우가 아니라면 Full Scan이나 Index Range Scan으로 넓은 범위를 찾아야 한다.</p>
<p>위 Table을 아래와 같이 먼저 정규화를 수행한다.</p>
<ul>
<li>장비 : 장비코드(PK), … (속성들은 모두 제외)</li>
<li>속성 : (장비코드(FK), 속성코드) (PK), 속성값</li>
</ul>
<p>위 상태에서는 속성 테이블에 PK로 인하여 INDEX가 생성되어 있으므로 조회시 성능이 향상된다.<br>조회는 다음과 같이 수행하면 된다.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ...</div><div class="line">  <span class="keyword">FROM</span> 장비 A, 속성 B</div><div class="line"> <span class="keyword">WHERE</span> A.장비코드 = B.장비코드</div><div class="line">   <span class="keyword">AND</span> (   (B.속성코드 = <span class="string">'1'</span> <span class="keyword">AND</span> B.속성값 = <span class="string">'1'</span>)</div><div class="line">        <span class="keyword">OR</span> (B.속성코드 = <span class="string">'2'</span> <span class="keyword">AND</span> B.속성값 = <span class="string">'2'</span>)</div><div class="line">        <span class="keyword">OR</span> (B.속성코드 = <span class="string">'3'</span> <span class="keyword">AND</span> B.속성값 = <span class="string">'3'</span>) )</div></pre></td></tr></table></figure></p>
<p>위와 같이 속성1, 2, 3 뿐만 아니라 이력 같은 데이터를 함께 보관하면서<br>장기재고 1개월 수량,금액 , 2개월 수량,금액 , 3개월 수량,금액 과 같은 형식의 컬럼이 있는경우<br>재고기간 별 수량,금액 을 별도 테이블로 분리하는 것이 유리하다.</p>
<h2 id="3절-반정규화와-성능"><a href="#3절-반정규화와-성능" class="headerlink" title="3절 반정규화와 성능"></a>3절 반정규화와 성능</h2><ul>
<li>반정규화란 ?</li>
</ul>
<p>성능향상, 개발, 운영의 편리를 위하여 데이터 중복을 각오하고 테이블을 통합하는 것을 의미한다.<br>단순히 JOIN이 귀찮아서 컬럼들을 통합하다가는 데이터의 무결성을 깨트리게 된다.  </p>
<h3 id="3-1-반정규화-적용방법"><a href="#3-1-반정규화-적용방법" class="headerlink" title="3.1 반정규화 적용방법"></a>3.1 반정규화 적용방법</h3><ol>
<li>반정규화 대상조사<ul>
<li>자주 사용되는 table에 range-scan을 하는 경우</li>
<li>대량의 데이터가 있는 table에 range-scan을 하는 경우</li>
<li>통계성 프로세스에서 통계정보를 필요로 할때 -&gt; 별도의 통계테이블 생성 (반정규화)</li>
<li>지나치게 많은 JOIN으로 조회 작업이 기술적으로 어려워 질때</li>
</ul>
</li>
<li>대안 검토 (반정규화가 아닌 다른 방법들)<ul>
<li>지나치게 많은 JOIN -&gt; View 생성</li>
<li>대량의 데이터 처리, 부분처리가 유리한 경우 -&gt; 클러스터링 적용 또는 INDEX 조정 (단 DML이 적고 조회 위주의 테이블에만 효과적)</li>
<li>대량의 데이터를 PK 성격에 따라 분리가 가능한 경우라면 -&gt; 파티셔닝 기법 적용해서 물리적으로 분리</li>
<li>Application 로직을 변경하여 성능 개선</li>
</ul>
</li>
<li>반정규화 적용<ul>
<li>테이블 반정규화</li>
<li>속성 반정규화</li>
<li>관계 반정규화</li>
</ul>
</li>
</ol>
<p>###3.2 반정규화 기법</p>
<ol>
<li>테이블 반정규화<ul>
<li>테이블 병합 : 1:1 , 1:M , 슈퍼/서브타입 관계의 테이블들을 병합하여 성능향상</li>
<li>테이블 분할<ul>
<li>수직분할 : 컬럼단위로 테이블을 1:1로 분리하여 트랜잭션을 분산 (트랜잭션의 유형이 선행되어야 함)</li>
<li>수평분할 : row 단위로 테이블을 분리하여 트랜잭션을 분산</li>
</ul>
</li>
<li>테이블 추가<ul>
<li>중복테이블 추가 : 원격 등의 환경에서 서버가 다른 경우 동일한 테이블 중복생성</li>
<li>통계테이블 추가 : 통계값을 미리 계산해 둠</li>
<li>이력테이블 추가 : 마스터 테이블에 존재하는 레코드를 중복으로 이력테이블에 저장</li>
<li>부분테이블 추가 : 자주 이용하는 집중화된 칼럼들을 모아놓은 별도 테이블 생성</li>
</ul>
</li>
</ul>
</li>
<li>컬럼 반정규화<ul>
<li>중복칼럼 추가 : JOIN을 줄이기 위함</li>
<li>파생칼럼 추가 : 미리 계산하여 저장</li>
<li>이력테이블 칼럼추가 : 이력테이블은 대용량이므로 처리속도가 느림. 그 중 자주 사용되는 컬럼을 추가 (최근값, 시작, 종료일자…)</li>
<li>PK에 의한 칼럼추가 : 복합의미 단일PK의 경우, 그 중 특정 값만 자주 사용한다면 일반속성으로 추가</li>
<li>응용시스템 오작동을 위한 칼럼추가 : 잘못 처리되었을 경우를 대비한 백업용 칼럼</li>
</ul>
</li>
<li>관계 반정규화<ul>
<li>중복관계 추가 : 여러 경로를 거쳐야 하는 JOIN을 줄이고자 관계추가</li>
</ul>
</li>
</ol>
<h3 id="반정규화가-더빠른-사례-1-이력테이블의-최근값이-필요한-경우"><a href="#반정규화가-더빠른-사례-1-이력테이블의-최근값이-필요한-경우" class="headerlink" title="반정규화가 더빠른 사례 1 : 이력테이블의 최근값이 필요한 경우"></a>반정규화가 더빠른 사례 1 : 이력테이블의 최근값이 필요한 경우</h3><ul>
<li>고객 Table : 고객번호(PK), 고객명</li>
<li>전화번호 Table : (고객번호(FK), 순번) (PK) , 전화번호</li>
<li>메일주소 Table : (고객번호(FK), 순번) (PK) , 메일주소</li>
</ul>
<p>고객의 전화번호, 메일주소의 변경이력까지 같이 관리해야 할 경우 위와 같이 전화번호, 메일주소를 별도의 Table로 관리하여야 한다.<br>이 경우 특정 고객의 가장 최근 전화번호와 메일주소를 알고 싶다면 아래와 같이 SQL문을 작성해야 한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> A.고객명, D.전화번호, G.메일주소</div><div class="line">  <span class="keyword">FROM</span> 고객 A,</div><div class="line">       (<span class="keyword">SELECT</span> B.고객번호 B.전화번호</div><div class="line">          <span class="keyword">FROM</span> 전화번호 B,</div><div class="line">               (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(순번) <span class="keyword">FROM</span> 전화번호 <span class="keyword">WHERE</span> 고객번호 = :custNo) C</div><div class="line">         <span class="keyword">WHERE</span> B.고객번호 = C.고객번호) D,</div><div class="line">        (<span class="keyword">SELECT</span> E.고객번호 E.메일주소</div><div class="line">          <span class="keyword">FROM</span> 메일주소 E,</div><div class="line">               (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(순번) <span class="keyword">FROM</span> 메일주소 <span class="keyword">WHERE</span> 고객번호 = :custNo) F</div><div class="line">         <span class="keyword">WHERE</span> E.고객번호 = F.고객번호) G,</div><div class="line"> <span class="keyword">WHERE</span> A.고객번호 = D.고객번호</div><div class="line">   <span class="keyword">AND</span> A.고객번호 = G.고객번호</div></pre></td></tr></table></figure>
<p>고객 Table에 최근전화번호, 최근메일주소 칼럼을 추가하여 관리할 경우에는 SQL문을 더 쉽게 작성이 가능하다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> 고객명, 최근전화번호, 최근메일주소</div><div class="line">  <span class="keyword">FROM</span> 고객</div><div class="line"> <span class="keyword">WHERE</span> 고객번호 = :custNo</div></pre></td></tr></table></figure>
<h3 id="반정규화가-더빠른-사례-2-원격서버와-JOIN할-경우"><a href="#반정규화가-더빠른-사례-2-원격서버와-JOIN할-경우" class="headerlink" title="반정규화가 더빠른 사례 2 : 원격서버와 JOIN할 경우"></a>반정규화가 더빠른 사례 2 : 원격서버와 JOIN할 경우</h3><ul>
<li>서버 A<ul>
<li>부서 Table : 부서코드(PK), 부서명</li>
<li>접수 Table : (접수번호, 부서코드(FK))(PK), …</li>
</ul>
</li>
<li>서버 B<ul>
<li>연계 Table : (연계번호, (접수번호, 부서코드)(FK))(PK), 연계상태, 연계일자, …</li>
</ul>
</li>
</ul>
<p>특정 일자 사이의 부서명에 따른 연계상태를 알고 싶은 경우 아래와 같이 SQL을 작성해야 한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> A.부서명, C.연계상태</div><div class="line">  <span class="keyword">FROM</span> 부서 A, 접수 B, 연계 C</div><div class="line"> <span class="keyword">WHERE</span> A.부서코드 = B.부서코드</div><div class="line">   <span class="keyword">AND</span> B.부서코드 = C.부서코드 <span class="keyword">AND</span> B.접수번호 = C.접수번호 <span class="comment">-- 서버A와 서버B의 원격 JOIN이 발생</span></div><div class="line">   <span class="keyword">AND</span> C.연계일자 <span class="keyword">BETWEEN</span> :startdate <span class="keyword">AND</span> :enddate</div></pre></td></tr></table></figure>
<p>원격 JOIN이 일어나서 성능이 저하 될수 있다.<br>부서명 칼럼을 연계 Table에 중복생성하면 원격JOIN을 없앨수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> 부서명, 연계상태</div><div class="line">  <span class="keyword">FROM</span> 연계</div><div class="line"> <span class="keyword">WHERE</span> 연계일자 <span class="keyword">BETWEEN</span> :startdate <span class="keyword">AND</span> :enddate</div></pre></td></tr></table></figure>
<p>하지만, 반정규화를 할 경우 데이터 입력, 수정, 삭제시 성능이 저하 된다는 점을 명심해야 한다.</p>
<h2 id="4절-대량-데이터에-따른-성능"><a href="#4절-대량-데이터에-따른-성능" class="headerlink" title="4절 대량 데이터에 따른 성능"></a>4절 대량 데이터에 따른 성능</h2><h3 id="4-1-칼럼-수가-많은-경우"><a href="#4-1-칼럼-수가-많은-경우" class="headerlink" title="4.1 칼럼 수가 많은 경우"></a>4.1 칼럼 수가 많은 경우</h3><ul>
<li>많은 DISK I/O 및 buffer miss를 발생시킨다. : 레코드 크기가 거져서 블록 당 적제된 레코드 수가 줄어든다.</li>
<li>200개가 넘는 컬럼의 데이터를 한번에 다 조회할 일이 과연 얼마나 될까 ? 화면에 다 표현은 가능한가 ?</li>
</ul>
<p>테이블을 분리시키는 방법이 있다.<br>도서관에서 관리하는 아래와 같은 table을 살펴보자.</p>
<ul>
<li>도서정보 Table : 도서번호(PK), 위치, 수량, 책정보관련 칼럼 10여개, 전자출판관련 칼럼 10여개, 대체제품관련 칼럼 10여개, …</li>
</ul>
<p>위의 경우 전자출판관련 정보나 대체제품관련 정보는 자주 이용되지 않는 항목이라면 별도의 table로 분리하는게 효과적이다.</p>
<ul>
<li>도서정보 Table : 도서번호(PK), 위치, 수량, 책정보관련 칼럼 10여개, …</li>
<li>전자출판 Table : 도서번호(FK, PK), 전자출판관련 칼럼 10여개</li>
<li>대체제품 Table : 도서번호(FK, PK), 대체제품관련 칼럼 10여개</li>
</ul>
<h3 id="4-2-테이블에-데이터가-많은-경우"><a href="#4-2-테이블에-데이터가-많은-경우" class="headerlink" title="4.2 테이블에 데이터가 많은 경우"></a>4.2 테이블에 데이터가 많은 경우</h3><ul>
<li>파티션(partition)을 적용하여 레코드를 분리하면 된다.</li>
<li>파티션 종류<ul>
<li>Range Partition : PK값의 범위별로 분리 (ex. 핸드폰요금 Table의 경우 요금일자를 범위로 하여 매 달마다 파티션 분리)</li>
<li>List Partition : PK의 특정값별로 분리 (ex. 핸드폰대리점 Table의 경우 사업소의 위치지역 별로 파티션 분리)</li>
<li>Hash Partition : PK의 해쉬값으로 분리 (범위 검색이 안되며, 데이터 보관주기를 통한 삭제 등의 관리가 어렵다.)</li>
</ul>
</li>
</ul>
<h3 id="4-3-테이블의-수평-수직-분할-절차"><a href="#4-3-테이블의-수평-수직-분할-절차" class="headerlink" title="4.3 테이블의 수평/수직 분할 절차"></a>4.3 테이블의 수평/수직 분할 절차</h3><ol>
<li>데이터 모델링 완성</li>
<li>데이터베이스 용량산정<ul>
<li>어느 테이블에 데이터가 대용량화 되는지 분석</li>
</ul>
</li>
<li>대량 데이터가 처리되는 테이블의 트랜잭션 처리 패턴 분석<ul>
<li>대용량화 테이블에 컬럼수가 많은가 ?</li>
<li>대용량화 테이블에 레코드수가 많은가 ?</li>
</ul>
</li>
<li>컬럼 단위 집중화, 로우 단위 집중화를 분석하여 테이블 분리 검토<ul>
<li>트랜잭션에서 많은 컬럼들을 항상 다 사용하는가 ? 테이블 분리가 가능한가 ?</li>
<li>트랜잭션에서 특정 범위 단위로 작업을 많이 하는가 ? 해당 범위별로 파티셔닝이 가능한가 ?</li>
</ul>
</li>
</ol>
<h2 id="5절-데이터베이스-구조와-성능"><a href="#5절-데이터베이스-구조와-성능" class="headerlink" title="5절 데이터베이스 구조와 성능"></a>5절 데이터베이스 구조와 성능</h2><h3 id="5-1-슈퍼-서브타입-데이터-모델링"><a href="#5-1-슈퍼-서브타입-데이터-모델링" class="headerlink" title="5.1 슈퍼/서브타입 데이터 모델링"></a>5.1 슈퍼/서브타입 데이터 모델링</h3><ul>
<li>공통부분을 슈퍼타입으로 모델링하고 이를 상속받아서 차이가 있는 속성별로 별도의 서브엔터티로 구분</li>
<li>논리적 데이터 모델링, 분석단계에서 사용됨</li>
<li>물리적으로는 3가지 형태로 구현함 ( One to One Type (1:1) , Plus Type (슈퍼+서브), Single Type (All in One) )</li>
<li>트랜잭션의 유형을 보고 각각의 형태로 구현해야 한다.</li>
</ul>
<h5 id="1-개별로-발생하는-트랜잭션에는-개별로-구현하는게-유리-1-1"><a href="#1-개별로-발생하는-트랜잭션에는-개별로-구현하는게-유리-1-1" class="headerlink" title="1. 개별로 발생하는 트랜잭션에는 개별로 구현하는게 유리 (1:1)"></a>1. 개별로 발생하는 트랜잭션에는 개별로 구현하는게 유리 (1:1)</h5><p>부동산거래 관리 어플리케이션에서 계약 내역에 이해관계자들(매수인,매도인,중개인)이 표시가 되고 상세를 눌렀을 경우 해당 인물에 대한 상세정보가 나오는 경우라면 이해관계자들을 별도의 테이블로 관리하는 것이 좋습니다.</p>
<ul>
<li>계약 Table : 계약번호(PK), … , 중개인번호(FK), 매도인번호(FK), 매수인번호(FK)</li>
<li>이해관계자 Table : 이해관계자번호(FK) , 역할, …</li>
</ul>
<h5 id="2-슈파타입-서브타입에-대해-발생되는-트랜잭션에-대해서는-슈퍼타입-서브타입으로-구분"><a href="#2-슈파타입-서브타입에-대해-발생되는-트랜잭션에-대해서는-슈퍼타입-서브타입으로-구분" class="headerlink" title="2. 슈파타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입으로 구분"></a>2. 슈파타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입으로 구분</h5><p>위 예제에서 중개인이 10만명, 매수인이 500만명, 매도인이 500만명인 경우 (즉, 이해관계자 Table은 1010만건)<br>중개인에 대한 처리가 필요한 경우 최대10만건의 데이터가 필요한데 최대1010만건을 읽을 경우도 발생할 수 있다.<br>이럴때는 슈퍼/서브타입으로 분리하는 것이 좋다.</p>
<ul>
<li>계약 Table : 계약반호(PK), …</li>
<li>이해관계자 Table : 계약번호(PK), 중개인번호(FK), 매도인번호(FK), 매수인번호(FK)</li>
<li>중개인 Table : 중개인번호(PK), …</li>
<li>매도인 Table : 매도인번호(PK), …</li>
<li>매수인 Table : 매수인번호(PK), …</li>
</ul>
<h5 id="3-전체를-하나로-묶어서-트랜잭션이-발생하는-경우"><a href="#3-전체를-하나로-묶어서-트랜잭션이-발생하는-경우" class="headerlink" title="3. 전체를 하나로 묶어서 트랜잭션이 발생하는 경우"></a>3. 전체를 하나로 묶어서 트랜잭션이 발생하는 경우</h5><p>항상 계약관련 사항을 조회하는데, 각 이해관계자들의 정보까지 동시에 화면에 출력이 되는 경우라면 하나의 테이블로 관리하는게 유리하다.</p>
<ul>
<li>계약 Table : 계약번호(PK), … , 중개인 정보들, 매도인 정보들), 매수인 정보들</li>
</ul>
<h3 id="5-2-INDEX-특성을-고려한-PK-FK-설정"><a href="#5-2-INDEX-특성을-고려한-PK-FK-설정" class="headerlink" title="5.2 INDEX 특성을 고려한 PK/FK 설정"></a>5.2 INDEX 특성을 고려한 PK/FK 설정</h3><ul>
<li>PK는 Unique Index를 자동으로 생성한다. 이하 생략 (자세한 내용은 뒤에 나올 Index 부분을 참조)</li>
<li>FK도 Index를 생성한다. FK가 없어도 WHERE 절에서 조건을 적어주는 것으로 SQL 작성이 가능하지만, Full Table Scan이 될 수 있다. 가능하면 일단 FK를 생성하는 것을 기본 정책으로하고, 트랜잭션을 분석하여 거의 활용되지 않을때는 지우는 것이 적절한 방법이다.</li>
</ul>
<h2 id="6절-분산-데이터베이스와-성능"><a href="#6절-분산-데이터베이스와-성능" class="headerlink" title="6절 분산 데이터베이스와 성능"></a>6절 분산 데이터베이스와 성능</h2><h3 id="6-1-분산-데이터베이스의-투명성-transparency-6가지-조건을-만족해야-한다"><a href="#6-1-분산-데이터베이스의-투명성-transparency-6가지-조건을-만족해야-한다" class="headerlink" title="6.1 분산 데이터베이스의 투명성(transparency) : 6가지 조건을 만족해야 한다."></a>6.1 분산 데이터베이스의 투명성(transparency) : 6가지 조건을 만족해야 한다.</h3><ul>
<li>분할 투명성 (단편화) : 하나의 논리적인 relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장</li>
<li>위치 투명성 : 위치정보는 system catalog에 유지되어야 하며, 사용자가 데이터 사용시는 명시할 필요가 없어야 함</li>
<li>지역사상 투명성 : 지역DBMS와 물리적 DB 사이의 Mapping 보장. 지역시스템과 무관한 이름 사용 가능</li>
<li>중복 투명성 : DB 객체가 여러 site에 중복되어 있는지 알 필요가 없음</li>
<li>장애 투명성 : DBMS의 장애와 무관하게 Transaction 일관성 유지</li>
<li>병행 투명성 : 다수 Transaction 수행시 일관성 유지, 분산 2단계 Locking을 이용하여 구현</li>
</ul>
<h3 id="6-2-장단점"><a href="#6-2-장단점" class="headerlink" title="6.2 장단점"></a>6.2 장단점</h3><ul>
<li>장점<ul>
<li>신뢰성, 가용성</li>
<li>빠른 응답 속도와 통신비용 절감</li>
<li>각 지역 사용자의 요구 수용 증대</li>
<li>지역 자치성, 점증적 시스템 용량 확장</li>
</ul>
</li>
<li>단점<ul>
<li>소프트웨어 개발 비용</li>
<li>처리 비용</li>
<li>설계, 관리의 복잡성과 비용</li>
<li>불규칙한 응답속도</li>
<li>통제가 어려움</li>
</ul>
</li>
</ul>
<h3 id="6-3-적용-기법"><a href="#6-3-적용-기법" class="headerlink" title="6.3 적용 기법"></a>6.3 적용 기법</h3><h4 id="1-테이블-분산"><a href="#1-테이블-분산" class="headerlink" title="1. 테이블 분산"></a>1. 테이블 분산</h4><p>테이블을 위치별로 분산 (ex. 자재품목은 본사, 생산제품은 지사)</p>
<h4 id="2-테이블-분할-fragmentation-분산"><a href="#2-테이블-분할-fragmentation-분산" class="headerlink" title="2. 테이블 분할(fragmentation) 분산"></a>2. 테이블 분할(fragmentation) 분산</h4><ul>
<li>수평분할 : 지사별로 각각 다른 PK를 가진 레코드들을 저장. 통합처리시 수행속도가 느려짐</li>
<li>수직분할 : 사이트별로 동일한 PK를 가진 레코드를 저장하나 컬럼을 분리해서 저장 (ex. 본사에는 단가를 저장, 각 지사에는 지사별 재고량을 저장)</li>
</ul>
<h4 id="3-테이블-복제-replication-분산"><a href="#3-테이블-복제-replication-분산" class="headerlink" title="3. 테이블 복제(replication) 분산"></a>3. 테이블 복제(replication) 분산</h4><p>동일한 테이블을 여러 곳에서 동시에 생성하여 관리</p>
<ul>
<li>부분복제(segment replication) : 통합본은 본사에 있고, 각 지사별로 수평분할 형태. 데이터 입력은 지사에서 하고, 본사에서 지사 데이터를 이용하여 통합</li>
<li>광역복제 (broadcast replication) : 본사의 데이터를 지사에서도 동일하게 가지고 있음. 본사를 통해서 입력을하고, 주기별로 해당 데이터를 지사로 복사</li>
</ul>
<h4 id="4-테이블-요약-summarization-분산"><a href="#4-테이블-요약-summarization-분산" class="headerlink" title="4. 테이블 요약(summarization) 분산"></a>4. 테이블 요약(summarization) 분산</h4><ul>
<li>분석요약 (rollup replication) : 지사별로 존재하는 요약정보를 본사에서 통합하여 지사로 전송 (모든 지사가 동일 정보)</li>
<li>통합요약 (consolidation replication) : 지사별로 존재하는 다른 정보를 본사에서 통합하여 관리 (모든 지사가 다른 정보)</li>
</ul>
<h3 id="6-4-분산-데이터베이스를-통한-성능-향상-사례"><a href="#6-4-분산-데이터베이스를-통한-성능-향상-사례" class="headerlink" title="6.4 분산 데이터베이스를 통한 성능 향상 사례"></a>6.4 분산 데이터베이스를 통한 성능 향상 사례</h3><p>인사팀DB에만 직원 정보가 있는 경우 업무DB에서는 항상 인사팀DB를 JOIN해야함.<br>직원 정보를 각 업무DB로 복사를 하면 성능이 향상 됨</p>
<ul>
<li>성능이 중요한 사이트에 적용</li>
<li>master 성격의 table을 분산하면 성능이 향상됨</li>
<li>실시간 동기화가 요구되지 않으면 유리. 특정시간에 batch로 동기화</li>
<li>특정 서버에 부하가 집중될떄 분산시킬수 있음</li>
<li>백업사이트를 구성할 때 분산기능을 적용할 수 있음</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/01/20/01.02.modeling_performance/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a href="/2016/01/20/01.02.modeling_performance/">
                <div class="postShorten-thumbnailimg">
                    <img alt="" itemprop="image" src="undefined"/>
                </div>
            </a>
            
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        <li class="pagination-prev">
            
                <a class="btn btn--default btn--small" href="/ ">
            
                <i class="fa fa-angle-left text-base icon-mr"></i>
                    <span>NEWER POSTS</span>
            </a>
        </li>
        
        
        <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/categories/Database/SQLP/page/3/">
                    <span>OLDER POSTS</span>
                <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
        </li>
        
        <li class="pagination-number">page 2 of 3</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 Yun Seok-joon. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">Yun Seok-joon</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Seoul, South Korea
            </div>
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">no post found</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2015/11/10/Devops.Jenkins/">
                            <h3 class="media-heading">Install Jenkins</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Nov 10, 2015
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/20/01.01.modeling/">
                            <h3 class="media-heading">SQLP 1-1 데이터 모델링</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 20, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/20/01.02.modeling_performance/">
                            <h3 class="media-heading">SQLP 1-2 데이터 모델과 성능</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 20, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/21/02.01.sql.basic/">
                            <h3 class="media-heading">SQLP 2-1 SQL 기본</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 21, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/23/02.02.sql.adv/">
                            <h3 class="media-heading">SQLP 2-2-1 SET, Hierarchical Query, Sub-query</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 23, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/25/02.03.group/">
                            <h3 class="media-heading">SQLP 2-2-2 GROUP function</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 25, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/25/02.04.window/">
                            <h3 class="media-heading">SQLP 2-2-3 Window function</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 25, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/26/02.05.dcl/">
                            <h3 class="media-heading">SQLP 2-2-4 DCL</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 26, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/26/02.06.plsql/">
                            <h3 class="media-heading">SQLP 2-2-5 PL/SQL</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 26, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://DevStarSJ.github.io/2016/01/27/02.07.optimizer/">
                            <h3 class="media-heading">SQLP 2-3 Optimizing SQL</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 27, 2016
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="no post found"
                data-message-one="1 post found"
                data-message-other="{n} posts found">
                59 posts found
            </p>
        </div>
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/jquery.fancybox-thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    </body>
</html>
