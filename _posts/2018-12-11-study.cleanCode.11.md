---
layout: post
title: "Clean Code 11. System"
subtitle:  
categories: study
tags: cleanCode
comments: true
---

### 시스템 제작(construction)과 사용(use)을 분리하라

> 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의종성을 서로 `연결`하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.

**관심사 분리**는 이 분야에서 가장 오래되고 중요한 설계 기법 중 하나이다.

```java
public Service getService() {
	if (service == null)
		service = new MyServiceImpl(...); // Good enough default for most cases?
	return service;
}
```

**Lazy Initialization/Evaluation** 코드이다. 실제로 필요할때까지 객체를 생성하지 않으므로 시작 시간이 빨라지고, 어떤 경우에도 null을 반환하지 않는다. 하지만 getService 메서드가 MyserviceImpl과 그 생성자 인수에 명시적으로 의존한다. 만약 MyServiceImpl이 무거운 객체라면 테스트 시 getService를 호출할 때마다 부하가 걸린다. 그걸 위해서 테스트를 위한  **[Test Double](https://en.wikipedia.org/wiki/Test_double) / Mock Object**를 service에 대입해야 하는데, 그러면 기존 run-time 로직이다 보니 해당 객체가 null인 경로와 아닌 경로를 모두 테스트 해야 한다. 즉, 작게나마 **단일 책임 원칙 (SRP : Single Responsibility Principle)**을 위배한다.

설정과 실행은 분리해야 모듈성이 높아진다. 또한 주요 의존성을 해소하기 위한 방식, 즉 전반적이며 일관적인 방식도 필요하다.

#### Main 분리

![](https://raw.githubusercontent.com/DevStarSJ/DevStarSJ.github.io/master/assets/img/post/2018-12-11.cleanCode.01.png)

가장 간단한 방법이다. 생성과 관련된 코드를 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다. 즉, 애플리케이션은 객체가 생성되는 과정을 전혀 모른다는 뜻이다.

#### Factory

![](https://raw.githubusercontent.com/DevStarSJ/DevStarSJ.github.io/master/assets/img/post/2018-12-11.cleanCode.02.png)

객체 생성 시점을 애플리케이션이 결정할 필요가 있을때는 **[Abstract Factory](https://en.m.wikipedia.org/wiki/Abstract_factory_pattern)** 패턴을 사용하여 생성 코드를 감춘다.

#### 의존성 주입(Dependency Injection)

[의존성 주입](https://en.wikipedia.org/wiki/Dependency_injection)은 **제어 역전 (IoC : Inversion of Control)** 기법을 의존성 관리에 적용한 메커니즘이다. 의존성 생성에 대한 책임을 다른 객체에게 맡기므로 **SRP**를 지키게 된다.

```java
MyService myService = (MyService)(jndiContext.lookup(“NameOfMyService”));
```

### 확장(Scaling)

작은 시골마을이 도시로 성장한 뒤 좁은 도로 때문에 지옥을 경험하는 경우가 많다. 하지만, 성장할지 모르는 작은 마을을 지을때 처음부터 확장을 고려하여 6차선 도로를 지으려 할까? 그 비용을 마을에서 반길까?

*처음부터 올바르게* 시스템을 만들 수 있다는 믿음은 미신이다. 오늘은 오늘 필요한 것을 만들고, 내일은 거기에 맞춰 확장하면 된다. 이것이 반복적이로 점진적인 애자일 방식의 핵심이다. TDD와 Refactoring으로 얻어지는 Clean Code는 확장하기 쉽게 만든다. 코드 수준에서는 이게 말이 되지만 시스템 수준에서는 어떤가? 단순한 아키텍처를 복잡한 아키텍처로 조금씩 키울 수는 없는가?

> 소프트웨어 시스템은 물리적인 시스템과는 다르다. 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.

관심사(Concern)를 적절히 분리하지 못했다면 아키텍처의 점진적 성장이 어렵다.

###### An EJB2 local interface for a Bank EJB
```java
package com.example.banking;
import java.util.Collections;
import javax.ejb.*;

public interface BankLocal extends java.ejb.EJBLocalObject {
    String getStreetAddr1() throws EJBException;
    String getStreetAddr2() throws EJBException;
    String getCity() throws EJBException;
    String getState() throws EJBException;
    String getZipCode() throws EJBException;
    void setStreetAddr1(String street1) throws EJBException;
    void setStreetAddr2(String street2) throws EJBException;
    void setCity(String city) throws EJBException;
    void setState(String state) throws EJBException;
    void setZipCode(String zip) throws EJBException;
    Collection getAccounts() throws EJBException;
    void setAccounts(Collection accounts) throws EJBException;
    void addAccount(AccountDTO accountDTO) throws EJBException;
}
```

###### The corresponding EJB2 Entity Bean Implementation
```java
package com.example.banking;
import java.util.Collections;
import javax.ejb.*;

public abstract class Bank implements javax.ejb.EntityBean {
    // Business logic...
    public abstract String getStreetAddr1();
    public abstract String getStreetAddr2();
    public abstract String getCity();
    public abstract String getState();
    public abstract String getZipCode();
    public abstract void setStreetAddr1(String street1);
    public abstract void setStreetAddr2(String street2);
    public abstract void setCity(String city);
    public abstract void setState(String state);
    public abstract void setZipCode(String zip);
    public abstract Collection getAccounts();
    public abstract void setAccounts(Collection accounts);
    
    public void addAccount(AccountDTO accountDTO) {
        InitialContext context = new InitialContext();
        AccountHomeLocal accountHome = context.lookup("AccountHomeLocal");
        AccountLocal account = accountHome.create(accountDTO);
        Collection accounts = getAccounts();
        accounts.add(account);
    }
    
    // EJB container logic
    public abstract void setId(Integer id);
    public abstract Integer getId();
    public Integer ejbCreate(Integer id) { ... }
    public void ejbPostCreate(Integer id) { ... }
    
    // The rest had to be implemented but were usually empty:
    public void setEntityContext(EntityContext ctx) {}
    public void unsetEntityContext() {}
    public void ejbActivate() {}
    public void ejbPassivate() {}
    public void ejbLoad() {}
    public void ejbStore() {}
    public void ejbRemove() {}
}
```

위와 같응 전형적인 EJB2 객체 구조에는 문제가 있다.
1. 비지니스 로직이 EJB2 컨테이너와 강하게 결합되어 있어, 클래스 생성시 컨테이너에서 파생해야 하며 컨테이너의 다양한 lifecycle 메서드를 제공해야 한다.
2. 비지니스 로직이 덩치 큰 컨테이너와 밀접하게 결합되어 독자적인 단위 테스트가 어렵다.
3. OOP가 무너진다. 빈은 다른 빈을 상속 받지 못한다. 일반적으로 EJB2 빈은 DTO(Data Transfer Object)를 정의한다. DTO는 메서드가 없는 사실상의 구조체이므로 동일한 정보를 저장하는 자료 유형이 두 개가 된다. 그래서 객체간의 자료를 복사하는 반복적인 코드가 필요하다.

